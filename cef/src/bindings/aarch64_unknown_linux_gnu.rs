#![allow(
    dead_code,
    improper_ctypes_definitions,
    non_camel_case_types,
    unused_variables
)]
use crate::rc::{ConvertParam, ConvertReturnValue, Rc, RcImpl, RefGuard, WrapParamRef};
use cef_sys::*;

/// Perform the conversion between CEF and Rust types in field initializers.
fn init_array_field<T, U, const N: usize>(mut value: [U; N]) -> [T; N]
where
    T: Sized,
    U: Sized + Into<T>,
{
    std::array::from_fn(move |i| {
        let mut elem = unsafe { std::mem::zeroed() };
        std::mem::swap(&mut value[i], &mut elem);
        elem.into()
    })
}

/// See [cef_string_wide_t] for more documentation.
pub type CefStringUserfreeWide = *mut CefStringWide;

/// See [cef_string_utf8_t] for more documentation.
pub type CefStringUserfreeUtf8 = *mut CefStringUtf8;

/// See [cef_string_utf16_t] for more documentation.
pub type CefStringUserfreeUtf16 = *mut CefStringUtf16;

/// See [char16_t] for more documentation.
pub type Char = char16_t;

/// See [cef_string_userfree_utf16_t] for more documentation.
pub type CefStringUserfree = *mut CefStringUtf16;

/// See [cef_string_utf16_t] for more documentation.
pub type CefString = CefStringUtf16;

/// See [_cef_accelerated_paint_native_pixmap_plane_info_t] for more documentation.
pub type AcceleratedPaintNativePixmapPlane = AcceleratedPaintNativePixmapPlaneInfo;

/// See [u32] for more documentation.
pub type Color = u32;

/// See [_cef_string_wide_t] for more documentation.
pub use crate::string::CefStringWide;

/// See [_cef_string_utf8_t] for more documentation.
pub use crate::string::CefStringUtf8;

/// See [_cef_string_utf16_t] for more documentation.
pub use crate::string::CefStringUtf16;

/// See [_cef_string_list_t] for more documentation.
pub use crate::string::CefStringList;

/// See [_cef_string_map_t] for more documentation.
pub use crate::string::CefStringMap;

/// See [_cef_string_multimap_t] for more documentation.
pub use crate::string::CefStringMultimap;

/// See [_cef_basetime_t] for more documentation.
#[derive(Clone)]
pub struct Basetime {
    pub val: i64,
}
impl From<_cef_basetime_t> for Basetime {
    fn from(value: _cef_basetime_t) -> Self {
        Self {
            val: value.val.into(),
        }
    }
}
impl Into<_cef_basetime_t> for Basetime {
    fn into(self) -> _cef_basetime_t {
        _cef_basetime_t {
            val: self.val.into(),
        }
    }
}
impl Default for Basetime {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_time_t] for more documentation.
#[derive(Clone)]
pub struct Time {
    pub year: ::std::os::raw::c_int,
    pub month: ::std::os::raw::c_int,
    pub day_of_week: ::std::os::raw::c_int,
    pub day_of_month: ::std::os::raw::c_int,
    pub hour: ::std::os::raw::c_int,
    pub minute: ::std::os::raw::c_int,
    pub second: ::std::os::raw::c_int,
    pub millisecond: ::std::os::raw::c_int,
}
impl From<_cef_time_t> for Time {
    fn from(value: _cef_time_t) -> Self {
        Self {
            year: value.year.into(),
            month: value.month.into(),
            day_of_week: value.day_of_week.into(),
            day_of_month: value.day_of_month.into(),
            hour: value.hour.into(),
            minute: value.minute.into(),
            second: value.second.into(),
            millisecond: value.millisecond.into(),
        }
    }
}
impl Into<_cef_time_t> for Time {
    fn into(self) -> _cef_time_t {
        _cef_time_t {
            year: self.year.into(),
            month: self.month.into(),
            day_of_week: self.day_of_week.into(),
            day_of_month: self.day_of_month.into(),
            hour: self.hour.into(),
            minute: self.minute.into(),
            second: self.second.into(),
            millisecond: self.millisecond.into(),
        }
    }
}
impl Default for Time {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_point_t] for more documentation.
#[derive(Clone)]
pub struct Point {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
impl From<_cef_point_t> for Point {
    fn from(value: _cef_point_t) -> Self {
        Self {
            x: value.x.into(),
            y: value.y.into(),
        }
    }
}
impl Into<_cef_point_t> for Point {
    fn into(self) -> _cef_point_t {
        _cef_point_t {
            x: self.x.into(),
            y: self.y.into(),
        }
    }
}
impl Default for Point {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_rect_t] for more documentation.
#[derive(Clone)]
pub struct Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
impl From<_cef_rect_t> for Rect {
    fn from(value: _cef_rect_t) -> Self {
        Self {
            x: value.x.into(),
            y: value.y.into(),
            width: value.width.into(),
            height: value.height.into(),
        }
    }
}
impl Into<_cef_rect_t> for Rect {
    fn into(self) -> _cef_rect_t {
        _cef_rect_t {
            x: self.x.into(),
            y: self.y.into(),
            width: self.width.into(),
            height: self.height.into(),
        }
    }
}
impl Default for Rect {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_size_t] for more documentation.
#[derive(Clone)]
pub struct Size {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
impl From<_cef_size_t> for Size {
    fn from(value: _cef_size_t) -> Self {
        Self {
            width: value.width.into(),
            height: value.height.into(),
        }
    }
}
impl Into<_cef_size_t> for Size {
    fn into(self) -> _cef_size_t {
        _cef_size_t {
            width: self.width.into(),
            height: self.height.into(),
        }
    }
}
impl Default for Size {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_insets_t] for more documentation.
#[derive(Clone)]
pub struct Insets {
    pub top: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
}
impl From<_cef_insets_t> for Insets {
    fn from(value: _cef_insets_t) -> Self {
        Self {
            top: value.top.into(),
            left: value.left.into(),
            bottom: value.bottom.into(),
            right: value.right.into(),
        }
    }
}
impl Into<_cef_insets_t> for Insets {
    fn into(self) -> _cef_insets_t {
        _cef_insets_t {
            top: self.top.into(),
            left: self.left.into(),
            bottom: self.bottom.into(),
            right: self.right.into(),
        }
    }
}
impl Default for Insets {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_main_args_t] for more documentation.
#[derive(Clone)]
pub struct MainArgs {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
impl From<_cef_main_args_t> for MainArgs {
    fn from(value: _cef_main_args_t) -> Self {
        Self {
            argc: value.argc.into(),
            argv: value.argv.into(),
        }
    }
}
impl Into<_cef_main_args_t> for MainArgs {
    fn into(self) -> _cef_main_args_t {
        _cef_main_args_t {
            argc: self.argc.into(),
            argv: self.argv.into(),
        }
    }
}
impl Default for MainArgs {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_window_info_t] for more documentation.
#[derive(Clone)]
pub struct WindowInfo {
    pub window_name: CefStringUtf16,
    pub bounds: Rect,
    pub parent_window: ::std::os::raw::c_ulong,
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    pub shared_texture_enabled: ::std::os::raw::c_int,
    pub external_begin_frame_enabled: ::std::os::raw::c_int,
    pub window: ::std::os::raw::c_ulong,
    pub runtime_style: RuntimeStyle,
}
impl From<_cef_window_info_t> for WindowInfo {
    fn from(value: _cef_window_info_t) -> Self {
        Self {
            window_name: value.window_name.into(),
            bounds: value.bounds.into(),
            parent_window: value.parent_window.into(),
            windowless_rendering_enabled: value.windowless_rendering_enabled.into(),
            shared_texture_enabled: value.shared_texture_enabled.into(),
            external_begin_frame_enabled: value.external_begin_frame_enabled.into(),
            window: value.window.into(),
            runtime_style: value.runtime_style.into(),
        }
    }
}
impl Into<_cef_window_info_t> for WindowInfo {
    fn into(self) -> _cef_window_info_t {
        _cef_window_info_t {
            window_name: self.window_name.into(),
            bounds: self.bounds.into(),
            parent_window: self.parent_window.into(),
            windowless_rendering_enabled: self.windowless_rendering_enabled.into(),
            shared_texture_enabled: self.shared_texture_enabled.into(),
            external_begin_frame_enabled: self.external_begin_frame_enabled.into(),
            window: self.window.into(),
            runtime_style: self.runtime_style.into(),
        }
    }
}
impl Default for WindowInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_accelerated_paint_native_pixmap_plane_info_t] for more documentation.
#[derive(Clone)]
pub struct AcceleratedPaintNativePixmapPlaneInfo {
    pub stride: u32,
    pub offset: u64,
    pub size: u64,
    pub fd: ::std::os::raw::c_int,
}
impl From<_cef_accelerated_paint_native_pixmap_plane_info_t>
    for AcceleratedPaintNativePixmapPlaneInfo
{
    fn from(value: _cef_accelerated_paint_native_pixmap_plane_info_t) -> Self {
        Self {
            stride: value.stride.into(),
            offset: value.offset.into(),
            size: value.size.into(),
            fd: value.fd.into(),
        }
    }
}
impl Into<_cef_accelerated_paint_native_pixmap_plane_info_t>
    for AcceleratedPaintNativePixmapPlaneInfo
{
    fn into(self) -> _cef_accelerated_paint_native_pixmap_plane_info_t {
        _cef_accelerated_paint_native_pixmap_plane_info_t {
            stride: self.stride.into(),
            offset: self.offset.into(),
            size: self.size.into(),
            fd: self.fd.into(),
        }
    }
}
impl Default for AcceleratedPaintNativePixmapPlaneInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_accelerated_paint_info_t] for more documentation.
#[derive(Clone)]
pub struct AcceleratedPaintInfo {
    pub planes: [AcceleratedPaintNativePixmapPlaneInfo; 4usize],
    pub plane_count: ::std::os::raw::c_int,
    pub modifier: u64,
    pub format: ColorType,
}
impl From<_cef_accelerated_paint_info_t> for AcceleratedPaintInfo {
    fn from(value: _cef_accelerated_paint_info_t) -> Self {
        Self {
            planes: init_array_field(value.planes),
            plane_count: value.plane_count.into(),
            modifier: value.modifier.into(),
            format: value.format.into(),
        }
    }
}
impl Into<_cef_accelerated_paint_info_t> for AcceleratedPaintInfo {
    fn into(self) -> _cef_accelerated_paint_info_t {
        _cef_accelerated_paint_info_t {
            planes: init_array_field(self.planes),
            plane_count: self.plane_count.into(),
            modifier: self.modifier.into(),
            format: self.format.into(),
        }
    }
}
impl Default for AcceleratedPaintInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_settings_t] for more documentation.
#[derive(Clone)]
pub struct Settings {
    pub size: usize,
    pub no_sandbox: ::std::os::raw::c_int,
    pub browser_subprocess_path: CefStringUtf16,
    pub framework_dir_path: CefStringUtf16,
    pub main_bundle_path: CefStringUtf16,
    pub multi_threaded_message_loop: ::std::os::raw::c_int,
    pub external_message_pump: ::std::os::raw::c_int,
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    pub command_line_args_disabled: ::std::os::raw::c_int,
    pub cache_path: CefStringUtf16,
    pub root_cache_path: CefStringUtf16,
    pub persist_session_cookies: ::std::os::raw::c_int,
    pub user_agent: CefStringUtf16,
    pub user_agent_product: CefStringUtf16,
    pub locale: CefStringUtf16,
    pub log_file: CefStringUtf16,
    pub log_severity: LogSeverity,
    pub log_items: LogItems,
    pub javascript_flags: CefStringUtf16,
    pub resources_dir_path: CefStringUtf16,
    pub locales_dir_path: CefStringUtf16,
    pub remote_debugging_port: ::std::os::raw::c_int,
    pub uncaught_exception_stack_size: ::std::os::raw::c_int,
    pub background_color: u32,
    pub accept_language_list: CefStringUtf16,
    pub cookieable_schemes_list: CefStringUtf16,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
    pub chrome_policy_id: CefStringUtf16,
    pub chrome_app_icon_id: ::std::os::raw::c_int,
    pub disable_signal_handlers: ::std::os::raw::c_int,
}
impl From<_cef_settings_t> for Settings {
    fn from(value: _cef_settings_t) -> Self {
        Self {
            size: value.size.into(),
            no_sandbox: value.no_sandbox.into(),
            browser_subprocess_path: value.browser_subprocess_path.into(),
            framework_dir_path: value.framework_dir_path.into(),
            main_bundle_path: value.main_bundle_path.into(),
            multi_threaded_message_loop: value.multi_threaded_message_loop.into(),
            external_message_pump: value.external_message_pump.into(),
            windowless_rendering_enabled: value.windowless_rendering_enabled.into(),
            command_line_args_disabled: value.command_line_args_disabled.into(),
            cache_path: value.cache_path.into(),
            root_cache_path: value.root_cache_path.into(),
            persist_session_cookies: value.persist_session_cookies.into(),
            user_agent: value.user_agent.into(),
            user_agent_product: value.user_agent_product.into(),
            locale: value.locale.into(),
            log_file: value.log_file.into(),
            log_severity: value.log_severity.into(),
            log_items: value.log_items.into(),
            javascript_flags: value.javascript_flags.into(),
            resources_dir_path: value.resources_dir_path.into(),
            locales_dir_path: value.locales_dir_path.into(),
            remote_debugging_port: value.remote_debugging_port.into(),
            uncaught_exception_stack_size: value.uncaught_exception_stack_size.into(),
            background_color: value.background_color.into(),
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults.into(),
            chrome_policy_id: value.chrome_policy_id.into(),
            chrome_app_icon_id: value.chrome_app_icon_id.into(),
            disable_signal_handlers: value.disable_signal_handlers.into(),
        }
    }
}
impl Into<_cef_settings_t> for Settings {
    fn into(self) -> _cef_settings_t {
        _cef_settings_t {
            size: self.size.into(),
            no_sandbox: self.no_sandbox.into(),
            browser_subprocess_path: self.browser_subprocess_path.into(),
            framework_dir_path: self.framework_dir_path.into(),
            main_bundle_path: self.main_bundle_path.into(),
            multi_threaded_message_loop: self.multi_threaded_message_loop.into(),
            external_message_pump: self.external_message_pump.into(),
            windowless_rendering_enabled: self.windowless_rendering_enabled.into(),
            command_line_args_disabled: self.command_line_args_disabled.into(),
            cache_path: self.cache_path.into(),
            root_cache_path: self.root_cache_path.into(),
            persist_session_cookies: self.persist_session_cookies.into(),
            user_agent: self.user_agent.into(),
            user_agent_product: self.user_agent_product.into(),
            locale: self.locale.into(),
            log_file: self.log_file.into(),
            log_severity: self.log_severity.into(),
            log_items: self.log_items.into(),
            javascript_flags: self.javascript_flags.into(),
            resources_dir_path: self.resources_dir_path.into(),
            locales_dir_path: self.locales_dir_path.into(),
            remote_debugging_port: self.remote_debugging_port.into(),
            uncaught_exception_stack_size: self.uncaught_exception_stack_size.into(),
            background_color: self.background_color.into(),
            accept_language_list: self.accept_language_list.into(),
            cookieable_schemes_list: self.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: self.cookieable_schemes_exclude_defaults.into(),
            chrome_policy_id: self.chrome_policy_id.into(),
            chrome_app_icon_id: self.chrome_app_icon_id.into(),
            disable_signal_handlers: self.disable_signal_handlers.into(),
        }
    }
}
impl Default for Settings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [_cef_request_context_settings_t] for more documentation.
#[derive(Clone)]
pub struct RequestContextSettings {
    pub size: usize,
    pub cache_path: CefStringUtf16,
    pub persist_session_cookies: ::std::os::raw::c_int,
    pub accept_language_list: CefStringUtf16,
    pub cookieable_schemes_list: CefStringUtf16,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
}
impl From<_cef_request_context_settings_t> for RequestContextSettings {
    fn from(value: _cef_request_context_settings_t) -> Self {
        Self {
            size: value.size.into(),
            cache_path: value.cache_path.into(),
            persist_session_cookies: value.persist_session_cookies.into(),
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults.into(),
        }
    }
}
impl Into<_cef_request_context_settings_t> for RequestContextSettings {
    fn into(self) -> _cef_request_context_settings_t {
        _cef_request_context_settings_t {
            size: self.size.into(),
            cache_path: self.cache_path.into(),
            persist_session_cookies: self.persist_session_cookies.into(),
            accept_language_list: self.accept_language_list.into(),
            cookieable_schemes_list: self.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: self.cookieable_schemes_exclude_defaults.into(),
        }
    }
}
impl Default for RequestContextSettings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_request_context_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [_cef_browser_settings_t] for more documentation.
#[derive(Clone)]
pub struct BrowserSettings {
    pub size: usize,
    pub windowless_frame_rate: ::std::os::raw::c_int,
    pub standard_font_family: CefStringUtf16,
    pub fixed_font_family: CefStringUtf16,
    pub serif_font_family: CefStringUtf16,
    pub sans_serif_font_family: CefStringUtf16,
    pub cursive_font_family: CefStringUtf16,
    pub fantasy_font_family: CefStringUtf16,
    pub default_font_size: ::std::os::raw::c_int,
    pub default_fixed_font_size: ::std::os::raw::c_int,
    pub minimum_font_size: ::std::os::raw::c_int,
    pub minimum_logical_font_size: ::std::os::raw::c_int,
    pub default_encoding: CefStringUtf16,
    pub remote_fonts: State,
    pub javascript: State,
    pub javascript_close_windows: State,
    pub javascript_access_clipboard: State,
    pub javascript_dom_paste: State,
    pub image_loading: State,
    pub image_shrink_standalone_to_fit: State,
    pub text_area_resize: State,
    pub tab_to_links: State,
    pub local_storage: State,
    pub databases: State,
    pub webgl: State,
    pub background_color: u32,
    pub chrome_status_bubble: State,
    pub chrome_zoom_bubble: State,
}
impl From<_cef_browser_settings_t> for BrowserSettings {
    fn from(value: _cef_browser_settings_t) -> Self {
        Self {
            size: value.size.into(),
            windowless_frame_rate: value.windowless_frame_rate.into(),
            standard_font_family: value.standard_font_family.into(),
            fixed_font_family: value.fixed_font_family.into(),
            serif_font_family: value.serif_font_family.into(),
            sans_serif_font_family: value.sans_serif_font_family.into(),
            cursive_font_family: value.cursive_font_family.into(),
            fantasy_font_family: value.fantasy_font_family.into(),
            default_font_size: value.default_font_size.into(),
            default_fixed_font_size: value.default_fixed_font_size.into(),
            minimum_font_size: value.minimum_font_size.into(),
            minimum_logical_font_size: value.minimum_logical_font_size.into(),
            default_encoding: value.default_encoding.into(),
            remote_fonts: value.remote_fonts.into(),
            javascript: value.javascript.into(),
            javascript_close_windows: value.javascript_close_windows.into(),
            javascript_access_clipboard: value.javascript_access_clipboard.into(),
            javascript_dom_paste: value.javascript_dom_paste.into(),
            image_loading: value.image_loading.into(),
            image_shrink_standalone_to_fit: value.image_shrink_standalone_to_fit.into(),
            text_area_resize: value.text_area_resize.into(),
            tab_to_links: value.tab_to_links.into(),
            local_storage: value.local_storage.into(),
            databases: value.databases.into(),
            webgl: value.webgl.into(),
            background_color: value.background_color.into(),
            chrome_status_bubble: value.chrome_status_bubble.into(),
            chrome_zoom_bubble: value.chrome_zoom_bubble.into(),
        }
    }
}
impl Into<_cef_browser_settings_t> for BrowserSettings {
    fn into(self) -> _cef_browser_settings_t {
        _cef_browser_settings_t {
            size: self.size.into(),
            windowless_frame_rate: self.windowless_frame_rate.into(),
            standard_font_family: self.standard_font_family.into(),
            fixed_font_family: self.fixed_font_family.into(),
            serif_font_family: self.serif_font_family.into(),
            sans_serif_font_family: self.sans_serif_font_family.into(),
            cursive_font_family: self.cursive_font_family.into(),
            fantasy_font_family: self.fantasy_font_family.into(),
            default_font_size: self.default_font_size.into(),
            default_fixed_font_size: self.default_fixed_font_size.into(),
            minimum_font_size: self.minimum_font_size.into(),
            minimum_logical_font_size: self.minimum_logical_font_size.into(),
            default_encoding: self.default_encoding.into(),
            remote_fonts: self.remote_fonts.into(),
            javascript: self.javascript.into(),
            javascript_close_windows: self.javascript_close_windows.into(),
            javascript_access_clipboard: self.javascript_access_clipboard.into(),
            javascript_dom_paste: self.javascript_dom_paste.into(),
            image_loading: self.image_loading.into(),
            image_shrink_standalone_to_fit: self.image_shrink_standalone_to_fit.into(),
            text_area_resize: self.text_area_resize.into(),
            tab_to_links: self.tab_to_links.into(),
            local_storage: self.local_storage.into(),
            databases: self.databases.into(),
            webgl: self.webgl.into(),
            background_color: self.background_color.into(),
            chrome_status_bubble: self.chrome_status_bubble.into(),
            chrome_zoom_bubble: self.chrome_zoom_bubble.into(),
        }
    }
}
impl Default for BrowserSettings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_browser_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [_cef_urlparts_t] for more documentation.
#[derive(Clone)]
pub struct Urlparts {
    pub spec: CefStringUtf16,
    pub scheme: CefStringUtf16,
    pub username: CefStringUtf16,
    pub password: CefStringUtf16,
    pub host: CefStringUtf16,
    pub port: CefStringUtf16,
    pub origin: CefStringUtf16,
    pub path: CefStringUtf16,
    pub query: CefStringUtf16,
    pub fragment: CefStringUtf16,
}
impl From<_cef_urlparts_t> for Urlparts {
    fn from(value: _cef_urlparts_t) -> Self {
        Self {
            spec: value.spec.into(),
            scheme: value.scheme.into(),
            username: value.username.into(),
            password: value.password.into(),
            host: value.host.into(),
            port: value.port.into(),
            origin: value.origin.into(),
            path: value.path.into(),
            query: value.query.into(),
            fragment: value.fragment.into(),
        }
    }
}
impl Into<_cef_urlparts_t> for Urlparts {
    fn into(self) -> _cef_urlparts_t {
        _cef_urlparts_t {
            spec: self.spec.into(),
            scheme: self.scheme.into(),
            username: self.username.into(),
            password: self.password.into(),
            host: self.host.into(),
            port: self.port.into(),
            origin: self.origin.into(),
            path: self.path.into(),
            query: self.query.into(),
            fragment: self.fragment.into(),
        }
    }
}
impl Default for Urlparts {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_cookie_t] for more documentation.
#[derive(Clone)]
pub struct Cookie {
    pub name: CefStringUtf16,
    pub value: CefStringUtf16,
    pub domain: CefStringUtf16,
    pub path: CefStringUtf16,
    pub secure: ::std::os::raw::c_int,
    pub httponly: ::std::os::raw::c_int,
    pub creation: Basetime,
    pub last_access: Basetime,
    pub has_expires: ::std::os::raw::c_int,
    pub expires: Basetime,
    pub same_site: CookieSameSite,
    pub priority: CookiePriority,
}
impl From<_cef_cookie_t> for Cookie {
    fn from(value: _cef_cookie_t) -> Self {
        Self {
            name: value.name.into(),
            value: value.value.into(),
            domain: value.domain.into(),
            path: value.path.into(),
            secure: value.secure.into(),
            httponly: value.httponly.into(),
            creation: value.creation.into(),
            last_access: value.last_access.into(),
            has_expires: value.has_expires.into(),
            expires: value.expires.into(),
            same_site: value.same_site.into(),
            priority: value.priority.into(),
        }
    }
}
impl Into<_cef_cookie_t> for Cookie {
    fn into(self) -> _cef_cookie_t {
        _cef_cookie_t {
            name: self.name.into(),
            value: self.value.into(),
            domain: self.domain.into(),
            path: self.path.into(),
            secure: self.secure.into(),
            httponly: self.httponly.into(),
            creation: self.creation.into(),
            last_access: self.last_access.into(),
            has_expires: self.has_expires.into(),
            expires: self.expires.into(),
            same_site: self.same_site.into(),
            priority: self.priority.into(),
        }
    }
}
impl Default for Cookie {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_draggable_region_t] for more documentation.
#[derive(Clone)]
pub struct DraggableRegion {
    pub bounds: Rect,
    pub draggable: ::std::os::raw::c_int,
}
impl From<_cef_draggable_region_t> for DraggableRegion {
    fn from(value: _cef_draggable_region_t) -> Self {
        Self {
            bounds: value.bounds.into(),
            draggable: value.draggable.into(),
        }
    }
}
impl Into<_cef_draggable_region_t> for DraggableRegion {
    fn into(self) -> _cef_draggable_region_t {
        _cef_draggable_region_t {
            bounds: self.bounds.into(),
            draggable: self.draggable.into(),
        }
    }
}
impl Default for DraggableRegion {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_screen_info_t] for more documentation.
#[derive(Clone)]
pub struct ScreenInfo {
    pub device_scale_factor: f32,
    pub depth: ::std::os::raw::c_int,
    pub depth_per_component: ::std::os::raw::c_int,
    pub is_monochrome: ::std::os::raw::c_int,
    pub rect: Rect,
    pub available_rect: Rect,
}
impl From<_cef_screen_info_t> for ScreenInfo {
    fn from(value: _cef_screen_info_t) -> Self {
        Self {
            device_scale_factor: value.device_scale_factor.into(),
            depth: value.depth.into(),
            depth_per_component: value.depth_per_component.into(),
            is_monochrome: value.is_monochrome.into(),
            rect: value.rect.into(),
            available_rect: value.available_rect.into(),
        }
    }
}
impl Into<_cef_screen_info_t> for ScreenInfo {
    fn into(self) -> _cef_screen_info_t {
        _cef_screen_info_t {
            device_scale_factor: self.device_scale_factor.into(),
            depth: self.depth.into(),
            depth_per_component: self.depth_per_component.into(),
            is_monochrome: self.is_monochrome.into(),
            rect: self.rect.into(),
            available_rect: self.available_rect.into(),
        }
    }
}
impl Default for ScreenInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_linux_window_properties_t] for more documentation.
#[derive(Clone)]
pub struct LinuxWindowProperties {
    pub wayland_app_id: CefStringUtf16,
    pub wm_class_class: CefStringUtf16,
    pub wm_class_name: CefStringUtf16,
    pub wm_role_name: CefStringUtf16,
}
impl From<_cef_linux_window_properties_t> for LinuxWindowProperties {
    fn from(value: _cef_linux_window_properties_t) -> Self {
        Self {
            wayland_app_id: value.wayland_app_id.into(),
            wm_class_class: value.wm_class_class.into(),
            wm_class_name: value.wm_class_name.into(),
            wm_role_name: value.wm_role_name.into(),
        }
    }
}
impl Into<_cef_linux_window_properties_t> for LinuxWindowProperties {
    fn into(self) -> _cef_linux_window_properties_t {
        _cef_linux_window_properties_t {
            wayland_app_id: self.wayland_app_id.into(),
            wm_class_class: self.wm_class_class.into(),
            wm_class_name: self.wm_class_name.into(),
            wm_role_name: self.wm_role_name.into(),
        }
    }
}
impl Default for LinuxWindowProperties {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_mouse_event_t] for more documentation.
#[derive(Clone)]
pub struct MouseEvent {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub modifiers: u32,
}
impl From<_cef_mouse_event_t> for MouseEvent {
    fn from(value: _cef_mouse_event_t) -> Self {
        Self {
            x: value.x.into(),
            y: value.y.into(),
            modifiers: value.modifiers.into(),
        }
    }
}
impl Into<_cef_mouse_event_t> for MouseEvent {
    fn into(self) -> _cef_mouse_event_t {
        _cef_mouse_event_t {
            x: self.x.into(),
            y: self.y.into(),
            modifiers: self.modifiers.into(),
        }
    }
}
impl Default for MouseEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_touch_event_t] for more documentation.
#[derive(Clone)]
pub struct TouchEvent {
    pub id: ::std::os::raw::c_int,
    pub x: f32,
    pub y: f32,
    pub radius_x: f32,
    pub radius_y: f32,
    pub rotation_angle: f32,
    pub pressure: f32,
    pub type_: TouchEventType,
    pub modifiers: u32,
    pub pointer_type: PointerType,
}
impl From<_cef_touch_event_t> for TouchEvent {
    fn from(value: _cef_touch_event_t) -> Self {
        Self {
            id: value.id.into(),
            x: value.x.into(),
            y: value.y.into(),
            radius_x: value.radius_x.into(),
            radius_y: value.radius_y.into(),
            rotation_angle: value.rotation_angle.into(),
            pressure: value.pressure.into(),
            type_: value.type_.into(),
            modifiers: value.modifiers.into(),
            pointer_type: value.pointer_type.into(),
        }
    }
}
impl Into<_cef_touch_event_t> for TouchEvent {
    fn into(self) -> _cef_touch_event_t {
        _cef_touch_event_t {
            id: self.id.into(),
            x: self.x.into(),
            y: self.y.into(),
            radius_x: self.radius_x.into(),
            radius_y: self.radius_y.into(),
            rotation_angle: self.rotation_angle.into(),
            pressure: self.pressure.into(),
            type_: self.type_.into(),
            modifiers: self.modifiers.into(),
            pointer_type: self.pointer_type.into(),
        }
    }
}
impl Default for TouchEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_key_event_t] for more documentation.
#[derive(Clone)]
pub struct KeyEvent {
    pub type_: KeyEventType,
    pub modifiers: u32,
    pub windows_key_code: ::std::os::raw::c_int,
    pub native_key_code: ::std::os::raw::c_int,
    pub is_system_key: ::std::os::raw::c_int,
    pub character: char16_t,
    pub unmodified_character: char16_t,
    pub focus_on_editable_field: ::std::os::raw::c_int,
}
impl From<_cef_key_event_t> for KeyEvent {
    fn from(value: _cef_key_event_t) -> Self {
        Self {
            type_: value.type_.into(),
            modifiers: value.modifiers.into(),
            windows_key_code: value.windows_key_code.into(),
            native_key_code: value.native_key_code.into(),
            is_system_key: value.is_system_key.into(),
            character: value.character.into(),
            unmodified_character: value.unmodified_character.into(),
            focus_on_editable_field: value.focus_on_editable_field.into(),
        }
    }
}
impl Into<_cef_key_event_t> for KeyEvent {
    fn into(self) -> _cef_key_event_t {
        _cef_key_event_t {
            type_: self.type_.into(),
            modifiers: self.modifiers.into(),
            windows_key_code: self.windows_key_code.into(),
            native_key_code: self.native_key_code.into(),
            is_system_key: self.is_system_key.into(),
            character: self.character.into(),
            unmodified_character: self.unmodified_character.into(),
            focus_on_editable_field: self.focus_on_editable_field.into(),
        }
    }
}
impl Default for KeyEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_popup_features_t] for more documentation.
#[derive(Clone)]
pub struct PopupFeatures {
    pub x: ::std::os::raw::c_int,
    pub x_set: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub y_set: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub width_set: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub height_set: ::std::os::raw::c_int,
    pub is_popup: ::std::os::raw::c_int,
}
impl From<_cef_popup_features_t> for PopupFeatures {
    fn from(value: _cef_popup_features_t) -> Self {
        Self {
            x: value.x.into(),
            x_set: value.xSet.into(),
            y: value.y.into(),
            y_set: value.ySet.into(),
            width: value.width.into(),
            width_set: value.widthSet.into(),
            height: value.height.into(),
            height_set: value.heightSet.into(),
            is_popup: value.isPopup.into(),
        }
    }
}
impl Into<_cef_popup_features_t> for PopupFeatures {
    fn into(self) -> _cef_popup_features_t {
        _cef_popup_features_t {
            x: self.x.into(),
            xSet: self.x_set.into(),
            y: self.y.into(),
            ySet: self.y_set.into(),
            width: self.width.into(),
            widthSet: self.width_set.into(),
            height: self.height.into(),
            heightSet: self.height_set.into(),
            isPopup: self.is_popup.into(),
        }
    }
}
impl Default for PopupFeatures {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_cursor_info_t] for more documentation.
#[derive(Clone)]
pub struct CursorInfo {
    pub hotspot: Point,
    pub image_scale_factor: f32,
    pub buffer: *mut ::std::os::raw::c_void,
    pub size: Size,
}
impl From<_cef_cursor_info_t> for CursorInfo {
    fn from(value: _cef_cursor_info_t) -> Self {
        Self {
            hotspot: value.hotspot.into(),
            image_scale_factor: value.image_scale_factor.into(),
            buffer: value.buffer.into(),
            size: value.size.into(),
        }
    }
}
impl Into<_cef_cursor_info_t> for CursorInfo {
    fn into(self) -> _cef_cursor_info_t {
        _cef_cursor_info_t {
            hotspot: self.hotspot.into(),
            image_scale_factor: self.image_scale_factor.into(),
            buffer: self.buffer.into(),
            size: self.size.into(),
        }
    }
}
impl Default for CursorInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_pdf_print_settings_t] for more documentation.
#[derive(Clone)]
pub struct PdfPrintSettings {
    pub landscape: ::std::os::raw::c_int,
    pub print_background: ::std::os::raw::c_int,
    pub scale: f64,
    pub paper_width: f64,
    pub paper_height: f64,
    pub prefer_css_page_size: ::std::os::raw::c_int,
    pub margin_type: PdfPrintMarginType,
    pub margin_top: f64,
    pub margin_right: f64,
    pub margin_bottom: f64,
    pub margin_left: f64,
    pub page_ranges: CefStringUtf16,
    pub display_header_footer: ::std::os::raw::c_int,
    pub header_template: CefStringUtf16,
    pub footer_template: CefStringUtf16,
    pub generate_tagged_pdf: ::std::os::raw::c_int,
    pub generate_document_outline: ::std::os::raw::c_int,
}
impl From<_cef_pdf_print_settings_t> for PdfPrintSettings {
    fn from(value: _cef_pdf_print_settings_t) -> Self {
        Self {
            landscape: value.landscape.into(),
            print_background: value.print_background.into(),
            scale: value.scale.into(),
            paper_width: value.paper_width.into(),
            paper_height: value.paper_height.into(),
            prefer_css_page_size: value.prefer_css_page_size.into(),
            margin_type: value.margin_type.into(),
            margin_top: value.margin_top.into(),
            margin_right: value.margin_right.into(),
            margin_bottom: value.margin_bottom.into(),
            margin_left: value.margin_left.into(),
            page_ranges: value.page_ranges.into(),
            display_header_footer: value.display_header_footer.into(),
            header_template: value.header_template.into(),
            footer_template: value.footer_template.into(),
            generate_tagged_pdf: value.generate_tagged_pdf.into(),
            generate_document_outline: value.generate_document_outline.into(),
        }
    }
}
impl Into<_cef_pdf_print_settings_t> for PdfPrintSettings {
    fn into(self) -> _cef_pdf_print_settings_t {
        _cef_pdf_print_settings_t {
            landscape: self.landscape.into(),
            print_background: self.print_background.into(),
            scale: self.scale.into(),
            paper_width: self.paper_width.into(),
            paper_height: self.paper_height.into(),
            prefer_css_page_size: self.prefer_css_page_size.into(),
            margin_type: self.margin_type.into(),
            margin_top: self.margin_top.into(),
            margin_right: self.margin_right.into(),
            margin_bottom: self.margin_bottom.into(),
            margin_left: self.margin_left.into(),
            page_ranges: self.page_ranges.into(),
            display_header_footer: self.display_header_footer.into(),
            header_template: self.header_template.into(),
            footer_template: self.footer_template.into(),
            generate_tagged_pdf: self.generate_tagged_pdf.into(),
            generate_document_outline: self.generate_document_outline.into(),
        }
    }
}
impl Default for PdfPrintSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_box_layout_settings_t] for more documentation.
#[derive(Clone)]
pub struct BoxLayoutSettings {
    pub horizontal: ::std::os::raw::c_int,
    pub inside_border_horizontal_spacing: ::std::os::raw::c_int,
    pub inside_border_vertical_spacing: ::std::os::raw::c_int,
    pub inside_border_insets: Insets,
    pub between_child_spacing: ::std::os::raw::c_int,
    pub main_axis_alignment: AxisAlignment,
    pub cross_axis_alignment: AxisAlignment,
    pub minimum_cross_axis_size: ::std::os::raw::c_int,
    pub default_flex: ::std::os::raw::c_int,
}
impl From<_cef_box_layout_settings_t> for BoxLayoutSettings {
    fn from(value: _cef_box_layout_settings_t) -> Self {
        Self {
            horizontal: value.horizontal.into(),
            inside_border_horizontal_spacing: value.inside_border_horizontal_spacing.into(),
            inside_border_vertical_spacing: value.inside_border_vertical_spacing.into(),
            inside_border_insets: value.inside_border_insets.into(),
            between_child_spacing: value.between_child_spacing.into(),
            main_axis_alignment: value.main_axis_alignment.into(),
            cross_axis_alignment: value.cross_axis_alignment.into(),
            minimum_cross_axis_size: value.minimum_cross_axis_size.into(),
            default_flex: value.default_flex.into(),
        }
    }
}
impl Into<_cef_box_layout_settings_t> for BoxLayoutSettings {
    fn into(self) -> _cef_box_layout_settings_t {
        _cef_box_layout_settings_t {
            horizontal: self.horizontal.into(),
            inside_border_horizontal_spacing: self.inside_border_horizontal_spacing.into(),
            inside_border_vertical_spacing: self.inside_border_vertical_spacing.into(),
            inside_border_insets: self.inside_border_insets.into(),
            between_child_spacing: self.between_child_spacing.into(),
            main_axis_alignment: self.main_axis_alignment.into(),
            cross_axis_alignment: self.cross_axis_alignment.into(),
            minimum_cross_axis_size: self.minimum_cross_axis_size.into(),
            default_flex: self.default_flex.into(),
        }
    }
}
impl Default for BoxLayoutSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_range_t] for more documentation.
#[derive(Clone)]
pub struct Range {
    pub from: u32,
    pub to: u32,
}
impl From<_cef_range_t> for Range {
    fn from(value: _cef_range_t) -> Self {
        Self {
            from: value.from.into(),
            to: value.to.into(),
        }
    }
}
impl Into<_cef_range_t> for Range {
    fn into(self) -> _cef_range_t {
        _cef_range_t {
            from: self.from.into(),
            to: self.to.into(),
        }
    }
}
impl Default for Range {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_composition_underline_t] for more documentation.
#[derive(Clone)]
pub struct CompositionUnderline {
    pub range: Range,
    pub color: u32,
    pub background_color: u32,
    pub thick: ::std::os::raw::c_int,
    pub style: CompositionUnderlineStyle,
}
impl From<_cef_composition_underline_t> for CompositionUnderline {
    fn from(value: _cef_composition_underline_t) -> Self {
        Self {
            range: value.range.into(),
            color: value.color.into(),
            background_color: value.background_color.into(),
            thick: value.thick.into(),
            style: value.style.into(),
        }
    }
}
impl Into<_cef_composition_underline_t> for CompositionUnderline {
    fn into(self) -> _cef_composition_underline_t {
        _cef_composition_underline_t {
            range: self.range.into(),
            color: self.color.into(),
            background_color: self.background_color.into(),
            thick: self.thick.into(),
            style: self.style.into(),
        }
    }
}
impl Default for CompositionUnderline {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_audio_parameters_t] for more documentation.
#[derive(Clone)]
pub struct AudioParameters {
    pub channel_layout: ChannelLayout,
    pub sample_rate: ::std::os::raw::c_int,
    pub frames_per_buffer: ::std::os::raw::c_int,
}
impl From<_cef_audio_parameters_t> for AudioParameters {
    fn from(value: _cef_audio_parameters_t) -> Self {
        Self {
            channel_layout: value.channel_layout.into(),
            sample_rate: value.sample_rate.into(),
            frames_per_buffer: value.frames_per_buffer.into(),
        }
    }
}
impl Into<_cef_audio_parameters_t> for AudioParameters {
    fn into(self) -> _cef_audio_parameters_t {
        _cef_audio_parameters_t {
            channel_layout: self.channel_layout.into(),
            sample_rate: self.sample_rate.into(),
            frames_per_buffer: self.frames_per_buffer.into(),
        }
    }
}
impl Default for AudioParameters {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_sink_device_info_t] for more documentation.
#[derive(Clone)]
pub struct MediaSinkDeviceInfo {
    pub ip_address: CefStringUtf16,
    pub port: ::std::os::raw::c_int,
    pub model_name: CefStringUtf16,
}
impl From<_cef_media_sink_device_info_t> for MediaSinkDeviceInfo {
    fn from(value: _cef_media_sink_device_info_t) -> Self {
        Self {
            ip_address: value.ip_address.into(),
            port: value.port.into(),
            model_name: value.model_name.into(),
        }
    }
}
impl Into<_cef_media_sink_device_info_t> for MediaSinkDeviceInfo {
    fn into(self) -> _cef_media_sink_device_info_t {
        _cef_media_sink_device_info_t {
            ip_address: self.ip_address.into(),
            port: self.port.into(),
            model_name: self.model_name.into(),
        }
    }
}
impl Default for MediaSinkDeviceInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_touch_handle_state_t] for more documentation.
#[derive(Clone)]
pub struct TouchHandleState {
    pub touch_handle_id: ::std::os::raw::c_int,
    pub flags: u32,
    pub enabled: ::std::os::raw::c_int,
    pub orientation: HorizontalAlignment,
    pub mirror_vertical: ::std::os::raw::c_int,
    pub mirror_horizontal: ::std::os::raw::c_int,
    pub origin: Point,
    pub alpha: f32,
}
impl From<_cef_touch_handle_state_t> for TouchHandleState {
    fn from(value: _cef_touch_handle_state_t) -> Self {
        Self {
            touch_handle_id: value.touch_handle_id.into(),
            flags: value.flags.into(),
            enabled: value.enabled.into(),
            orientation: value.orientation.into(),
            mirror_vertical: value.mirror_vertical.into(),
            mirror_horizontal: value.mirror_horizontal.into(),
            origin: value.origin.into(),
            alpha: value.alpha.into(),
        }
    }
}
impl Into<_cef_touch_handle_state_t> for TouchHandleState {
    fn into(self) -> _cef_touch_handle_state_t {
        _cef_touch_handle_state_t {
            touch_handle_id: self.touch_handle_id.into(),
            flags: self.flags.into(),
            enabled: self.enabled.into(),
            orientation: self.orientation.into(),
            mirror_vertical: self.mirror_vertical.into(),
            mirror_horizontal: self.mirror_horizontal.into(),
            origin: self.origin.into(),
            alpha: self.alpha.into(),
        }
    }
}
impl Default for TouchHandleState {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_task_info_t] for more documentation.
#[derive(Clone)]
pub struct TaskInfo {
    pub id: i64,
    pub type_: TaskType,
    pub is_killable: ::std::os::raw::c_int,
    pub title: CefStringUtf16,
    pub cpu_usage: f64,
    pub number_of_processors: ::std::os::raw::c_int,
    pub memory: i64,
    pub gpu_memory: i64,
    pub is_gpu_memory_inflated: ::std::os::raw::c_int,
}
impl From<_cef_task_info_t> for TaskInfo {
    fn from(value: _cef_task_info_t) -> Self {
        Self {
            id: value.id.into(),
            type_: value.type_.into(),
            is_killable: value.is_killable.into(),
            title: value.title.into(),
            cpu_usage: value.cpu_usage.into(),
            number_of_processors: value.number_of_processors.into(),
            memory: value.memory.into(),
            gpu_memory: value.gpu_memory.into(),
            is_gpu_memory_inflated: value.is_gpu_memory_inflated.into(),
        }
    }
}
impl Into<_cef_task_info_t> for TaskInfo {
    fn into(self) -> _cef_task_info_t {
        _cef_task_info_t {
            id: self.id.into(),
            type_: self.type_.into(),
            is_killable: self.is_killable.into(),
            title: self.title.into(),
            cpu_usage: self.cpu_usage.into(),
            number_of_processors: self.number_of_processors.into(),
            memory: self.memory.into(),
            gpu_memory: self.gpu_memory.into(),
            is_gpu_memory_inflated: self.is_gpu_memory_inflated.into(),
        }
    }
}
impl Default for TaskInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_base_ref_counted_t] for more documentation.
#[derive(Clone)]
pub struct BaseRefCounted(RefGuard<_cef_base_ref_counted_t>);
impl BaseRefCounted {
    fn get_raw(&self) -> *mut _cef_base_ref_counted_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for BaseRefCounted {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_base_ref_counted_t> for &BaseRefCounted {
    fn as_raw(self) -> *mut _cef_base_ref_counted_t {
        self.get_raw()
    }
}
impl ConvertParam<*mut _cef_base_ref_counted_t> for &mut BaseRefCounted {
    fn as_raw(self) -> *mut _cef_base_ref_counted_t {
        self.get_raw()
    }
}
impl ConvertReturnValue<BaseRefCounted> for *mut _cef_base_ref_counted_t {
    fn as_wrapper(self) -> BaseRefCounted {
        BaseRefCounted(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_base_ref_counted_t> for BaseRefCounted {
    fn into(self) -> *mut _cef_base_ref_counted_t {
        let object = self.get_raw();
        std::mem::forget(self);
        object
    }
}
impl Default for BaseRefCounted {
    fn default() -> Self {
        Self(unsafe { RefGuard::from_raw(std::ptr::null_mut()) })
    }
}

/// See [_cef_base_scoped_t] for more documentation.
#[derive(Clone, Copy)]
pub struct BaseScoped(*mut _cef_base_scoped_t);
impl BaseScoped {
    fn get_raw(&self) -> *mut _cef_base_scoped_t {
        self.0
    }
}
impl ConvertParam<*mut _cef_base_scoped_t> for &BaseScoped {
    fn as_raw(self) -> *mut _cef_base_scoped_t {
        self.get_raw()
    }
}
impl ConvertParam<*mut _cef_base_scoped_t> for &mut BaseScoped {
    fn as_raw(self) -> *mut _cef_base_scoped_t {
        self.get_raw()
    }
}
impl ConvertReturnValue<BaseScoped> for *mut _cef_base_scoped_t {
    fn as_wrapper(self) -> BaseScoped {
        BaseScoped(self)
    }
}
impl Into<*mut _cef_base_scoped_t> for BaseScoped {
    fn into(self) -> *mut _cef_base_scoped_t {
        self.get_raw()
    }
}
impl Default for BaseScoped {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

/// See [_cef_dev_tools_message_observer_t] for more documentation.
#[derive(Clone)]
pub struct DevToolsMessageObserver(RefGuard<_cef_dev_tools_message_observer_t>);
impl DevToolsMessageObserver {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDevToolsMessageObserver,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDevToolsMessageObserver>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDevToolsMessageObserver>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_dev_tools_message_observer_t).as_wrapper()
        }
    }
}
pub trait WrapDevToolsMessageObserver: ImplDevToolsMessageObserver {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_dev_tools_message_observer_t, Self>);
}
pub trait ImplDevToolsMessageObserver: Clone + Sized + Rc {
    fn on_dev_tools_message(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message: Option<&[u8]>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_dev_tools_method_result(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: Option<&[u8]>,
    ) {
    }
    fn on_dev_tools_event(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        method: Option<&CefStringUtf16>,
        params: Option<&[u8]>,
    ) {
    }
    fn on_dev_tools_agent_attached(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn on_dev_tools_agent_detached(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn init_methods(object: &mut _cef_dev_tools_message_observer_t) {
        impl_cef_dev_tools_message_observer_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_dev_tools_message_observer_t;
}
mod impl_cef_dev_tools_message_observer_t {
    use super::*;
    pub fn init_methods<I: ImplDevToolsMessageObserver>(
        object: &mut _cef_dev_tools_message_observer_t,
    ) {
        object.on_dev_tools_message = Some(on_dev_tools_message::<I>);
        object.on_dev_tools_method_result = Some(on_dev_tools_method_result::<I>);
        object.on_dev_tools_event = Some(on_dev_tools_event::<I>);
        object.on_dev_tools_agent_attached = Some(on_dev_tools_agent_attached::<I>);
        object.on_dev_tools_agent_detached = Some(on_dev_tools_agent_detached::<I>);
    }
    extern "C" fn on_dev_tools_message<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_message, arg_message_size) =
            (self_, browser, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        let result = ImplDevToolsMessageObserver::on_dev_tools_message(
            &arg_self_.interface,
            arg_browser,
            arg_message,
        );
        result.into()
    }
    extern "C" fn on_dev_tools_method_result<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: *const ::std::os::raw::c_void,
        result_size: usize,
    ) {
        let (arg_self_, arg_browser, arg_message_id, arg_success, arg_result, arg_result_size) =
            (self_, browser, message_id, success, result, result_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message_id = arg_message_id.as_raw();
        let arg_success = arg_success.as_raw();
        let arg_result = (!arg_result.is_null() && arg_result_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_result as *const _, arg_result_size)
        });
        let result = ImplDevToolsMessageObserver::on_dev_tools_method_result(
            &arg_self_.interface,
            arg_browser,
            arg_message_id,
            arg_success,
            arg_result,
        );
    }
    extern "C" fn on_dev_tools_event<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        method: *const _cef_string_utf16_t,
        params: *const ::std::os::raw::c_void,
        params_size: usize,
    ) {
        let (arg_self_, arg_browser, arg_method, arg_params, arg_params_size) =
            (self_, browser, method, params, params_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_method = if arg_method.is_null() {
            None
        } else {
            Some(arg_method.into())
        };
        let arg_method = arg_method.as_ref();
        let arg_params = (!arg_params.is_null() && arg_params_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_params as *const _, arg_params_size)
        });
        let result = ImplDevToolsMessageObserver::on_dev_tools_event(
            &arg_self_.interface,
            arg_browser,
            arg_method,
            arg_params,
        );
    }
    extern "C" fn on_dev_tools_agent_attached<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplDevToolsMessageObserver::on_dev_tools_agent_attached(
            &arg_self_.interface,
            arg_browser,
        );
    }
    extern "C" fn on_dev_tools_agent_detached<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplDevToolsMessageObserver::on_dev_tools_agent_detached(
            &arg_self_.interface,
            arg_browser,
        );
    }
}
impl ImplDevToolsMessageObserver for DevToolsMessageObserver {
    fn on_dev_tools_message(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message: Option<&[u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_dev_tools_message
                .map(|f| {
                    let (arg_browser, arg_message) = (browser, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_message_size = arg_message
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_message = arg_message
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_dev_tools_method_result(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: Option<&[u8]>,
    ) {
        unsafe {
            self.0
                .on_dev_tools_method_result
                .map(|f| {
                    let (arg_browser, arg_message_id, arg_success, arg_result) =
                        (browser, message_id, success, result);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_message_id = arg_message_id;
                    let arg_success = arg_success;
                    let arg_result_size =
                        arg_result.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_result = arg_result
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_message_id,
                        arg_success,
                        arg_result,
                        arg_result_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dev_tools_event(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        method: Option<&CefStringUtf16>,
        params: Option<&[u8]>,
    ) {
        unsafe {
            self.0
                .on_dev_tools_event
                .map(|f| {
                    let (arg_browser, arg_method, arg_params) = (browser, method, params);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_method = arg_method
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_params_size =
                        arg_params.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_params = arg_params
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_method,
                        arg_params,
                        arg_params_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dev_tools_agent_attached(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_dev_tools_agent_attached
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dev_tools_agent_detached(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_dev_tools_agent_detached
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_dev_tools_message_observer_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_dev_tools_message_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DevToolsMessageObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dev_tools_message_observer_t> for &DevToolsMessageObserver {
    fn as_raw(self) -> *mut _cef_dev_tools_message_observer_t {
        ImplDevToolsMessageObserver::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_dev_tools_message_observer_t> for &mut DevToolsMessageObserver {
    fn as_raw(self) -> *mut _cef_dev_tools_message_observer_t {
        ImplDevToolsMessageObserver::get_raw(self)
    }
}
impl ConvertReturnValue<DevToolsMessageObserver> for *mut _cef_dev_tools_message_observer_t {
    fn as_wrapper(self) -> DevToolsMessageObserver {
        DevToolsMessageObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_dev_tools_message_observer_t> for DevToolsMessageObserver {
    fn into(self) -> *mut _cef_dev_tools_message_observer_t {
        let object = ImplDevToolsMessageObserver::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DevToolsMessageObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_value_t] for more documentation.
#[derive(Clone)]
pub struct Value(RefGuard<_cef_value_t>);
impl Value {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapValue,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplValue>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapValue>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_value_t).as_wrapper()
        }
    }
}
pub trait WrapValue: ImplValue {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_value_t, Self>);
}
pub trait ImplValue: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_equal(&self, that: Option<&mut impl ImplValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn copy(&self) -> Option<Value> {
        Default::default()
    }
    fn get_type(&self) -> ValueType {
        Default::default()
    }
    fn get_bool(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_int(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_double(&self) -> f64 {
        Default::default()
    }
    fn get_string(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_binary(&self) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_dictionary(&self) -> Option<DictionaryValue> {
        Default::default()
    }
    fn get_list(&self) -> Option<ListValue> {
        Default::default()
    }
    fn set_null(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_bool(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_int(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_double(&self, value: f64) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_string(&self, value: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_binary(&self, value: Option<&mut impl ImplBinaryValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_dictionary(
        &self,
        value: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_list(&self, value: Option<&mut impl ImplListValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_value_t) {
        impl_cef_value_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_value_t;
}
mod impl_cef_value_t {
    use super::*;
    pub fn init_methods<I: ImplValue>(object: &mut _cef_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_bool = Some(get_bool::<I>);
        object.get_int = Some(get_int::<I>);
        object.get_double = Some(get_double::<I>);
        object.get_string = Some(get_string::<I>);
        object.get_binary = Some(get_binary::<I>);
        object.get_dictionary = Some(get_dictionary::<I>);
        object.get_list = Some(get_list::<I>);
        object.set_null = Some(set_null::<I>);
        object.set_bool = Some(set_bool::<I>);
        object.set_int = Some(set_int::<I>);
        object.set_double = Some(set_double::<I>);
        object.set_string = Some(set_string::<I>);
        object.set_binary = Some(set_binary::<I>);
        object.set_dictionary = Some(set_dictionary::<I>);
        object.set_list = Some(set_list::<I>);
    }
    extern "C" fn is_valid<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_owned<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::is_owned(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_read_only<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplValue>(
        self_: *mut _cef_value_t,
        that: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplValue::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn is_equal<I: ImplValue>(
        self_: *mut _cef_value_t,
        that: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplValue::is_equal(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn copy<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::copy(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_type<I: ImplValue>(self_: *mut _cef_value_t) -> cef_value_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_bool<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_bool(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_int<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_int(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_double<I: ImplValue>(self_: *mut _cef_value_t) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_double(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_string<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_string(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_binary<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_binary(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_dictionary<I: ImplValue>(
        self_: *mut _cef_value_t,
    ) -> *mut _cef_dictionary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_dictionary(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_list<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_list_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::get_list(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_null<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplValue::set_null(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_bool<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = arg_value.as_raw();
        let result = ImplValue::set_bool(&arg_self_.interface, arg_value);
        result.into()
    }
    extern "C" fn set_int<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = arg_value.as_raw();
        let result = ImplValue::set_int(&arg_self_.interface, arg_value);
        result.into()
    }
    extern "C" fn set_double<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: f64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = arg_value.as_raw();
        let result = ImplValue::set_double(&arg_self_.interface, arg_value);
        result.into()
    }
    extern "C" fn set_string<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let result = ImplValue::set_string(&arg_self_.interface, arg_value);
        result.into()
    }
    extern "C" fn set_binary<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_value = unsafe { arg_value.as_mut() }
            .map(|arg| BinaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplValue::set_binary(&arg_self_.interface, arg_value);
        result.into()
    }
    extern "C" fn set_dictionary<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_value = unsafe { arg_value.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplValue::set_dictionary(&arg_self_.interface, arg_value);
        result.into()
    }
    extern "C" fn set_list<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| ListValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplValue::set_list(&arg_self_.interface, arg_value);
        result.into()
    }
}
impl ImplValue for Value {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut impl ImplValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<Value> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_bool(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_int(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_double(&self) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_string(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_binary(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_dictionary(&self) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_list(&self) -> Option<ListValue> {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_null(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_bool(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_int(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_double(&self, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_string(&self, value: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_binary(&self, value: Option<&mut impl ImplBinaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_dictionary(
        &self,
        value: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_list(&self, value: Option<&mut impl ImplListValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_value_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Value {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_value_t> for &Value {
    fn as_raw(self) -> *mut _cef_value_t {
        ImplValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_value_t> for &mut Value {
    fn as_raw(self) -> *mut _cef_value_t {
        ImplValue::get_raw(self)
    }
}
impl ConvertReturnValue<Value> for *mut _cef_value_t {
    fn as_wrapper(self) -> Value {
        Value(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_value_t> for Value {
    fn into(self) -> *mut _cef_value_t {
        let object = ImplValue::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Value {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_binary_value_t] for more documentation.
#[derive(Clone)]
pub struct BinaryValue(RefGuard<_cef_binary_value_t>);
impl BinaryValue {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBinaryValue,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBinaryValue>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBinaryValue>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_binary_value_t).as_wrapper()
        }
    }
}
pub trait WrapBinaryValue: ImplBinaryValue {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_binary_value_t, Self>);
}
pub trait ImplBinaryValue: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplBinaryValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_equal(&self, that: Option<&mut impl ImplBinaryValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn copy(&self) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_raw_data(&self) -> *const ::std::os::raw::c_void {
        unsafe { std::mem::zeroed() }
    }
    fn get_size(&self) -> usize {
        Default::default()
    }
    fn get_data(&self, buffer: Option<&mut Vec<u8>>, data_offset: usize) -> usize {
        Default::default()
    }
    fn init_methods(object: &mut _cef_binary_value_t) {
        impl_cef_binary_value_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_binary_value_t;
}
mod impl_cef_binary_value_t {
    use super::*;
    pub fn init_methods<I: ImplBinaryValue>(object: &mut _cef_binary_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.get_raw_data = Some(get_raw_data::<I>);
        object.get_size = Some(get_size::<I>);
        object.get_data = Some(get_data::<I>);
    }
    extern "C" fn is_valid<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBinaryValue::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_owned<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBinaryValue::is_owned(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
        that: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| BinaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplBinaryValue::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn is_equal<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
        that: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| BinaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplBinaryValue::is_equal(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn copy<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBinaryValue::copy(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_raw_data<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> *const ::std::os::raw::c_void {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBinaryValue::get_raw_data(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_size<I: ImplBinaryValue>(self_: *mut _cef_binary_value_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBinaryValue::get_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_data<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
        data_offset: usize,
    ) -> usize {
        let (arg_self_, arg_buffer, arg_buffer_size, arg_data_offset) =
            (self_, buffer, buffer_size, data_offset);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let out_buffer = (!arg_buffer.is_null() && arg_buffer_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_buffer as *mut _, arg_buffer_size)
        });
        let mut vec_buffer = out_buffer.as_ref().map(|arg| arg.to_vec());
        let arg_buffer = vec_buffer.as_mut();
        let arg_data_offset = arg_data_offset.as_raw();
        let result = ImplBinaryValue::get_data(&arg_self_.interface, arg_buffer, arg_data_offset);
        if let (Some(out_buffer), Some(vec_buffer)) = (out_buffer, vec_buffer.as_mut()) {
            let size = vec_buffer.len().min(out_buffer.len());
            out_buffer[..size].copy_from_slice(&vec_buffer[..size]);
        }
        result.into()
    }
}
impl ImplBinaryValue for BinaryValue {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplBinaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut impl ImplBinaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw_data(&self) -> *const ::std::os::raw::c_void {
        unsafe {
            self.0
                .get_raw_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_data(&self, buffer: Option<&mut Vec<u8>>, data_offset: usize) -> usize {
        unsafe {
            self.0
                .get_data
                .map(|f| {
                    let (arg_buffer, arg_data_offset) = (buffer, data_offset);
                    let arg_self_ = self.as_raw();
                    let arg_buffer_size =
                        arg_buffer.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let mut out_buffer = arg_buffer;
                    let arg_buffer = out_buffer
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_offset = arg_data_offset;
                    let result = f(arg_self_, arg_buffer, arg_buffer_size, arg_data_offset);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_binary_value_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_binary_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BinaryValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_binary_value_t> for &BinaryValue {
    fn as_raw(self) -> *mut _cef_binary_value_t {
        ImplBinaryValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_binary_value_t> for &mut BinaryValue {
    fn as_raw(self) -> *mut _cef_binary_value_t {
        ImplBinaryValue::get_raw(self)
    }
}
impl ConvertReturnValue<BinaryValue> for *mut _cef_binary_value_t {
    fn as_wrapper(self) -> BinaryValue {
        BinaryValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_binary_value_t> for BinaryValue {
    fn into(self) -> *mut _cef_binary_value_t {
        let object = ImplBinaryValue::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for BinaryValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_dictionary_value_t] for more documentation.
#[derive(Clone)]
pub struct DictionaryValue(RefGuard<_cef_dictionary_value_t>);
impl DictionaryValue {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDictionaryValue,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDictionaryValue>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDictionaryValue>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_dictionary_value_t).as_wrapper()
        }
    }
}
pub trait WrapDictionaryValue: ImplDictionaryValue {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_dictionary_value_t, Self>);
}
pub trait ImplDictionaryValue: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplDictionaryValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_equal(&self, that: Option<&mut impl ImplDictionaryValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn copy(&self, exclude_empty_children: ::std::os::raw::c_int) -> Option<DictionaryValue> {
        Default::default()
    }
    fn get_size(&self) -> usize {
        Default::default()
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_key(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn remove(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_type(&self, key: Option<&CefStringUtf16>) -> ValueType {
        Default::default()
    }
    fn get_value(&self, key: Option<&CefStringUtf16>) -> Option<Value> {
        Default::default()
    }
    fn get_bool(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_int(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_double(&self, key: Option<&CefStringUtf16>) -> f64 {
        Default::default()
    }
    fn get_string(&self, key: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_binary(&self, key: Option<&CefStringUtf16>) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_dictionary(&self, key: Option<&CefStringUtf16>) -> Option<DictionaryValue> {
        Default::default()
    }
    fn get_list(&self, key: Option<&CefStringUtf16>) -> Option<ListValue> {
        Default::default()
    }
    fn set_value(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_null(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_bool(
        &self,
        key: Option<&CefStringUtf16>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_int(
        &self,
        key: Option<&CefStringUtf16>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_double(&self, key: Option<&CefStringUtf16>, value: f64) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_string(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_binary(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplBinaryValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_dictionary(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_list(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplListValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_dictionary_value_t) {
        impl_cef_dictionary_value_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_dictionary_value_t;
}
mod impl_cef_dictionary_value_t {
    use super::*;
    pub fn init_methods<I: ImplDictionaryValue>(object: &mut _cef_dictionary_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.get_size = Some(get_size::<I>);
        object.clear = Some(clear::<I>);
        object.has_key = Some(has_key::<I>);
        object.get_keys = Some(get_keys::<I>);
        object.remove = Some(remove::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_value = Some(get_value::<I>);
        object.get_bool = Some(get_bool::<I>);
        object.get_int = Some(get_int::<I>);
        object.get_double = Some(get_double::<I>);
        object.get_string = Some(get_string::<I>);
        object.get_binary = Some(get_binary::<I>);
        object.get_dictionary = Some(get_dictionary::<I>);
        object.get_list = Some(get_list::<I>);
        object.set_value = Some(set_value::<I>);
        object.set_null = Some(set_null::<I>);
        object.set_bool = Some(set_bool::<I>);
        object.set_int = Some(set_int::<I>);
        object.set_double = Some(set_double::<I>);
        object.set_string = Some(set_string::<I>);
        object.set_binary = Some(set_binary::<I>);
        object.set_dictionary = Some(set_dictionary::<I>);
        object.set_list = Some(set_list::<I>);
    }
    extern "C" fn is_valid<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDictionaryValue::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_owned<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDictionaryValue::is_owned(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_read_only<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDictionaryValue::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        that: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that = unsafe { arg_that.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplDictionaryValue::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn is_equal<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        that: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that = unsafe { arg_that.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplDictionaryValue::is_equal(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn copy<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        exclude_empty_children: ::std::os::raw::c_int,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_exclude_empty_children) = (self_, exclude_empty_children);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_exclude_empty_children = arg_exclude_empty_children.as_raw();
        let result = ImplDictionaryValue::copy(&arg_self_.interface, arg_exclude_empty_children);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_size<I: ImplDictionaryValue>(self_: *mut _cef_dictionary_value_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDictionaryValue::get_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn clear<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDictionaryValue::clear(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_key<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::has_key(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn get_keys<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        keys: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_keys) = (self_, keys);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_keys = if arg_keys.is_null() {
            None
        } else {
            Some(arg_keys.into())
        };
        let arg_keys = arg_keys.as_mut();
        let result = ImplDictionaryValue::get_keys(&arg_self_.interface, arg_keys);
        result.into()
    }
    extern "C" fn remove<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::remove(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn get_type<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> cef_value_type_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_type(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn get_value<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_value(&arg_self_.interface, arg_key);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_bool<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_bool(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn get_int<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_int(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn get_double<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> f64 {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_double(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn get_string<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_string(&arg_self_.interface, arg_key);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_binary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_binary(&arg_self_.interface, arg_key);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_dictionary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_dictionary(&arg_self_.interface, arg_key);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_list<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_list_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::get_list(&arg_self_.interface, arg_key);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_value<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplDictionaryValue::set_value(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
    extern "C" fn set_null<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplDictionaryValue::set_null(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn set_bool<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let arg_value = arg_value.as_raw();
        let result = ImplDictionaryValue::set_bool(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
    extern "C" fn set_int<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let arg_value = arg_value.as_raw();
        let result = ImplDictionaryValue::set_int(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
    extern "C" fn set_double<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: f64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let arg_value = arg_value.as_raw();
        let result = ImplDictionaryValue::set_double(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
    extern "C" fn set_string<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let result = ImplDictionaryValue::set_string(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
    extern "C" fn set_binary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let mut arg_value = unsafe { arg_value.as_mut() }
            .map(|arg| BinaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplDictionaryValue::set_binary(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
    extern "C" fn set_dictionary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let mut arg_value = unsafe { arg_value.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplDictionaryValue::set_dictionary(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
    extern "C" fn set_list<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| ListValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplDictionaryValue::set_list(&arg_self_.interface, arg_key, arg_value);
        result.into()
    }
}
impl ImplDictionaryValue for DictionaryValue {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplDictionaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut impl ImplDictionaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self, exclude_empty_children: ::std::os::raw::c_int) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_exclude_empty_children = exclude_empty_children;
                    let arg_self_ = self.as_raw();
                    let arg_exclude_empty_children = arg_exclude_empty_children;
                    let result = f(arg_self_, arg_exclude_empty_children);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_size(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_key(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_key
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_keys
                .map(|f| {
                    let arg_keys = keys;
                    let arg_self_ = self.as_raw();
                    let arg_keys = arg_keys
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_keys);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn remove(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self, key: Option<&CefStringUtf16>) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_value(&self, key: Option<&CefStringUtf16>) -> Option<Value> {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_bool(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_int(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_double(&self, key: Option<&CefStringUtf16>) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_string(&self, key: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_binary(&self, key: Option<&CefStringUtf16>) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_dictionary(&self, key: Option<&CefStringUtf16>) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_list(&self, key: Option<&CefStringUtf16>) -> Option<ListValue> {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_value(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_null(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_bool(
        &self,
        key: Option<&CefStringUtf16>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_int(
        &self,
        key: Option<&CefStringUtf16>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_double(&self, key: Option<&CefStringUtf16>, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_string(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_binary(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplBinaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_dictionary(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_list(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplListValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_dictionary_value_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_dictionary_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DictionaryValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dictionary_value_t> for &DictionaryValue {
    fn as_raw(self) -> *mut _cef_dictionary_value_t {
        ImplDictionaryValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_dictionary_value_t> for &mut DictionaryValue {
    fn as_raw(self) -> *mut _cef_dictionary_value_t {
        ImplDictionaryValue::get_raw(self)
    }
}
impl ConvertReturnValue<DictionaryValue> for *mut _cef_dictionary_value_t {
    fn as_wrapper(self) -> DictionaryValue {
        DictionaryValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_dictionary_value_t> for DictionaryValue {
    fn into(self) -> *mut _cef_dictionary_value_t {
        let object = ImplDictionaryValue::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DictionaryValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_list_value_t] for more documentation.
#[derive(Clone)]
pub struct ListValue(RefGuard<_cef_list_value_t>);
impl ListValue {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapListValue,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplListValue>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapListValue>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_list_value_t).as_wrapper()
        }
    }
}
pub trait WrapListValue: ImplListValue {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_list_value_t, Self>);
}
pub trait ImplListValue: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplListValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_equal(&self, that: Option<&mut impl ImplListValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn copy(&self) -> Option<ListValue> {
        Default::default()
    }
    fn set_size(&self, size: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_size(&self) -> usize {
        Default::default()
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn remove(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_type(&self, index: usize) -> ValueType {
        Default::default()
    }
    fn get_value(&self, index: usize) -> Option<Value> {
        Default::default()
    }
    fn get_bool(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_int(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_double(&self, index: usize) -> f64 {
        Default::default()
    }
    fn get_string(&self, index: usize) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_binary(&self, index: usize) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_dictionary(&self, index: usize) -> Option<DictionaryValue> {
        Default::default()
    }
    fn get_list(&self, index: usize) -> Option<ListValue> {
        Default::default()
    }
    fn set_value(&self, index: usize, value: Option<&mut impl ImplValue>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_null(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_bool(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_int(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_double(&self, index: usize, value: f64) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_string(&self, index: usize, value: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_binary(
        &self,
        index: usize,
        value: Option<&mut impl ImplBinaryValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_dictionary(
        &self,
        index: usize,
        value: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_list(
        &self,
        index: usize,
        value: Option<&mut impl ImplListValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_list_value_t) {
        impl_cef_list_value_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_list_value_t;
}
mod impl_cef_list_value_t {
    use super::*;
    pub fn init_methods<I: ImplListValue>(object: &mut _cef_list_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.set_size = Some(set_size::<I>);
        object.get_size = Some(get_size::<I>);
        object.clear = Some(clear::<I>);
        object.remove = Some(remove::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_value = Some(get_value::<I>);
        object.get_bool = Some(get_bool::<I>);
        object.get_int = Some(get_int::<I>);
        object.get_double = Some(get_double::<I>);
        object.get_string = Some(get_string::<I>);
        object.get_binary = Some(get_binary::<I>);
        object.get_dictionary = Some(get_dictionary::<I>);
        object.get_list = Some(get_list::<I>);
        object.set_value = Some(set_value::<I>);
        object.set_null = Some(set_null::<I>);
        object.set_bool = Some(set_bool::<I>);
        object.set_int = Some(set_int::<I>);
        object.set_double = Some(set_double::<I>);
        object.set_string = Some(set_string::<I>);
        object.set_binary = Some(set_binary::<I>);
        object.set_dictionary = Some(set_dictionary::<I>);
        object.set_list = Some(set_list::<I>);
    }
    extern "C" fn is_valid<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplListValue::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_owned<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplListValue::is_owned(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_read_only<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplListValue::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        that: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| ListValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplListValue::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn is_equal<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        that: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| ListValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplListValue::is_equal(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn copy<I: ImplListValue>(self_: *mut _cef_list_value_t) -> *mut _cef_list_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplListValue::copy(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_size<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        let result = ImplListValue::set_size(&arg_self_.interface, arg_size);
        result.into()
    }
    extern "C" fn get_size<I: ImplListValue>(self_: *mut _cef_list_value_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplListValue::get_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn clear<I: ImplListValue>(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplListValue::clear(&arg_self_.interface);
        result.into()
    }
    extern "C" fn remove<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::remove(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_type<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> cef_value_type_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_type(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_value<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_value(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_bool<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_bool(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_int<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_int(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_double<I: ImplListValue>(self_: *mut _cef_list_value_t, index: usize) -> f64 {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_double(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_string<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_string(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_binary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_binary(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_dictionary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_dictionary(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_list<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_list_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::get_list(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_value<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplListValue::set_value(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_null<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplListValue::set_null(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn set_bool<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = arg_value.as_raw();
        let result = ImplListValue::set_bool(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_int<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = arg_value.as_raw();
        let result = ImplListValue::set_int(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_double<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: f64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = arg_value.as_raw();
        let result = ImplListValue::set_double(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_string<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let result = ImplListValue::set_string(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_binary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_value = unsafe { arg_value.as_mut() }
            .map(|arg| BinaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplListValue::set_binary(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_dictionary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_value = unsafe { arg_value.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplListValue::set_dictionary(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_list<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| ListValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplListValue::set_list(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
}
impl ImplListValue for ListValue {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplListValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut impl ImplListValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<ListValue> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_size(&self, size: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size;
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_size(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn remove(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self, index: usize) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_value(&self, index: usize) -> Option<Value> {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_bool(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_int(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_double(&self, index: usize) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_string(&self, index: usize) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_binary(&self, index: usize) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_dictionary(&self, index: usize) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_list(&self, index: usize) -> Option<ListValue> {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_value(&self, index: usize, value: Option<&mut impl ImplValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_null(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_bool(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_int(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_double(&self, index: usize, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_string(&self, index: usize, value: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_binary(
        &self,
        index: usize,
        value: Option<&mut impl ImplBinaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_dictionary(
        &self,
        index: usize,
        value: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_list(
        &self,
        index: usize,
        value: Option<&mut impl ImplListValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_list_value_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_list_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ListValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_list_value_t> for &ListValue {
    fn as_raw(self) -> *mut _cef_list_value_t {
        ImplListValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_list_value_t> for &mut ListValue {
    fn as_raw(self) -> *mut _cef_list_value_t {
        ImplListValue::get_raw(self)
    }
}
impl ConvertReturnValue<ListValue> for *mut _cef_list_value_t {
    fn as_wrapper(self) -> ListValue {
        ListValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_list_value_t> for ListValue {
    fn into(self) -> *mut _cef_list_value_t {
        let object = ImplListValue::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ListValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_image_t] for more documentation.
#[derive(Clone)]
pub struct Image(RefGuard<_cef_image_t>);
impl Image {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapImage,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplImage>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapImage>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_image_t).as_wrapper()
        }
    }
}
pub trait WrapImage: ImplImage {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_image_t, Self>);
}
pub trait ImplImage: Clone + Sized + Rc {
    fn is_empty(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplImage>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_bitmap(
        &self,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_data: Option<&[u8]>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_png(&self, scale_factor: f32, png_data: Option<&[u8]>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_jpeg(&self, scale_factor: f32, jpeg_data: Option<&[u8]>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_width(&self) -> usize {
        Default::default()
    }
    fn get_height(&self) -> usize {
        Default::default()
    }
    fn has_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn remove_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_representation_info(
        &self,
        scale_factor: f32,
        actual_scale_factor: Option<&mut f32>,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_as_bitmap(
        &self,
        scale_factor: f32,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_as_png(
        &self,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_as_jpeg(
        &self,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_image_t) {
        impl_cef_image_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_image_t;
}
mod impl_cef_image_t {
    use super::*;
    pub fn init_methods<I: ImplImage>(object: &mut _cef_image_t) {
        object.is_empty = Some(is_empty::<I>);
        object.is_same = Some(is_same::<I>);
        object.add_bitmap = Some(add_bitmap::<I>);
        object.add_png = Some(add_png::<I>);
        object.add_jpeg = Some(add_jpeg::<I>);
        object.get_width = Some(get_width::<I>);
        object.get_height = Some(get_height::<I>);
        object.has_representation = Some(has_representation::<I>);
        object.remove_representation = Some(remove_representation::<I>);
        object.get_representation_info = Some(get_representation_info::<I>);
        object.get_as_bitmap = Some(get_as_bitmap::<I>);
        object.get_as_png = Some(get_as_png::<I>);
        object.get_as_jpeg = Some(get_as_jpeg::<I>);
    }
    extern "C" fn is_empty<I: ImplImage>(self_: *mut _cef_image_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplImage::is_empty(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplImage>(
        self_: *mut _cef_image_t,
        that: *mut _cef_image_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| Image(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplImage::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn add_bitmap<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: cef_color_type_t,
        alpha_type: cef_alpha_type_t,
        pixel_data: *const ::std::os::raw::c_void,
        pixel_data_size: usize,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_scale_factor,
            arg_pixel_width,
            arg_pixel_height,
            arg_color_type,
            arg_alpha_type,
            arg_pixel_data,
            arg_pixel_data_size,
        ) = (
            self_,
            scale_factor,
            pixel_width,
            pixel_height,
            color_type,
            alpha_type,
            pixel_data,
            pixel_data_size,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_pixel_width = arg_pixel_width.as_raw();
        let arg_pixel_height = arg_pixel_height.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_alpha_type = arg_alpha_type.as_raw();
        let arg_pixel_data =
            (!arg_pixel_data.is_null() && arg_pixel_data_size > 0).then(|| unsafe {
                std::slice::from_raw_parts(arg_pixel_data as *const _, arg_pixel_data_size)
            });
        let result = ImplImage::add_bitmap(
            &arg_self_.interface,
            arg_scale_factor,
            arg_pixel_width,
            arg_pixel_height,
            arg_color_type,
            arg_alpha_type,
            arg_pixel_data,
        );
        result.into()
    }
    extern "C" fn add_png<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        png_data: *const ::std::os::raw::c_void,
        png_data_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor, arg_png_data, arg_png_data_size) =
            (self_, scale_factor, png_data, png_data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_png_data = (!arg_png_data.is_null() && arg_png_data_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_png_data as *const _, arg_png_data_size)
        });
        let result = ImplImage::add_png(&arg_self_.interface, arg_scale_factor, arg_png_data);
        result.into()
    }
    extern "C" fn add_jpeg<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        jpeg_data: *const ::std::os::raw::c_void,
        jpeg_data_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor, arg_jpeg_data, arg_jpeg_data_size) =
            (self_, scale_factor, jpeg_data, jpeg_data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_jpeg_data = (!arg_jpeg_data.is_null() && arg_jpeg_data_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_jpeg_data as *const _, arg_jpeg_data_size)
        });
        let result = ImplImage::add_jpeg(&arg_self_.interface, arg_scale_factor, arg_jpeg_data);
        result.into()
    }
    extern "C" fn get_width<I: ImplImage>(self_: *mut _cef_image_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplImage::get_width(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_height<I: ImplImage>(self_: *mut _cef_image_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplImage::get_height(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_representation<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor) = (self_, scale_factor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let result = ImplImage::has_representation(&arg_self_.interface, arg_scale_factor);
        result.into()
    }
    extern "C" fn remove_representation<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor) = (self_, scale_factor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let result = ImplImage::remove_representation(&arg_self_.interface, arg_scale_factor);
        result.into()
    }
    extern "C" fn get_representation_info<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        actual_scale_factor: *mut f32,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_scale_factor,
            arg_actual_scale_factor,
            arg_pixel_width,
            arg_pixel_height,
        ) = (
            self_,
            scale_factor,
            actual_scale_factor,
            pixel_width,
            pixel_height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let mut arg_actual_scale_factor = if arg_actual_scale_factor.is_null() {
            None
        } else {
            Some(WrapParamRef::<f32>::from(arg_actual_scale_factor))
        };
        let arg_actual_scale_factor = arg_actual_scale_factor.as_mut().map(|arg| arg.as_mut());
        let mut arg_pixel_width = if arg_pixel_width.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width))
        };
        let arg_pixel_width = arg_pixel_width.as_mut().map(|arg| arg.as_mut());
        let mut arg_pixel_height = if arg_pixel_height.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_pixel_height,
            ))
        };
        let arg_pixel_height = arg_pixel_height.as_mut().map(|arg| arg.as_mut());
        let result = ImplImage::get_representation_info(
            &arg_self_.interface,
            arg_scale_factor,
            arg_actual_scale_factor,
            arg_pixel_width,
            arg_pixel_height,
        );
        result.into()
    }
    extern "C" fn get_as_bitmap<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        color_type: cef_color_type_t,
        alpha_type: cef_alpha_type_t,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_binary_value_t {
        let (
            arg_self_,
            arg_scale_factor,
            arg_color_type,
            arg_alpha_type,
            arg_pixel_width,
            arg_pixel_height,
        ) = (
            self_,
            scale_factor,
            color_type,
            alpha_type,
            pixel_width,
            pixel_height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_alpha_type = arg_alpha_type.as_raw();
        let mut arg_pixel_width = if arg_pixel_width.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width))
        };
        let arg_pixel_width = arg_pixel_width.as_mut().map(|arg| arg.as_mut());
        let mut arg_pixel_height = if arg_pixel_height.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_pixel_height,
            ))
        };
        let arg_pixel_height = arg_pixel_height.as_mut().map(|arg| arg.as_mut());
        let result = ImplImage::get_as_bitmap(
            &arg_self_.interface,
            arg_scale_factor,
            arg_color_type,
            arg_alpha_type,
            arg_pixel_width,
            arg_pixel_height,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_as_png<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_scale_factor, arg_with_transparency, arg_pixel_width, arg_pixel_height) = (
            self_,
            scale_factor,
            with_transparency,
            pixel_width,
            pixel_height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_with_transparency = arg_with_transparency.as_raw();
        let mut arg_pixel_width = if arg_pixel_width.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width))
        };
        let arg_pixel_width = arg_pixel_width.as_mut().map(|arg| arg.as_mut());
        let mut arg_pixel_height = if arg_pixel_height.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_pixel_height,
            ))
        };
        let arg_pixel_height = arg_pixel_height.as_mut().map(|arg| arg.as_mut());
        let result = ImplImage::get_as_png(
            &arg_self_.interface,
            arg_scale_factor,
            arg_with_transparency,
            arg_pixel_width,
            arg_pixel_height,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_as_jpeg<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_scale_factor, arg_quality, arg_pixel_width, arg_pixel_height) =
            (self_, scale_factor, quality, pixel_width, pixel_height);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_quality = arg_quality.as_raw();
        let mut arg_pixel_width = if arg_pixel_width.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width))
        };
        let arg_pixel_width = arg_pixel_width.as_mut().map(|arg| arg.as_mut());
        let mut arg_pixel_height = if arg_pixel_height.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_pixel_height,
            ))
        };
        let arg_pixel_height = arg_pixel_height.as_mut().map(|arg| arg.as_mut());
        let result = ImplImage::get_as_jpeg(
            &arg_self_.interface,
            arg_scale_factor,
            arg_quality,
            arg_pixel_width,
            arg_pixel_height,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplImage for Image {
    fn is_empty(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_empty
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplImage>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplImage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_bitmap(
        &self,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_data: Option<&[u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_bitmap
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_data,
                    ) = (
                        scale_factor,
                        pixel_width,
                        pixel_height,
                        color_type,
                        alpha_type,
                        pixel_data,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_pixel_width = arg_pixel_width;
                    let arg_pixel_height = arg_pixel_height;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_alpha_type = arg_alpha_type.as_raw();
                    let arg_pixel_data_size = arg_pixel_data
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_pixel_data = arg_pixel_data
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_data,
                        arg_pixel_data_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_png(&self, scale_factor: f32, png_data: Option<&[u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_png
                .map(|f| {
                    let (arg_scale_factor, arg_png_data) = (scale_factor, png_data);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_png_data_size = arg_png_data
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_png_data = arg_png_data
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_scale_factor, arg_png_data, arg_png_data_size);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_jpeg(&self, scale_factor: f32, jpeg_data: Option<&[u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_jpeg
                .map(|f| {
                    let (arg_scale_factor, arg_jpeg_data) = (scale_factor, jpeg_data);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_jpeg_data_size = arg_jpeg_data
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_jpeg_data = arg_jpeg_data
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_jpeg_data,
                        arg_jpeg_data_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_width(&self) -> usize {
        unsafe {
            self.0
                .get_width
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_height(&self) -> usize {
        unsafe {
            self.0
                .get_height
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_representation
                .map(|f| {
                    let arg_scale_factor = scale_factor;
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let result = f(arg_self_, arg_scale_factor);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn remove_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_representation
                .map(|f| {
                    let arg_scale_factor = scale_factor;
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let result = f(arg_self_, arg_scale_factor);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_representation_info(
        &self,
        scale_factor: f32,
        actual_scale_factor: Option<&mut f32>,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_representation_info
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_actual_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (scale_factor, actual_scale_factor, pixel_width, pixel_height);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_actual_scale_factor = arg_actual_scale_factor
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_actual_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_as_bitmap(
        &self,
        scale_factor: f32,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_as_bitmap
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (
                        scale_factor,
                        color_type,
                        alpha_type,
                        pixel_width,
                        pixel_height,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_alpha_type = arg_alpha_type.as_raw();
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_as_png(
        &self,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_as_png
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_with_transparency,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (scale_factor, with_transparency, pixel_width, pixel_height);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_with_transparency = arg_with_transparency;
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_with_transparency,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_as_jpeg(
        &self,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_as_jpeg
                .map(|f| {
                    let (arg_scale_factor, arg_quality, arg_pixel_width, arg_pixel_height) =
                        (scale_factor, quality, pixel_width, pixel_height);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_quality = arg_quality;
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_quality,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_image_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_image_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Image {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_image_t> for &Image {
    fn as_raw(self) -> *mut _cef_image_t {
        ImplImage::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_image_t> for &mut Image {
    fn as_raw(self) -> *mut _cef_image_t {
        ImplImage::get_raw(self)
    }
}
impl ConvertReturnValue<Image> for *mut _cef_image_t {
    fn as_wrapper(self) -> Image {
        Image(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_image_t> for Image {
    fn into(self) -> *mut _cef_image_t {
        let object = ImplImage::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Image {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_read_handler_t] for more documentation.
#[derive(Clone)]
pub struct ReadHandler(RefGuard<_cef_read_handler_t>);
impl ReadHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapReadHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplReadHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapReadHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_read_handler_t).as_wrapper()
        }
    }
}
pub trait WrapReadHandler: ImplReadHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_read_handler_t, Self>);
}
pub trait ImplReadHandler: Clone + Sized + Rc {
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize {
        Default::default()
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn tell(&self) -> i64 {
        Default::default()
    }
    fn eof(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_read_handler_t) {
        impl_cef_read_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_read_handler_t;
}
mod impl_cef_read_handler_t {
    use super::*;
    pub fn init_methods<I: ImplReadHandler>(object: &mut _cef_read_handler_t) {
        object.read = Some(read::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.eof = Some(eof::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn read<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ptr = arg_ptr as *mut _;
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        let result = ImplReadHandler::read(&arg_self_.interface, arg_ptr, arg_size, arg_n);
        result.into()
    }
    extern "C" fn seek<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        let result = ImplReadHandler::seek(&arg_self_.interface, arg_offset, arg_whence);
        result.into()
    }
    extern "C" fn tell<I: ImplReadHandler>(self_: *mut _cef_read_handler_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplReadHandler::tell(&arg_self_.interface);
        result.into()
    }
    extern "C" fn eof<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplReadHandler::eof(&arg_self_.interface);
        result.into()
    }
    extern "C" fn may_block<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplReadHandler::may_block(&arg_self_.interface);
        result.into()
    }
}
impl ImplReadHandler for ReadHandler {
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *mut _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn eof(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eof
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_read_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_read_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ReadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_read_handler_t> for &ReadHandler {
    fn as_raw(self) -> *mut _cef_read_handler_t {
        ImplReadHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_read_handler_t> for &mut ReadHandler {
    fn as_raw(self) -> *mut _cef_read_handler_t {
        ImplReadHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ReadHandler> for *mut _cef_read_handler_t {
    fn as_wrapper(self) -> ReadHandler {
        ReadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_read_handler_t> for ReadHandler {
    fn into(self) -> *mut _cef_read_handler_t {
        let object = ImplReadHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ReadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_stream_reader_t] for more documentation.
#[derive(Clone)]
pub struct StreamReader(RefGuard<_cef_stream_reader_t>);
impl StreamReader {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapStreamReader,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplStreamReader>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapStreamReader>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_stream_reader_t).as_wrapper()
        }
    }
}
pub trait WrapStreamReader: ImplStreamReader {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_stream_reader_t, Self>);
}
pub trait ImplStreamReader: Clone + Sized + Rc {
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize {
        Default::default()
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn tell(&self) -> i64 {
        Default::default()
    }
    fn eof(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_stream_reader_t) {
        impl_cef_stream_reader_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_stream_reader_t;
}
mod impl_cef_stream_reader_t {
    use super::*;
    pub fn init_methods<I: ImplStreamReader>(object: &mut _cef_stream_reader_t) {
        object.read = Some(read::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.eof = Some(eof::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn read<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ptr = arg_ptr as *mut _;
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        let result = ImplStreamReader::read(&arg_self_.interface, arg_ptr, arg_size, arg_n);
        result.into()
    }
    extern "C" fn seek<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        let result = ImplStreamReader::seek(&arg_self_.interface, arg_offset, arg_whence);
        result.into()
    }
    extern "C" fn tell<I: ImplStreamReader>(self_: *mut _cef_stream_reader_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplStreamReader::tell(&arg_self_.interface);
        result.into()
    }
    extern "C" fn eof<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplStreamReader::eof(&arg_self_.interface);
        result.into()
    }
    extern "C" fn may_block<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplStreamReader::may_block(&arg_self_.interface);
        result.into()
    }
}
impl ImplStreamReader for StreamReader {
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *mut _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn eof(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eof
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_stream_reader_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_stream_reader_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for StreamReader {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_stream_reader_t> for &StreamReader {
    fn as_raw(self) -> *mut _cef_stream_reader_t {
        ImplStreamReader::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_stream_reader_t> for &mut StreamReader {
    fn as_raw(self) -> *mut _cef_stream_reader_t {
        ImplStreamReader::get_raw(self)
    }
}
impl ConvertReturnValue<StreamReader> for *mut _cef_stream_reader_t {
    fn as_wrapper(self) -> StreamReader {
        StreamReader(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_stream_reader_t> for StreamReader {
    fn into(self) -> *mut _cef_stream_reader_t {
        let object = ImplStreamReader::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for StreamReader {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_write_handler_t] for more documentation.
#[derive(Clone)]
pub struct WriteHandler(RefGuard<_cef_write_handler_t>);
impl WriteHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapWriteHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplWriteHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapWriteHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_write_handler_t).as_wrapper()
        }
    }
}
pub trait WrapWriteHandler: ImplWriteHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_write_handler_t, Self>);
}
pub trait ImplWriteHandler: Clone + Sized + Rc {
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize {
        Default::default()
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn tell(&self) -> i64 {
        Default::default()
    }
    fn flush(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_write_handler_t) {
        impl_cef_write_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_write_handler_t;
}
mod impl_cef_write_handler_t {
    use super::*;
    pub fn init_methods<I: ImplWriteHandler>(object: &mut _cef_write_handler_t) {
        object.write = Some(write::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.flush = Some(flush::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn write<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ptr = arg_ptr as *const _;
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        let result = ImplWriteHandler::write(&arg_self_.interface, arg_ptr, arg_size, arg_n);
        result.into()
    }
    extern "C" fn seek<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        let result = ImplWriteHandler::seek(&arg_self_.interface, arg_offset, arg_whence);
        result.into()
    }
    extern "C" fn tell<I: ImplWriteHandler>(self_: *mut _cef_write_handler_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWriteHandler::tell(&arg_self_.interface);
        result.into()
    }
    extern "C" fn flush<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWriteHandler::flush(&arg_self_.interface);
        result.into()
    }
    extern "C" fn may_block<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWriteHandler::may_block(&arg_self_.interface);
        result.into()
    }
}
impl ImplWriteHandler for WriteHandler {
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .write
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *const _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn flush(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_write_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_write_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for WriteHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_write_handler_t> for &WriteHandler {
    fn as_raw(self) -> *mut _cef_write_handler_t {
        ImplWriteHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_write_handler_t> for &mut WriteHandler {
    fn as_raw(self) -> *mut _cef_write_handler_t {
        ImplWriteHandler::get_raw(self)
    }
}
impl ConvertReturnValue<WriteHandler> for *mut _cef_write_handler_t {
    fn as_wrapper(self) -> WriteHandler {
        WriteHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_write_handler_t> for WriteHandler {
    fn into(self) -> *mut _cef_write_handler_t {
        let object = ImplWriteHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for WriteHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_stream_writer_t] for more documentation.
#[derive(Clone)]
pub struct StreamWriter(RefGuard<_cef_stream_writer_t>);
impl StreamWriter {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapStreamWriter,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplStreamWriter>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapStreamWriter>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_stream_writer_t).as_wrapper()
        }
    }
}
pub trait WrapStreamWriter: ImplStreamWriter {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_stream_writer_t, Self>);
}
pub trait ImplStreamWriter: Clone + Sized + Rc {
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize {
        Default::default()
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn tell(&self) -> i64 {
        Default::default()
    }
    fn flush(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_stream_writer_t) {
        impl_cef_stream_writer_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_stream_writer_t;
}
mod impl_cef_stream_writer_t {
    use super::*;
    pub fn init_methods<I: ImplStreamWriter>(object: &mut _cef_stream_writer_t) {
        object.write = Some(write::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.flush = Some(flush::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn write<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ptr = arg_ptr as *const _;
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        let result = ImplStreamWriter::write(&arg_self_.interface, arg_ptr, arg_size, arg_n);
        result.into()
    }
    extern "C" fn seek<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        let result = ImplStreamWriter::seek(&arg_self_.interface, arg_offset, arg_whence);
        result.into()
    }
    extern "C" fn tell<I: ImplStreamWriter>(self_: *mut _cef_stream_writer_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplStreamWriter::tell(&arg_self_.interface);
        result.into()
    }
    extern "C" fn flush<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplStreamWriter::flush(&arg_self_.interface);
        result.into()
    }
    extern "C" fn may_block<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplStreamWriter::may_block(&arg_self_.interface);
        result.into()
    }
}
impl ImplStreamWriter for StreamWriter {
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .write
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *const _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn flush(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_stream_writer_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_stream_writer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for StreamWriter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_stream_writer_t> for &StreamWriter {
    fn as_raw(self) -> *mut _cef_stream_writer_t {
        ImplStreamWriter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_stream_writer_t> for &mut StreamWriter {
    fn as_raw(self) -> *mut _cef_stream_writer_t {
        ImplStreamWriter::get_raw(self)
    }
}
impl ConvertReturnValue<StreamWriter> for *mut _cef_stream_writer_t {
    fn as_wrapper(self) -> StreamWriter {
        StreamWriter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_stream_writer_t> for StreamWriter {
    fn into(self) -> *mut _cef_stream_writer_t {
        let object = ImplStreamWriter::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for StreamWriter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_drag_data_t] for more documentation.
#[derive(Clone)]
pub struct DragData(RefGuard<_cef_drag_data_t>);
impl DragData {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDragData,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDragData>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDragData>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_drag_data_t).as_wrapper()
        }
    }
}
pub trait WrapDragData: ImplDragData {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_drag_data_t, Self>);
}
pub trait ImplDragData: Clone + Sized + Rc {
    fn clone(&self) -> Option<DragData> {
        Default::default()
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_link(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_fragment(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_file(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_link_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_link_title(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_link_metadata(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_fragment_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_fragment_html(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_fragment_base_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_file_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_file_contents(&self, writer: Option<&mut impl ImplStreamWriter>) -> usize {
        Default::default()
    }
    fn get_file_names(&self, names: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_file_paths(&self, paths: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_link_url(&self, url: Option<&CefStringUtf16>) {}
    fn set_link_title(&self, title: Option<&CefStringUtf16>) {}
    fn set_link_metadata(&self, data: Option<&CefStringUtf16>) {}
    fn set_fragment_text(&self, text: Option<&CefStringUtf16>) {}
    fn set_fragment_html(&self, html: Option<&CefStringUtf16>) {}
    fn set_fragment_base_url(&self, base_url: Option<&CefStringUtf16>) {}
    fn reset_file_contents(&self) {}
    fn add_file(&self, path: Option<&CefStringUtf16>, display_name: Option<&CefStringUtf16>) {}
    fn clear_filenames(&self) {}
    fn get_image(&self) -> Option<Image> {
        Default::default()
    }
    fn get_image_hotspot(&self) -> Point {
        Default::default()
    }
    fn has_image(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_drag_data_t) {
        impl_cef_drag_data_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_drag_data_t;
}
mod impl_cef_drag_data_t {
    use super::*;
    pub fn init_methods<I: ImplDragData>(object: &mut _cef_drag_data_t) {
        object.clone = Some(clone::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_link = Some(is_link::<I>);
        object.is_fragment = Some(is_fragment::<I>);
        object.is_file = Some(is_file::<I>);
        object.get_link_url = Some(get_link_url::<I>);
        object.get_link_title = Some(get_link_title::<I>);
        object.get_link_metadata = Some(get_link_metadata::<I>);
        object.get_fragment_text = Some(get_fragment_text::<I>);
        object.get_fragment_html = Some(get_fragment_html::<I>);
        object.get_fragment_base_url = Some(get_fragment_base_url::<I>);
        object.get_file_name = Some(get_file_name::<I>);
        object.get_file_contents = Some(get_file_contents::<I>);
        object.get_file_names = Some(get_file_names::<I>);
        object.get_file_paths = Some(get_file_paths::<I>);
        object.set_link_url = Some(set_link_url::<I>);
        object.set_link_title = Some(set_link_title::<I>);
        object.set_link_metadata = Some(set_link_metadata::<I>);
        object.set_fragment_text = Some(set_fragment_text::<I>);
        object.set_fragment_html = Some(set_fragment_html::<I>);
        object.set_fragment_base_url = Some(set_fragment_base_url::<I>);
        object.reset_file_contents = Some(reset_file_contents::<I>);
        object.add_file = Some(add_file::<I>);
        object.clear_filenames = Some(clear_filenames::<I>);
        object.get_image = Some(get_image::<I>);
        object.get_image_hotspot = Some(get_image_hotspot::<I>);
        object.has_image = Some(has_image::<I>);
    }
    extern "C" fn clone<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> *mut _cef_drag_data_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::clone(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_read_only<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_link<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::is_link(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_fragment<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::is_fragment(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_file<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::is_file(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_link_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_link_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_link_title<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_link_title(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_link_metadata<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_link_metadata(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_fragment_text<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_fragment_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_fragment_html<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_fragment_html(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_fragment_base_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_fragment_base_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_file_name<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_file_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_file_contents<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        writer: *mut _cef_stream_writer_t,
    ) -> usize {
        let (arg_self_, arg_writer) = (self_, writer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_writer = unsafe { arg_writer.as_mut() }
            .map(|arg| StreamWriter(unsafe { RefGuard::from_raw(arg) }));
        let arg_writer = arg_writer.as_mut();
        let result = ImplDragData::get_file_contents(&arg_self_.interface, arg_writer);
        result.into()
    }
    extern "C" fn get_file_names<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        names: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = if arg_names.is_null() {
            None
        } else {
            Some(arg_names.into())
        };
        let arg_names = arg_names.as_mut();
        let result = ImplDragData::get_file_names(&arg_self_.interface, arg_names);
        result.into()
    }
    extern "C" fn get_file_paths<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        paths: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_paths) = (self_, paths);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_paths = if arg_paths.is_null() {
            None
        } else {
            Some(arg_paths.into())
        };
        let arg_paths = arg_paths.as_mut();
        let result = ImplDragData::get_file_paths(&arg_self_.interface, arg_paths);
        result.into()
    }
    extern "C" fn set_link_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let result = ImplDragData::set_link_url(&arg_self_.interface, arg_url);
    }
    extern "C" fn set_link_title<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        title: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_title) = (self_, title);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_title = if arg_title.is_null() {
            None
        } else {
            Some(arg_title.into())
        };
        let arg_title = arg_title.as_ref();
        let result = ImplDragData::set_link_title(&arg_self_.interface, arg_title);
    }
    extern "C" fn set_link_metadata<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        data: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_data) = (self_, data);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_data = if arg_data.is_null() {
            None
        } else {
            Some(arg_data.into())
        };
        let arg_data = arg_data.as_ref();
        let result = ImplDragData::set_link_metadata(&arg_self_.interface, arg_data);
    }
    extern "C" fn set_fragment_text<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let result = ImplDragData::set_fragment_text(&arg_self_.interface, arg_text);
    }
    extern "C" fn set_fragment_html<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        html: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_html) = (self_, html);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_html = if arg_html.is_null() {
            None
        } else {
            Some(arg_html.into())
        };
        let arg_html = arg_html.as_ref();
        let result = ImplDragData::set_fragment_html(&arg_self_.interface, arg_html);
    }
    extern "C" fn set_fragment_base_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        base_url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_base_url) = (self_, base_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_base_url = if arg_base_url.is_null() {
            None
        } else {
            Some(arg_base_url.into())
        };
        let arg_base_url = arg_base_url.as_ref();
        let result = ImplDragData::set_fragment_base_url(&arg_self_.interface, arg_base_url);
    }
    extern "C" fn reset_file_contents<I: ImplDragData>(self_: *mut _cef_drag_data_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::reset_file_contents(&arg_self_.interface);
    }
    extern "C" fn add_file<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        path: *const _cef_string_utf16_t,
        display_name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_path, arg_display_name) = (self_, path, display_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_path = if arg_path.is_null() {
            None
        } else {
            Some(arg_path.into())
        };
        let arg_path = arg_path.as_ref();
        let arg_display_name = if arg_display_name.is_null() {
            None
        } else {
            Some(arg_display_name.into())
        };
        let arg_display_name = arg_display_name.as_ref();
        let result = ImplDragData::add_file(&arg_self_.interface, arg_path, arg_display_name);
    }
    extern "C" fn clear_filenames<I: ImplDragData>(self_: *mut _cef_drag_data_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::clear_filenames(&arg_self_.interface);
    }
    extern "C" fn get_image<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> *mut _cef_image_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_image(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_image_hotspot<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> _cef_point_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::get_image_hotspot(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_image<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDragData::has_image(&arg_self_.interface);
        result.into()
    }
}
impl ImplDragData for DragData {
    fn clone(&self) -> Option<DragData> {
        unsafe {
            self.0
                .clone
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_link(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_link
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_fragment(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fragment
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_file(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_file
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_link_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_link_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_link_title(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_link_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_link_metadata(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_link_metadata
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_fragment_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_fragment_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_fragment_html(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_fragment_html
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_fragment_base_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_fragment_base_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_file_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_file_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_file_contents(&self, writer: Option<&mut impl ImplStreamWriter>) -> usize {
        unsafe {
            self.0
                .get_file_contents
                .map(|f| {
                    let arg_writer = writer;
                    let arg_self_ = self.as_raw();
                    let arg_writer = arg_writer
                        .map(|arg| {
                            arg.add_ref();
                            ImplStreamWriter::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_writer);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_file_names(&self, names: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_file_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_file_paths(&self, paths: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_file_paths
                .map(|f| {
                    let arg_paths = paths;
                    let arg_self_ = self.as_raw();
                    let arg_paths = arg_paths
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_paths);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_link_url(&self, url: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_link_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_link_title(&self, title: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_link_title
                .map(|f| {
                    let arg_title = title;
                    let arg_self_ = self.as_raw();
                    let arg_title = arg_title
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_title);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_link_metadata(&self, data: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_link_metadata
                .map(|f| {
                    let arg_data = data;
                    let arg_self_ = self.as_raw();
                    let arg_data = arg_data.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_data);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fragment_text(&self, text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_fragment_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fragment_html(&self, html: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_fragment_html
                .map(|f| {
                    let arg_html = html;
                    let arg_self_ = self.as_raw();
                    let arg_html = arg_html.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_html);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fragment_base_url(&self, base_url: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_fragment_base_url
                .map(|f| {
                    let arg_base_url = base_url;
                    let arg_self_ = self.as_raw();
                    let arg_base_url = arg_base_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_base_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reset_file_contents(&self) {
        unsafe {
            self.0
                .reset_file_contents
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_file(&self, path: Option<&CefStringUtf16>, display_name: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .add_file
                .map(|f| {
                    let (arg_path, arg_display_name) = (path, display_name);
                    let arg_self_ = self.as_raw();
                    let arg_path = arg_path.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_display_name = arg_display_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_path, arg_display_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_filenames(&self) {
        unsafe {
            self.0
                .clear_filenames
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_image(&self) -> Option<Image> {
        unsafe {
            self.0
                .get_image
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_image_hotspot(&self) -> Point {
        unsafe {
            self.0
                .get_image_hotspot
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_image(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_image
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_drag_data_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_drag_data_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DragData {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_drag_data_t> for &DragData {
    fn as_raw(self) -> *mut _cef_drag_data_t {
        ImplDragData::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_drag_data_t> for &mut DragData {
    fn as_raw(self) -> *mut _cef_drag_data_t {
        ImplDragData::get_raw(self)
    }
}
impl ConvertReturnValue<DragData> for *mut _cef_drag_data_t {
    fn as_wrapper(self) -> DragData {
        DragData(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_drag_data_t> for DragData {
    fn into(self) -> *mut _cef_drag_data_t {
        let object = ImplDragData::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DragData {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_domvisitor_t] for more documentation.
#[derive(Clone)]
pub struct Domvisitor(RefGuard<_cef_domvisitor_t>);
impl Domvisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDomvisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDomvisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDomvisitor>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_domvisitor_t).as_wrapper()
        }
    }
}
pub trait WrapDomvisitor: ImplDomvisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_domvisitor_t, Self>);
}
pub trait ImplDomvisitor: Clone + Sized + Rc {
    fn visit(&self, document: Option<&mut impl ImplDomdocument>) {}
    fn init_methods(object: &mut _cef_domvisitor_t) {
        impl_cef_domvisitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_domvisitor_t;
}
mod impl_cef_domvisitor_t {
    use super::*;
    pub fn init_methods<I: ImplDomvisitor>(object: &mut _cef_domvisitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplDomvisitor>(
        self_: *mut _cef_domvisitor_t,
        document: *mut _cef_domdocument_t,
    ) {
        let (arg_self_, arg_document) = (self_, document);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_document = unsafe { arg_document.as_mut() }
            .map(|arg| Domdocument(unsafe { RefGuard::from_raw(arg) }));
        let arg_document = arg_document.as_mut();
        let result = ImplDomvisitor::visit(&arg_self_.interface, arg_document);
    }
}
impl ImplDomvisitor for Domvisitor {
    fn visit(&self, document: Option<&mut impl ImplDomdocument>) {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let arg_document = document;
                    let arg_self_ = self.as_raw();
                    let arg_document = arg_document
                        .map(|arg| {
                            arg.add_ref();
                            ImplDomdocument::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_document);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_domvisitor_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_domvisitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domvisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domvisitor_t> for &Domvisitor {
    fn as_raw(self) -> *mut _cef_domvisitor_t {
        ImplDomvisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_domvisitor_t> for &mut Domvisitor {
    fn as_raw(self) -> *mut _cef_domvisitor_t {
        ImplDomvisitor::get_raw(self)
    }
}
impl ConvertReturnValue<Domvisitor> for *mut _cef_domvisitor_t {
    fn as_wrapper(self) -> Domvisitor {
        Domvisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_domvisitor_t> for Domvisitor {
    fn into(self) -> *mut _cef_domvisitor_t {
        let object = ImplDomvisitor::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Domvisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_domdocument_t] for more documentation.
#[derive(Clone)]
pub struct Domdocument(RefGuard<_cef_domdocument_t>);
impl Domdocument {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDomdocument,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDomdocument>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDomdocument>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_domdocument_t).as_wrapper()
        }
    }
}
pub trait WrapDomdocument: ImplDomdocument {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_domdocument_t, Self>);
}
pub trait ImplDomdocument: Clone + Sized + Rc {
    fn get_type(&self) -> DomDocumentType {
        Default::default()
    }
    fn get_document(&self) -> Option<Domnode> {
        Default::default()
    }
    fn get_body(&self) -> Option<Domnode> {
        Default::default()
    }
    fn get_head(&self) -> Option<Domnode> {
        Default::default()
    }
    fn get_title(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_element_by_id(&self, id: Option<&CefStringUtf16>) -> Option<Domnode> {
        Default::default()
    }
    fn get_focused_node(&self) -> Option<Domnode> {
        Default::default()
    }
    fn has_selection(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_selection_start_offset(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_selection_end_offset(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_selection_as_markup(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_selection_as_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_base_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_complete_url(&self, partial_url: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_domdocument_t) {
        impl_cef_domdocument_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_domdocument_t;
}
mod impl_cef_domdocument_t {
    use super::*;
    pub fn init_methods<I: ImplDomdocument>(object: &mut _cef_domdocument_t) {
        object.get_type = Some(get_type::<I>);
        object.get_document = Some(get_document::<I>);
        object.get_body = Some(get_body::<I>);
        object.get_head = Some(get_head::<I>);
        object.get_title = Some(get_title::<I>);
        object.get_element_by_id = Some(get_element_by_id::<I>);
        object.get_focused_node = Some(get_focused_node::<I>);
        object.has_selection = Some(has_selection::<I>);
        object.get_selection_start_offset = Some(get_selection_start_offset::<I>);
        object.get_selection_end_offset = Some(get_selection_end_offset::<I>);
        object.get_selection_as_markup = Some(get_selection_as_markup::<I>);
        object.get_selection_as_text = Some(get_selection_as_text::<I>);
        object.get_base_url = Some(get_base_url::<I>);
        object.get_complete_url = Some(get_complete_url::<I>);
    }
    extern "C" fn get_type<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> cef_dom_document_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_document<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_document(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_body<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_body(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_head<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_head(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_title<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_title(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_element_by_id<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
        id: *const _cef_string_utf16_t,
    ) -> *mut _cef_domnode_t {
        let (arg_self_, arg_id) = (self_, id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_id = if arg_id.is_null() {
            None
        } else {
            Some(arg_id.into())
        };
        let arg_id = arg_id.as_ref();
        let result = ImplDomdocument::get_element_by_id(&arg_self_.interface, arg_id);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_focused_node<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_focused_node(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn has_selection<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::has_selection(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_selection_start_offset<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_selection_start_offset(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_selection_end_offset<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_selection_end_offset(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_selection_as_markup<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_selection_as_markup(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_selection_as_text<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_selection_as_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_base_url<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomdocument::get_base_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_complete_url<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
        partial_url: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_partial_url) = (self_, partial_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_partial_url = if arg_partial_url.is_null() {
            None
        } else {
            Some(arg_partial_url.into())
        };
        let arg_partial_url = arg_partial_url.as_ref();
        let result = ImplDomdocument::get_complete_url(&arg_self_.interface, arg_partial_url);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplDomdocument for Domdocument {
    fn get_type(&self) -> DomDocumentType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_document(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_document
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_body(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_body
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_head(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_head
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_title(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_element_by_id(&self, id: Option<&CefStringUtf16>) -> Option<Domnode> {
        unsafe {
            self.0
                .get_element_by_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.as_raw();
                    let arg_id = arg_id.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_id);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_focused_node(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_focused_node
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn has_selection(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_selection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_selection_start_offset(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_selection_start_offset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_selection_end_offset(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_selection_end_offset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_selection_as_markup(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_selection_as_markup
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_selection_as_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_selection_as_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_base_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_base_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_complete_url(&self, partial_url: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_complete_url
                .map(|f| {
                    let arg_partial_url = partial_url;
                    let arg_self_ = self.as_raw();
                    let arg_partial_url = arg_partial_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_partial_url);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_domdocument_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_domdocument_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domdocument {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domdocument_t> for &Domdocument {
    fn as_raw(self) -> *mut _cef_domdocument_t {
        ImplDomdocument::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_domdocument_t> for &mut Domdocument {
    fn as_raw(self) -> *mut _cef_domdocument_t {
        ImplDomdocument::get_raw(self)
    }
}
impl ConvertReturnValue<Domdocument> for *mut _cef_domdocument_t {
    fn as_wrapper(self) -> Domdocument {
        Domdocument(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_domdocument_t> for Domdocument {
    fn into(self) -> *mut _cef_domdocument_t {
        let object = ImplDomdocument::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Domdocument {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_domnode_t] for more documentation.
#[derive(Clone)]
pub struct Domnode(RefGuard<_cef_domnode_t>);
impl Domnode {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDomnode,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDomnode>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDomnode>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_domnode_t).as_wrapper()
        }
    }
}
pub trait WrapDomnode: ImplDomnode {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_domnode_t, Self>);
}
pub trait ImplDomnode: Clone + Sized + Rc {
    fn get_type(&self) -> DomNodeType {
        Default::default()
    }
    fn is_text(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_element(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_editable(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_form_control_element(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_form_control_element_type(&self) -> DomFormControlType {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplDomnode>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_value(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_value(&self, value: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_as_markup(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_document(&self) -> Option<Domdocument> {
        Default::default()
    }
    fn get_parent(&self) -> Option<Domnode> {
        Default::default()
    }
    fn get_previous_sibling(&self) -> Option<Domnode> {
        Default::default()
    }
    fn get_next_sibling(&self) -> Option<Domnode> {
        Default::default()
    }
    fn has_children(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_first_child(&self) -> Option<Domnode> {
        Default::default()
    }
    fn get_last_child(&self) -> Option<Domnode> {
        Default::default()
    }
    fn get_element_tag_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn has_element_attributes(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_element_attribute(&self, attr_name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_element_attribute(&self, attr_name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_element_attributes(&self, attr_map: Option<&mut CefStringMap>) {}
    fn set_element_attribute(
        &self,
        attr_name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_element_inner_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_element_bounds(&self) -> Rect {
        Default::default()
    }
    fn init_methods(object: &mut _cef_domnode_t) {
        impl_cef_domnode_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_domnode_t;
}
mod impl_cef_domnode_t {
    use super::*;
    pub fn init_methods<I: ImplDomnode>(object: &mut _cef_domnode_t) {
        object.get_type = Some(get_type::<I>);
        object.is_text = Some(is_text::<I>);
        object.is_element = Some(is_element::<I>);
        object.is_editable = Some(is_editable::<I>);
        object.is_form_control_element = Some(is_form_control_element::<I>);
        object.get_form_control_element_type = Some(get_form_control_element_type::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_value = Some(get_value::<I>);
        object.set_value = Some(set_value::<I>);
        object.get_as_markup = Some(get_as_markup::<I>);
        object.get_document = Some(get_document::<I>);
        object.get_parent = Some(get_parent::<I>);
        object.get_previous_sibling = Some(get_previous_sibling::<I>);
        object.get_next_sibling = Some(get_next_sibling::<I>);
        object.has_children = Some(has_children::<I>);
        object.get_first_child = Some(get_first_child::<I>);
        object.get_last_child = Some(get_last_child::<I>);
        object.get_element_tag_name = Some(get_element_tag_name::<I>);
        object.has_element_attributes = Some(has_element_attributes::<I>);
        object.has_element_attribute = Some(has_element_attribute::<I>);
        object.get_element_attribute = Some(get_element_attribute::<I>);
        object.get_element_attributes = Some(get_element_attributes::<I>);
        object.set_element_attribute = Some(set_element_attribute::<I>);
        object.get_element_inner_text = Some(get_element_inner_text::<I>);
        object.get_element_bounds = Some(get_element_bounds::<I>);
    }
    extern "C" fn get_type<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> cef_dom_node_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_text<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::is_text(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_element<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::is_element(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_editable<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::is_editable(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_form_control_element<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::is_form_control_element(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_form_control_element_type<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> cef_dom_form_control_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_form_control_element_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        that: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| Domnode(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplDomnode::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn get_name<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_value<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_value(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_value<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let result = ImplDomnode::set_value(&arg_self_.interface, arg_value);
        result.into()
    }
    extern "C" fn get_as_markup<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_as_markup(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_document<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domdocument_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_document(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_parent<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_parent(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_previous_sibling<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_previous_sibling(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_next_sibling<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_next_sibling(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn has_children<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::has_children(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_first_child<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_first_child(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_last_child<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_last_child(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_element_tag_name<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_element_tag_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn has_element_attributes<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::has_element_attributes(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_element_attribute<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_attr_name) = (self_, attr_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_attr_name = if arg_attr_name.is_null() {
            None
        } else {
            Some(arg_attr_name.into())
        };
        let arg_attr_name = arg_attr_name.as_ref();
        let result = ImplDomnode::has_element_attribute(&arg_self_.interface, arg_attr_name);
        result.into()
    }
    extern "C" fn get_element_attribute<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_attr_name) = (self_, attr_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_attr_name = if arg_attr_name.is_null() {
            None
        } else {
            Some(arg_attr_name.into())
        };
        let arg_attr_name = arg_attr_name.as_ref();
        let result = ImplDomnode::get_element_attribute(&arg_self_.interface, arg_attr_name);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_element_attributes<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_map: *mut _cef_string_map_t,
    ) {
        let (arg_self_, arg_attr_map) = (self_, attr_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_attr_map = if arg_attr_map.is_null() {
            None
        } else {
            Some(arg_attr_map.into())
        };
        let arg_attr_map = arg_attr_map.as_mut();
        let result = ImplDomnode::get_element_attributes(&arg_self_.interface, arg_attr_map);
    }
    extern "C" fn set_element_attribute<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_attr_name, arg_value) = (self_, attr_name, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_attr_name = if arg_attr_name.is_null() {
            None
        } else {
            Some(arg_attr_name.into())
        };
        let arg_attr_name = arg_attr_name.as_ref();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let result =
            ImplDomnode::set_element_attribute(&arg_self_.interface, arg_attr_name, arg_value);
        result.into()
    }
    extern "C" fn get_element_inner_text<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_element_inner_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_element_bounds<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDomnode::get_element_bounds(&arg_self_.interface);
        result.into()
    }
}
impl ImplDomnode for Domnode {
    fn get_type(&self) -> DomNodeType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_text(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_element(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_element
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_editable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_editable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_form_control_element(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_form_control_element
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_form_control_element_type(&self) -> DomFormControlType {
        unsafe {
            self.0
                .get_form_control_element_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplDomnode>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplDomnode::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_value(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_value(&self, value: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_as_markup(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_as_markup
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_document(&self) -> Option<Domdocument> {
        unsafe {
            self.0
                .get_document
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_parent(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_parent
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_previous_sibling(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_previous_sibling
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_next_sibling(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_next_sibling
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn has_children(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_children
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_first_child(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_first_child
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_last_child(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_last_child
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_element_tag_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_element_tag_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn has_element_attributes(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_element_attributes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_element_attribute(&self, attr_name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_element_attribute
                .map(|f| {
                    let arg_attr_name = attr_name;
                    let arg_self_ = self.as_raw();
                    let arg_attr_name = arg_attr_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_attr_name);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_element_attribute(&self, attr_name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_element_attribute
                .map(|f| {
                    let arg_attr_name = attr_name;
                    let arg_self_ = self.as_raw();
                    let arg_attr_name = arg_attr_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_attr_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_element_attributes(&self, attr_map: Option<&mut CefStringMap>) {
        unsafe {
            self.0
                .get_element_attributes
                .map(|f| {
                    let arg_attr_map = attr_map;
                    let arg_self_ = self.as_raw();
                    let arg_attr_map = arg_attr_map
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_attr_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_element_attribute(
        &self,
        attr_name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_element_attribute
                .map(|f| {
                    let (arg_attr_name, arg_value) = (attr_name, value);
                    let arg_self_ = self.as_raw();
                    let arg_attr_name = arg_attr_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_attr_name, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_element_inner_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_element_inner_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_element_bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_element_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_domnode_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_domnode_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domnode {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domnode_t> for &Domnode {
    fn as_raw(self) -> *mut _cef_domnode_t {
        ImplDomnode::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_domnode_t> for &mut Domnode {
    fn as_raw(self) -> *mut _cef_domnode_t {
        ImplDomnode::get_raw(self)
    }
}
impl ConvertReturnValue<Domnode> for *mut _cef_domnode_t {
    fn as_wrapper(self) -> Domnode {
        Domnode(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_domnode_t> for Domnode {
    fn into(self) -> *mut _cef_domnode_t {
        let object = ImplDomnode::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Domnode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_shared_memory_region_t] for more documentation.
#[derive(Clone)]
pub struct SharedMemoryRegion(RefGuard<_cef_shared_memory_region_t>);
impl SharedMemoryRegion {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSharedMemoryRegion,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSharedMemoryRegion>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSharedMemoryRegion>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_shared_memory_region_t).as_wrapper()
        }
    }
}
pub trait WrapSharedMemoryRegion: ImplSharedMemoryRegion {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_shared_memory_region_t, Self>);
}
pub trait ImplSharedMemoryRegion: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn size(&self) -> usize {
        Default::default()
    }
    fn memory(&self) -> *mut ::std::os::raw::c_void {
        unsafe { std::mem::zeroed() }
    }
    fn init_methods(object: &mut _cef_shared_memory_region_t) {
        impl_cef_shared_memory_region_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_shared_memory_region_t;
}
mod impl_cef_shared_memory_region_t {
    use super::*;
    pub fn init_methods<I: ImplSharedMemoryRegion>(object: &mut _cef_shared_memory_region_t) {
        object.is_valid = Some(is_valid::<I>);
        object.size = Some(size::<I>);
        object.memory = Some(memory::<I>);
    }
    extern "C" fn is_valid<I: ImplSharedMemoryRegion>(
        self_: *mut _cef_shared_memory_region_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSharedMemoryRegion::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn size<I: ImplSharedMemoryRegion>(
        self_: *mut _cef_shared_memory_region_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSharedMemoryRegion::size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn memory<I: ImplSharedMemoryRegion>(
        self_: *mut _cef_shared_memory_region_t,
    ) -> *mut ::std::os::raw::c_void {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSharedMemoryRegion::memory(&arg_self_.interface);
        result.into()
    }
}
impl ImplSharedMemoryRegion for SharedMemoryRegion {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn size(&self) -> usize {
        unsafe {
            self.0
                .size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn memory(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            self.0
                .memory
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_shared_memory_region_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_shared_memory_region_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SharedMemoryRegion {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_shared_memory_region_t> for &SharedMemoryRegion {
    fn as_raw(self) -> *mut _cef_shared_memory_region_t {
        ImplSharedMemoryRegion::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_shared_memory_region_t> for &mut SharedMemoryRegion {
    fn as_raw(self) -> *mut _cef_shared_memory_region_t {
        ImplSharedMemoryRegion::get_raw(self)
    }
}
impl ConvertReturnValue<SharedMemoryRegion> for *mut _cef_shared_memory_region_t {
    fn as_wrapper(self) -> SharedMemoryRegion {
        SharedMemoryRegion(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_shared_memory_region_t> for SharedMemoryRegion {
    fn into(self) -> *mut _cef_shared_memory_region_t {
        let object = ImplSharedMemoryRegion::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for SharedMemoryRegion {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_process_message_t] for more documentation.
#[derive(Clone)]
pub struct ProcessMessage(RefGuard<_cef_process_message_t>);
impl ProcessMessage {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapProcessMessage,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplProcessMessage>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapProcessMessage>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_process_message_t).as_wrapper()
        }
    }
}
pub trait WrapProcessMessage: ImplProcessMessage {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_process_message_t, Self>);
}
pub trait ImplProcessMessage: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn copy(&self) -> Option<ProcessMessage> {
        Default::default()
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_argument_list(&self) -> Option<ListValue> {
        Default::default()
    }
    fn get_shared_memory_region(&self) -> Option<SharedMemoryRegion> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_process_message_t) {
        impl_cef_process_message_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_process_message_t;
}
mod impl_cef_process_message_t {
    use super::*;
    pub fn init_methods<I: ImplProcessMessage>(object: &mut _cef_process_message_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.copy = Some(copy::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_argument_list = Some(get_argument_list::<I>);
        object.get_shared_memory_region = Some(get_shared_memory_region::<I>);
    }
    extern "C" fn is_valid<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplProcessMessage::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_read_only<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplProcessMessage::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn copy<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_process_message_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplProcessMessage::copy(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_name<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplProcessMessage::get_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_argument_list<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_list_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplProcessMessage::get_argument_list(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_shared_memory_region<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_shared_memory_region_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplProcessMessage::get_shared_memory_region(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplProcessMessage for ProcessMessage {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<ProcessMessage> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_argument_list(&self) -> Option<ListValue> {
        unsafe {
            self.0
                .get_argument_list
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_shared_memory_region(&self) -> Option<SharedMemoryRegion> {
        unsafe {
            self.0
                .get_shared_memory_region
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_process_message_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_process_message_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ProcessMessage {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_process_message_t> for &ProcessMessage {
    fn as_raw(self) -> *mut _cef_process_message_t {
        ImplProcessMessage::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_process_message_t> for &mut ProcessMessage {
    fn as_raw(self) -> *mut _cef_process_message_t {
        ImplProcessMessage::get_raw(self)
    }
}
impl ConvertReturnValue<ProcessMessage> for *mut _cef_process_message_t {
    fn as_wrapper(self) -> ProcessMessage {
        ProcessMessage(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_process_message_t> for ProcessMessage {
    fn into(self) -> *mut _cef_process_message_t {
        let object = ImplProcessMessage::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ProcessMessage {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_request_t] for more documentation.
#[derive(Clone)]
pub struct Request(RefGuard<_cef_request_t>);
impl Request {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRequest,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRequest>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRequest>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_request_t).as_wrapper()
        }
    }
}
pub trait WrapRequest: ImplRequest {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_request_t, Self>);
}
pub trait ImplRequest: Clone + Sized + Rc {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_url(&self, url: Option<&CefStringUtf16>) {}
    fn get_method(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_method(&self, method: Option<&CefStringUtf16>) {}
    fn set_referrer(&self, referrer_url: Option<&CefStringUtf16>, policy: ReferrerPolicy) {}
    fn get_referrer_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_referrer_policy(&self) -> ReferrerPolicy {
        Default::default()
    }
    fn get_post_data(&self) -> Option<PostData> {
        Default::default()
    }
    fn set_post_data(&self, post_data: Option<&mut impl ImplPostData>) {}
    fn get_header_map(&self, header_map: Option<&mut CefStringMultimap>) {}
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>) {}
    fn get_header_by_name(&self, name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_header_by_name(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
        overwrite: ::std::os::raw::c_int,
    ) {
    }
    fn set(
        &self,
        url: Option<&CefStringUtf16>,
        method: Option<&CefStringUtf16>,
        post_data: Option<&mut impl ImplPostData>,
        header_map: Option<&mut CefStringMultimap>,
    ) {
    }
    fn get_flags(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_flags(&self, flags: ::std::os::raw::c_int) {}
    fn get_first_party_for_cookies(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_first_party_for_cookies(&self, url: Option<&CefStringUtf16>) {}
    fn get_resource_type(&self) -> ResourceType {
        Default::default()
    }
    fn get_transition_type(&self) -> TransitionType {
        Default::default()
    }
    fn get_identifier(&self) -> u64 {
        Default::default()
    }
    fn init_methods(object: &mut _cef_request_t) {
        impl_cef_request_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_request_t;
}
mod impl_cef_request_t {
    use super::*;
    pub fn init_methods<I: ImplRequest>(object: &mut _cef_request_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.get_url = Some(get_url::<I>);
        object.set_url = Some(set_url::<I>);
        object.get_method = Some(get_method::<I>);
        object.set_method = Some(set_method::<I>);
        object.set_referrer = Some(set_referrer::<I>);
        object.get_referrer_url = Some(get_referrer_url::<I>);
        object.get_referrer_policy = Some(get_referrer_policy::<I>);
        object.get_post_data = Some(get_post_data::<I>);
        object.set_post_data = Some(set_post_data::<I>);
        object.get_header_map = Some(get_header_map::<I>);
        object.set_header_map = Some(set_header_map::<I>);
        object.get_header_by_name = Some(get_header_by_name::<I>);
        object.set_header_by_name = Some(set_header_by_name::<I>);
        object.set = Some(set::<I>);
        object.get_flags = Some(get_flags::<I>);
        object.set_flags = Some(set_flags::<I>);
        object.get_first_party_for_cookies = Some(get_first_party_for_cookies::<I>);
        object.set_first_party_for_cookies = Some(set_first_party_for_cookies::<I>);
        object.get_resource_type = Some(get_resource_type::<I>);
        object.get_transition_type = Some(get_transition_type::<I>);
        object.get_identifier = Some(get_identifier::<I>);
    }
    extern "C" fn is_read_only<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_url<I: ImplRequest>(self_: *mut _cef_request_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_url<I: ImplRequest>(
        self_: *mut _cef_request_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let result = ImplRequest::set_url(&arg_self_.interface, arg_url);
    }
    extern "C" fn get_method<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_method(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_method<I: ImplRequest>(
        self_: *mut _cef_request_t,
        method: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_method) = (self_, method);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_method = if arg_method.is_null() {
            None
        } else {
            Some(arg_method.into())
        };
        let arg_method = arg_method.as_ref();
        let result = ImplRequest::set_method(&arg_self_.interface, arg_method);
    }
    extern "C" fn set_referrer<I: ImplRequest>(
        self_: *mut _cef_request_t,
        referrer_url: *const _cef_string_utf16_t,
        policy: cef_referrer_policy_t,
    ) {
        let (arg_self_, arg_referrer_url, arg_policy) = (self_, referrer_url, policy);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_referrer_url = if arg_referrer_url.is_null() {
            None
        } else {
            Some(arg_referrer_url.into())
        };
        let arg_referrer_url = arg_referrer_url.as_ref();
        let arg_policy = arg_policy.as_raw();
        let result = ImplRequest::set_referrer(&arg_self_.interface, arg_referrer_url, arg_policy);
    }
    extern "C" fn get_referrer_url<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_referrer_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_referrer_policy<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> cef_referrer_policy_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_referrer_policy(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_post_data<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_post_data_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_post_data(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_post_data<I: ImplRequest>(
        self_: *mut _cef_request_t,
        post_data: *mut _cef_post_data_t,
    ) {
        let (arg_self_, arg_post_data) = (self_, post_data);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_post_data = unsafe { arg_post_data.as_mut() }
            .map(|arg| PostData(unsafe { RefGuard::from_raw(arg) }));
        let arg_post_data = arg_post_data.as_mut();
        let result = ImplRequest::set_post_data(&arg_self_.interface, arg_post_data);
    }
    extern "C" fn get_header_map<I: ImplRequest>(
        self_: *mut _cef_request_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = if arg_header_map.is_null() {
            None
        } else {
            Some(arg_header_map.into())
        };
        let arg_header_map = arg_header_map.as_mut();
        let result = ImplRequest::get_header_map(&arg_self_.interface, arg_header_map);
    }
    extern "C" fn set_header_map<I: ImplRequest>(
        self_: *mut _cef_request_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = if arg_header_map.is_null() {
            None
        } else {
            Some(arg_header_map.into())
        };
        let arg_header_map = arg_header_map.as_mut();
        let result = ImplRequest::set_header_map(&arg_self_.interface, arg_header_map);
    }
    extern "C" fn get_header_by_name<I: ImplRequest>(
        self_: *mut _cef_request_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplRequest::get_header_by_name(&arg_self_.interface, arg_name);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_header_by_name<I: ImplRequest>(
        self_: *mut _cef_request_t,
        name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
        overwrite: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_name, arg_value, arg_overwrite) = (self_, name, value, overwrite);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let arg_overwrite = arg_overwrite.as_raw();
        let result = ImplRequest::set_header_by_name(
            &arg_self_.interface,
            arg_name,
            arg_value,
            arg_overwrite,
        );
    }
    extern "C" fn set<I: ImplRequest>(
        self_: *mut _cef_request_t,
        url: *const _cef_string_utf16_t,
        method: *const _cef_string_utf16_t,
        post_data: *mut _cef_post_data_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_url, arg_method, arg_post_data, arg_header_map) =
            (self_, url, method, post_data, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let arg_method = if arg_method.is_null() {
            None
        } else {
            Some(arg_method.into())
        };
        let arg_method = arg_method.as_ref();
        let mut arg_post_data = unsafe { arg_post_data.as_mut() }
            .map(|arg| PostData(unsafe { RefGuard::from_raw(arg) }));
        let arg_post_data = arg_post_data.as_mut();
        let mut arg_header_map = if arg_header_map.is_null() {
            None
        } else {
            Some(arg_header_map.into())
        };
        let arg_header_map = arg_header_map.as_mut();
        let result = ImplRequest::set(
            &arg_self_.interface,
            arg_url,
            arg_method,
            arg_post_data,
            arg_header_map,
        );
    }
    extern "C" fn get_flags<I: ImplRequest>(self_: *mut _cef_request_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_flags(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_flags<I: ImplRequest>(
        self_: *mut _cef_request_t,
        flags: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_flags) = (self_, flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_flags = arg_flags.as_raw();
        let result = ImplRequest::set_flags(&arg_self_.interface, arg_flags);
    }
    extern "C" fn get_first_party_for_cookies<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_first_party_for_cookies(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_first_party_for_cookies<I: ImplRequest>(
        self_: *mut _cef_request_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let result = ImplRequest::set_first_party_for_cookies(&arg_self_.interface, arg_url);
    }
    extern "C" fn get_resource_type<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> cef_resource_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_resource_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_transition_type<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> cef_transition_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_transition_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_identifier<I: ImplRequest>(self_: *mut _cef_request_t) -> u64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequest::get_identifier(&arg_self_.interface);
        result.into()
    }
}
impl ImplRequest for Request {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_url(&self, url: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_method(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_method
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_method(&self, method: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_method
                .map(|f| {
                    let arg_method = method;
                    let arg_self_ = self.as_raw();
                    let arg_method = arg_method
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_method);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_referrer(&self, referrer_url: Option<&CefStringUtf16>, policy: ReferrerPolicy) {
        unsafe {
            self.0
                .set_referrer
                .map(|f| {
                    let (arg_referrer_url, arg_policy) = (referrer_url, policy);
                    let arg_self_ = self.as_raw();
                    let arg_referrer_url = arg_referrer_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_policy = arg_policy.as_raw();
                    let result = f(arg_self_, arg_referrer_url, arg_policy);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_referrer_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_referrer_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_referrer_policy(&self) -> ReferrerPolicy {
        unsafe {
            self.0
                .get_referrer_policy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_post_data(&self) -> Option<PostData> {
        unsafe {
            self.0
                .get_post_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_post_data(&self, post_data: Option<&mut impl ImplPostData>) {
        unsafe {
            self.0
                .set_post_data
                .map(|f| {
                    let arg_post_data = post_data;
                    let arg_self_ = self.as_raw();
                    let arg_post_data = arg_post_data
                        .map(|arg| {
                            arg.add_ref();
                            ImplPostData::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_post_data);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            self.0
                .get_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            self.0
                .set_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_by_name(&self, name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_header_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_header_by_name(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_header_by_name
                .map(|f| {
                    let (arg_name, arg_value, arg_overwrite) = (name, value, overwrite);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_overwrite = arg_overwrite;
                    let result = f(arg_self_, arg_name, arg_value, arg_overwrite);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set(
        &self,
        url: Option<&CefStringUtf16>,
        method: Option<&CefStringUtf16>,
        post_data: Option<&mut impl ImplPostData>,
        header_map: Option<&mut CefStringMultimap>,
    ) {
        unsafe {
            self.0
                .set
                .map(|f| {
                    let (arg_url, arg_method, arg_post_data, arg_header_map) =
                        (url, method, post_data, header_map);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_method = arg_method
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_post_data = arg_post_data
                        .map(|arg| {
                            arg.add_ref();
                            ImplPostData::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_header_map = arg_header_map
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_url,
                        arg_method,
                        arg_post_data,
                        arg_header_map,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_flags(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_flags(&self, flags: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_flags
                .map(|f| {
                    let arg_flags = flags;
                    let arg_self_ = self.as_raw();
                    let arg_flags = arg_flags;
                    let result = f(arg_self_, arg_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_first_party_for_cookies(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_first_party_for_cookies
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_first_party_for_cookies(&self, url: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_first_party_for_cookies
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_type(&self) -> ResourceType {
        unsafe {
            self.0
                .get_resource_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_transition_type(&self) -> TransitionType {
        unsafe {
            self.0
                .get_transition_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_identifier(&self) -> u64 {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_request_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_request_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Request {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_t> for &Request {
    fn as_raw(self) -> *mut _cef_request_t {
        ImplRequest::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_t> for &mut Request {
    fn as_raw(self) -> *mut _cef_request_t {
        ImplRequest::get_raw(self)
    }
}
impl ConvertReturnValue<Request> for *mut _cef_request_t {
    fn as_wrapper(self) -> Request {
        Request(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_t> for Request {
    fn into(self) -> *mut _cef_request_t {
        let object = ImplRequest::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Request {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_post_data_t] for more documentation.
#[derive(Clone)]
pub struct PostData(RefGuard<_cef_post_data_t>);
impl PostData {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPostData,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPostData>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPostData>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_post_data_t).as_wrapper()
        }
    }
}
pub trait WrapPostData: ImplPostData {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_post_data_t, Self>);
}
pub trait ImplPostData: Clone + Sized + Rc {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_excluded_elements(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_element_count(&self) -> usize {
        Default::default()
    }
    fn get_elements(&self, elements: Option<&mut Vec<Option<PostDataElement>>>) {}
    fn remove_element(
        &self,
        element: Option<&mut impl ImplPostDataElement>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_element(&self, element: Option<&mut impl ImplPostDataElement>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn remove_elements(&self) {}
    fn init_methods(object: &mut _cef_post_data_t) {
        impl_cef_post_data_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_post_data_t;
}
mod impl_cef_post_data_t {
    use super::*;
    pub fn init_methods<I: ImplPostData>(object: &mut _cef_post_data_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.has_excluded_elements = Some(has_excluded_elements::<I>);
        object.get_element_count = Some(get_element_count::<I>);
        object.get_elements = Some(get_elements::<I>);
        object.remove_element = Some(remove_element::<I>);
        object.add_element = Some(add_element::<I>);
        object.remove_elements = Some(remove_elements::<I>);
    }
    extern "C" fn is_read_only<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostData::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_excluded_elements<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostData::has_excluded_elements(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_element_count<I: ImplPostData>(self_: *mut _cef_post_data_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostData::get_element_count(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_elements<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
        elements_count: *mut usize,
        elements: *mut *mut _cef_post_data_element_t,
    ) {
        let (arg_self_, arg_elements_count, arg_elements) = (self_, elements_count, elements);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let out_elements_count = unsafe { arg_elements_count.as_mut() };
        let out_elements = unsafe { arg_elements.as_mut() };
        let arg_elements_count = out_elements_count
            .as_ref()
            .map(|count| **count)
            .unwrap_or_default();
        let mut vec_elements = unsafe { arg_elements.as_mut() }.map(|arg| {
            let arg = unsafe {
                std::slice::from_raw_parts_mut(std::ptr::from_mut(arg), arg_elements_count)
            };
            arg.iter_mut()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(PostDataElement(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_elements = vec_elements.as_mut();
        let result = ImplPostData::get_elements(&arg_self_.interface, arg_elements);
        if let (Some(out_elements_count), Some(vec_elements)) =
            (out_elements_count, vec_elements.as_mut())
        {
            let size = vec_elements.len().min(*out_elements_count);
            for elem in &mut vec_elements[..size] {
                if let Some(elem) = elem.as_ref() {
                    unsafe { elem.add_ref() };
                }
            }
            *out_elements_count = size;
        }
    }
    extern "C" fn remove_element<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
        element: *mut _cef_post_data_element_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_element) = (self_, element);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_element = unsafe { arg_element.as_mut() }
            .map(|arg| PostDataElement(unsafe { RefGuard::from_raw(arg) }));
        let arg_element = arg_element.as_mut();
        let result = ImplPostData::remove_element(&arg_self_.interface, arg_element);
        result.into()
    }
    extern "C" fn add_element<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
        element: *mut _cef_post_data_element_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_element) = (self_, element);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_element = unsafe { arg_element.as_mut() }
            .map(|arg| PostDataElement(unsafe { RefGuard::from_raw(arg) }));
        let arg_element = arg_element.as_mut();
        let result = ImplPostData::add_element(&arg_self_.interface, arg_element);
        result.into()
    }
    extern "C" fn remove_elements<I: ImplPostData>(self_: *mut _cef_post_data_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostData::remove_elements(&arg_self_.interface);
    }
}
impl ImplPostData for PostData {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_excluded_elements(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_excluded_elements
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_element_count(&self) -> usize {
        unsafe {
            self.0
                .get_element_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_elements(&self, elements: Option<&mut Vec<Option<PostDataElement>>>) {
        unsafe {
            self.0
                .get_elements
                .map(|f| {
                    let arg_elements = elements;
                    let arg_self_ = self.as_raw();
                    let mut out_elements_count = arg_elements
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_elements_count = &mut out_elements_count;
                    let out_elements = arg_elements;
                    let mut vec_elements = out_elements
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_elements = if vec_elements.is_empty() {
                        std::ptr::null_mut()
                    } else {
                        vec_elements.as_mut_ptr()
                    };
                    let result = f(arg_self_, arg_elements_count, arg_elements);
                    if let Some(out_elements) = out_elements {
                        *out_elements = vec_elements
                            .into_iter()
                            .take(out_elements_count)
                            .map(|elem| {
                                if elem.is_null() {
                                    None
                                } else {
                                    Some(elem.as_wrapper())
                                }
                            })
                            .collect();
                    }
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_element(
        &self,
        element: Option<&mut impl ImplPostDataElement>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_element
                .map(|f| {
                    let arg_element = element;
                    let arg_self_ = self.as_raw();
                    let arg_element = arg_element
                        .map(|arg| {
                            arg.add_ref();
                            ImplPostDataElement::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_element);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_element(&self, element: Option<&mut impl ImplPostDataElement>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_element
                .map(|f| {
                    let arg_element = element;
                    let arg_self_ = self.as_raw();
                    let arg_element = arg_element
                        .map(|arg| {
                            arg.add_ref();
                            ImplPostDataElement::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_element);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn remove_elements(&self) {
        unsafe {
            self.0
                .remove_elements
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_post_data_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_post_data_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PostData {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_post_data_t> for &PostData {
    fn as_raw(self) -> *mut _cef_post_data_t {
        ImplPostData::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_post_data_t> for &mut PostData {
    fn as_raw(self) -> *mut _cef_post_data_t {
        ImplPostData::get_raw(self)
    }
}
impl ConvertReturnValue<PostData> for *mut _cef_post_data_t {
    fn as_wrapper(self) -> PostData {
        PostData(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_post_data_t> for PostData {
    fn into(self) -> *mut _cef_post_data_t {
        let object = ImplPostData::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PostData {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_post_data_element_t] for more documentation.
#[derive(Clone)]
pub struct PostDataElement(RefGuard<_cef_post_data_element_t>);
impl PostDataElement {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPostDataElement,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPostDataElement>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPostDataElement>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_post_data_element_t).as_wrapper()
        }
    }
}
pub trait WrapPostDataElement: ImplPostDataElement {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_post_data_element_t, Self>);
}
pub trait ImplPostDataElement: Clone + Sized + Rc {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_to_empty(&self) {}
    fn set_to_file(&self, file_name: Option<&CefStringUtf16>) {}
    fn set_to_bytes(&self, size: usize, bytes: *const u8) {}
    fn get_type(&self) -> PostdataelementType {
        Default::default()
    }
    fn get_file(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_bytes_count(&self) -> usize {
        Default::default()
    }
    fn get_bytes(&self, size: usize, bytes: *mut u8) -> usize {
        Default::default()
    }
    fn init_methods(object: &mut _cef_post_data_element_t) {
        impl_cef_post_data_element_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_post_data_element_t;
}
mod impl_cef_post_data_element_t {
    use super::*;
    pub fn init_methods<I: ImplPostDataElement>(object: &mut _cef_post_data_element_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.set_to_empty = Some(set_to_empty::<I>);
        object.set_to_file = Some(set_to_file::<I>);
        object.set_to_bytes = Some(set_to_bytes::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_file = Some(get_file::<I>);
        object.get_bytes_count = Some(get_bytes_count::<I>);
        object.get_bytes = Some(get_bytes::<I>);
    }
    extern "C" fn is_read_only<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostDataElement::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_to_empty<I: ImplPostDataElement>(self_: *mut _cef_post_data_element_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostDataElement::set_to_empty(&arg_self_.interface);
    }
    extern "C" fn set_to_file<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
        file_name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_file_name) = (self_, file_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_file_name = if arg_file_name.is_null() {
            None
        } else {
            Some(arg_file_name.into())
        };
        let arg_file_name = arg_file_name.as_ref();
        let result = ImplPostDataElement::set_to_file(&arg_self_.interface, arg_file_name);
    }
    extern "C" fn set_to_bytes<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
        size: usize,
        bytes: *const ::std::os::raw::c_void,
    ) {
        let (arg_self_, arg_size, arg_bytes) = (self_, size, bytes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        let arg_bytes = arg_bytes as *const _;
        let result = ImplPostDataElement::set_to_bytes(&arg_self_.interface, arg_size, arg_bytes);
    }
    extern "C" fn get_type<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> cef_postdataelement_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostDataElement::get_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_file<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostDataElement::get_file(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_bytes_count<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPostDataElement::get_bytes_count(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_bytes<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
        size: usize,
        bytes: *mut ::std::os::raw::c_void,
    ) -> usize {
        let (arg_self_, arg_size, arg_bytes) = (self_, size, bytes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        let arg_bytes = arg_bytes as *mut _;
        let result = ImplPostDataElement::get_bytes(&arg_self_.interface, arg_size, arg_bytes);
        result.into()
    }
}
impl ImplPostDataElement for PostDataElement {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_to_empty(&self) {
        unsafe {
            self.0
                .set_to_empty
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_to_file(&self, file_name: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_to_file
                .map(|f| {
                    let arg_file_name = file_name;
                    let arg_self_ = self.as_raw();
                    let arg_file_name = arg_file_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_file_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_to_bytes(&self, size: usize, bytes: *const u8) {
        unsafe {
            self.0
                .set_to_bytes
                .map(|f| {
                    let (arg_size, arg_bytes) = (size, bytes);
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size;
                    let arg_bytes = arg_bytes as *const _;
                    let result = f(arg_self_, arg_size, arg_bytes);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type(&self) -> PostdataelementType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_file(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_file
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_bytes_count(&self) -> usize {
        unsafe {
            self.0
                .get_bytes_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_bytes(&self, size: usize, bytes: *mut u8) -> usize {
        unsafe {
            self.0
                .get_bytes
                .map(|f| {
                    let (arg_size, arg_bytes) = (size, bytes);
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size;
                    let arg_bytes = arg_bytes as *mut _;
                    let result = f(arg_self_, arg_size, arg_bytes);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_post_data_element_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_post_data_element_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PostDataElement {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_post_data_element_t> for &PostDataElement {
    fn as_raw(self) -> *mut _cef_post_data_element_t {
        ImplPostDataElement::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_post_data_element_t> for &mut PostDataElement {
    fn as_raw(self) -> *mut _cef_post_data_element_t {
        ImplPostDataElement::get_raw(self)
    }
}
impl ConvertReturnValue<PostDataElement> for *mut _cef_post_data_element_t {
    fn as_wrapper(self) -> PostDataElement {
        PostDataElement(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_post_data_element_t> for PostDataElement {
    fn into(self) -> *mut _cef_post_data_element_t {
        let object = ImplPostDataElement::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PostDataElement {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_string_visitor_t] for more documentation.
#[derive(Clone)]
pub struct CefStringVisitor(RefGuard<_cef_string_visitor_t>);
impl CefStringVisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCefStringVisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCefStringVisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCefStringVisitor>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_string_visitor_t).as_wrapper()
        }
    }
}
pub trait WrapCefStringVisitor: ImplCefStringVisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_string_visitor_t, Self>);
}
pub trait ImplCefStringVisitor: Clone + Sized + Rc {
    fn visit(&self, string: Option<&CefStringUtf16>) {}
    fn init_methods(object: &mut _cef_string_visitor_t) {
        impl_cef_string_visitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_string_visitor_t;
}
mod impl_cef_string_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplCefStringVisitor>(object: &mut _cef_string_visitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplCefStringVisitor>(
        self_: *mut _cef_string_visitor_t,
        string: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_string) = (self_, string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_string = if arg_string.is_null() {
            None
        } else {
            Some(arg_string.into())
        };
        let arg_string = arg_string.as_ref();
        let result = ImplCefStringVisitor::visit(&arg_self_.interface, arg_string);
    }
}
impl ImplCefStringVisitor for CefStringVisitor {
    fn visit(&self, string: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let arg_string = string;
                    let arg_self_ = self.as_raw();
                    let arg_string = arg_string
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_string);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_string_visitor_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_string_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CefStringVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_string_visitor_t> for &CefStringVisitor {
    fn as_raw(self) -> *mut _cef_string_visitor_t {
        ImplCefStringVisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_string_visitor_t> for &mut CefStringVisitor {
    fn as_raw(self) -> *mut _cef_string_visitor_t {
        ImplCefStringVisitor::get_raw(self)
    }
}
impl ConvertReturnValue<CefStringVisitor> for *mut _cef_string_visitor_t {
    fn as_wrapper(self) -> CefStringVisitor {
        CefStringVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_string_visitor_t> for CefStringVisitor {
    fn into(self) -> *mut _cef_string_visitor_t {
        let object = ImplCefStringVisitor::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for CefStringVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_frame_t] for more documentation.
#[derive(Clone)]
pub struct Frame(RefGuard<_cef_frame_t>);
impl Frame {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFrame,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFrame>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFrame>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_frame_t).as_wrapper()
        }
    }
}
pub trait WrapFrame: ImplFrame {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_frame_t, Self>);
}
pub trait ImplFrame: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn undo(&self) {}
    fn redo(&self) {}
    fn cut(&self) {}
    fn copy(&self) {}
    fn paste(&self) {}
    fn paste_and_match_style(&self) {}
    fn del(&self) {}
    fn select_all(&self) {}
    fn view_source(&self) {}
    fn get_source(&self, visitor: Option<&mut impl ImplCefStringVisitor>) {}
    fn get_text(&self, visitor: Option<&mut impl ImplCefStringVisitor>) {}
    fn load_request(&self, request: Option<&mut impl ImplRequest>) {}
    fn load_url(&self, url: Option<&CefStringUtf16>) {}
    fn execute_java_script(
        &self,
        code: Option<&CefStringUtf16>,
        script_url: Option<&CefStringUtf16>,
        start_line: ::std::os::raw::c_int,
    ) {
    }
    fn is_main(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_focused(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_identifier(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_parent(&self) -> Option<Frame> {
        Default::default()
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_browser(&self) -> Option<Browser> {
        Default::default()
    }
    fn get_v8context(&self) -> Option<V8context> {
        Default::default()
    }
    fn visit_dom(&self, visitor: Option<&mut impl ImplDomvisitor>) {}
    fn create_urlrequest(
        &self,
        request: Option<&mut impl ImplRequest>,
        client: Option<&mut impl ImplUrlrequestClient>,
    ) -> Option<Urlrequest> {
        Default::default()
    }
    fn send_process_message(
        &self,
        target_process: ProcessId,
        message: Option<&mut impl ImplProcessMessage>,
    ) {
    }
    fn init_methods(object: &mut _cef_frame_t) {
        impl_cef_frame_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_frame_t;
}
mod impl_cef_frame_t {
    use super::*;
    pub fn init_methods<I: ImplFrame>(object: &mut _cef_frame_t) {
        object.is_valid = Some(is_valid::<I>);
        object.undo = Some(undo::<I>);
        object.redo = Some(redo::<I>);
        object.cut = Some(cut::<I>);
        object.copy = Some(copy::<I>);
        object.paste = Some(paste::<I>);
        object.paste_and_match_style = Some(paste_and_match_style::<I>);
        object.del = Some(del::<I>);
        object.select_all = Some(select_all::<I>);
        object.view_source = Some(view_source::<I>);
        object.get_source = Some(get_source::<I>);
        object.get_text = Some(get_text::<I>);
        object.load_request = Some(load_request::<I>);
        object.load_url = Some(load_url::<I>);
        object.execute_java_script = Some(execute_java_script::<I>);
        object.is_main = Some(is_main::<I>);
        object.is_focused = Some(is_focused::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_identifier = Some(get_identifier::<I>);
        object.get_parent = Some(get_parent::<I>);
        object.get_url = Some(get_url::<I>);
        object.get_browser = Some(get_browser::<I>);
        object.get_v8context = Some(get_v8context::<I>);
        object.visit_dom = Some(visit_dom::<I>);
        object.create_urlrequest = Some(create_urlrequest::<I>);
        object.send_process_message = Some(send_process_message::<I>);
    }
    extern "C" fn is_valid<I: ImplFrame>(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn undo<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::undo(&arg_self_.interface);
    }
    extern "C" fn redo<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::redo(&arg_self_.interface);
    }
    extern "C" fn cut<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::cut(&arg_self_.interface);
    }
    extern "C" fn copy<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::copy(&arg_self_.interface);
    }
    extern "C" fn paste<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::paste(&arg_self_.interface);
    }
    extern "C" fn paste_and_match_style<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::paste_and_match_style(&arg_self_.interface);
    }
    extern "C" fn del<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::del(&arg_self_.interface);
    }
    extern "C" fn select_all<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::select_all(&arg_self_.interface);
    }
    extern "C" fn view_source<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::view_source(&arg_self_.interface);
    }
    extern "C" fn get_source<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        visitor: *mut _cef_string_visitor_t,
    ) {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_visitor = unsafe { arg_visitor.as_mut() }
            .map(|arg| CefStringVisitor(unsafe { RefGuard::from_raw(arg) }));
        let arg_visitor = arg_visitor.as_mut();
        let result = ImplFrame::get_source(&arg_self_.interface, arg_visitor);
    }
    extern "C" fn get_text<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        visitor: *mut _cef_string_visitor_t,
    ) {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_visitor = unsafe { arg_visitor.as_mut() }
            .map(|arg| CefStringVisitor(unsafe { RefGuard::from_raw(arg) }));
        let arg_visitor = arg_visitor.as_mut();
        let result = ImplFrame::get_text(&arg_self_.interface, arg_visitor);
    }
    extern "C" fn load_request<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) {
        let (arg_self_, arg_request) = (self_, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplFrame::load_request(&arg_self_.interface, arg_request);
    }
    extern "C" fn load_url<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let result = ImplFrame::load_url(&arg_self_.interface, arg_url);
    }
    extern "C" fn execute_java_script<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        code: *const _cef_string_utf16_t,
        script_url: *const _cef_string_utf16_t,
        start_line: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_code, arg_script_url, arg_start_line) =
            (self_, code, script_url, start_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_code = if arg_code.is_null() {
            None
        } else {
            Some(arg_code.into())
        };
        let arg_code = arg_code.as_ref();
        let arg_script_url = if arg_script_url.is_null() {
            None
        } else {
            Some(arg_script_url.into())
        };
        let arg_script_url = arg_script_url.as_ref();
        let arg_start_line = arg_start_line.as_raw();
        let result = ImplFrame::execute_java_script(
            &arg_self_.interface,
            arg_code,
            arg_script_url,
            arg_start_line,
        );
    }
    extern "C" fn is_main<I: ImplFrame>(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::is_main(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_focused<I: ImplFrame>(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::is_focused(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_name<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::get_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_identifier<I: ImplFrame>(
        self_: *mut _cef_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::get_identifier(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_parent<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::get_parent(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_url<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::get_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_browser<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::get_browser(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_v8context<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_v8context_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFrame::get_v8context(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn visit_dom<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        visitor: *mut _cef_domvisitor_t,
    ) {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_visitor = unsafe { arg_visitor.as_mut() }
            .map(|arg| Domvisitor(unsafe { RefGuard::from_raw(arg) }));
        let arg_visitor = arg_visitor.as_mut();
        let result = ImplFrame::visit_dom(&arg_self_.interface, arg_visitor);
    }
    extern "C" fn create_urlrequest<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        client: *mut _cef_urlrequest_client_t,
    ) -> *mut _cef_urlrequest_t {
        let (arg_self_, arg_request, arg_client) = (self_, request, client);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_client = unsafe { arg_client.as_mut() }
            .map(|arg| UrlrequestClient(unsafe { RefGuard::from_raw(arg) }));
        let arg_client = arg_client.as_mut();
        let result = ImplFrame::create_urlrequest(&arg_self_.interface, arg_request, arg_client);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn send_process_message<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        target_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) {
        let (arg_self_, arg_target_process, arg_message) = (self_, target_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_target_process = arg_target_process.as_raw();
        let mut arg_message = unsafe { arg_message.as_mut() }
            .map(|arg| ProcessMessage(unsafe { RefGuard::from_raw(arg) }));
        let arg_message = arg_message.as_mut();
        let result =
            ImplFrame::send_process_message(&arg_self_.interface, arg_target_process, arg_message);
    }
}
impl ImplFrame for Frame {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn undo(&self) {
        unsafe {
            self.0
                .undo
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn redo(&self) {
        unsafe {
            self.0
                .redo
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cut(&self) {
        unsafe {
            self.0
                .cut
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy(&self) {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn paste(&self) {
        unsafe {
            self.0
                .paste
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn paste_and_match_style(&self) {
        unsafe {
            self.0
                .paste_and_match_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn del(&self) {
        unsafe {
            self.0
                .del
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn select_all(&self) {
        unsafe {
            self.0
                .select_all
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn view_source(&self) {
        unsafe {
            self.0
                .view_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_source(&self, visitor: Option<&mut impl ImplCefStringVisitor>) {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplCefStringVisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_text(&self, visitor: Option<&mut impl ImplCefStringVisitor>) {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplCefStringVisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn load_request(&self, request: Option<&mut impl ImplRequest>) {
        unsafe {
            self.0
                .load_request
                .map(|f| {
                    let arg_request = request;
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn load_url(&self, url: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .load_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn execute_java_script(
        &self,
        code: Option<&CefStringUtf16>,
        script_url: Option<&CefStringUtf16>,
        start_line: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .execute_java_script
                .map(|f| {
                    let (arg_code, arg_script_url, arg_start_line) = (code, script_url, start_line);
                    let arg_self_ = self.as_raw();
                    let arg_code = arg_code.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_script_url = arg_script_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_start_line = arg_start_line;
                    let result = f(arg_self_, arg_code, arg_script_url, arg_start_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_main(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_main
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_focused(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_focused
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_identifier(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_parent(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_parent
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_v8context(&self) -> Option<V8context> {
        unsafe {
            self.0
                .get_v8context
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn visit_dom(&self, visitor: Option<&mut impl ImplDomvisitor>) {
        unsafe {
            self.0
                .visit_dom
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplDomvisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn create_urlrequest(
        &self,
        request: Option<&mut impl ImplRequest>,
        client: Option<&mut impl ImplUrlrequestClient>,
    ) -> Option<Urlrequest> {
        unsafe {
            self.0
                .create_urlrequest
                .map(|f| {
                    let (arg_request, arg_client) = (request, client);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_client = arg_client
                        .map(|arg| {
                            arg.add_ref();
                            ImplUrlrequestClient::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request, arg_client);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn send_process_message(
        &self,
        target_process: ProcessId,
        message: Option<&mut impl ImplProcessMessage>,
    ) {
        unsafe {
            self.0
                .send_process_message
                .map(|f| {
                    let (arg_target_process, arg_message) = (target_process, message);
                    let arg_self_ = self.as_raw();
                    let arg_target_process = arg_target_process.as_raw();
                    let arg_message = arg_message
                        .map(|arg| {
                            arg.add_ref();
                            ImplProcessMessage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_target_process, arg_message);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_frame_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_frame_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Frame {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_frame_t> for &Frame {
    fn as_raw(self) -> *mut _cef_frame_t {
        ImplFrame::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_frame_t> for &mut Frame {
    fn as_raw(self) -> *mut _cef_frame_t {
        ImplFrame::get_raw(self)
    }
}
impl ConvertReturnValue<Frame> for *mut _cef_frame_t {
    fn as_wrapper(self) -> Frame {
        Frame(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_frame_t> for Frame {
    fn into(self) -> *mut _cef_frame_t {
        let object = ImplFrame::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Frame {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_x509cert_principal_t] for more documentation.
#[derive(Clone)]
pub struct X509certPrincipal(RefGuard<_cef_x509cert_principal_t>);
impl X509certPrincipal {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapX509certPrincipal,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplX509certPrincipal>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapX509certPrincipal>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_x509cert_principal_t).as_wrapper()
        }
    }
}
pub trait WrapX509certPrincipal: ImplX509certPrincipal {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_x509cert_principal_t, Self>);
}
pub trait ImplX509certPrincipal: Clone + Sized + Rc {
    fn get_display_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_common_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_locality_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_state_or_province_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_country_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_organization_names(&self, names: Option<&mut CefStringList>) {}
    fn get_organization_unit_names(&self, names: Option<&mut CefStringList>) {}
    fn init_methods(object: &mut _cef_x509cert_principal_t) {
        impl_cef_x509cert_principal_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_x509cert_principal_t;
}
mod impl_cef_x509cert_principal_t {
    use super::*;
    pub fn init_methods<I: ImplX509certPrincipal>(object: &mut _cef_x509cert_principal_t) {
        object.get_display_name = Some(get_display_name::<I>);
        object.get_common_name = Some(get_common_name::<I>);
        object.get_locality_name = Some(get_locality_name::<I>);
        object.get_state_or_province_name = Some(get_state_or_province_name::<I>);
        object.get_country_name = Some(get_country_name::<I>);
        object.get_organization_names = Some(get_organization_names::<I>);
        object.get_organization_unit_names = Some(get_organization_unit_names::<I>);
    }
    extern "C" fn get_display_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certPrincipal::get_display_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_common_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certPrincipal::get_common_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_locality_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certPrincipal::get_locality_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_state_or_province_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certPrincipal::get_state_or_province_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_country_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certPrincipal::get_country_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_organization_names<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
        names: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = if arg_names.is_null() {
            None
        } else {
            Some(arg_names.into())
        };
        let arg_names = arg_names.as_mut();
        let result = ImplX509certPrincipal::get_organization_names(&arg_self_.interface, arg_names);
    }
    extern "C" fn get_organization_unit_names<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
        names: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = if arg_names.is_null() {
            None
        } else {
            Some(arg_names.into())
        };
        let arg_names = arg_names.as_mut();
        let result =
            ImplX509certPrincipal::get_organization_unit_names(&arg_self_.interface, arg_names);
    }
}
impl ImplX509certPrincipal for X509certPrincipal {
    fn get_display_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_display_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_common_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_common_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_locality_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_locality_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_state_or_province_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_state_or_province_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_country_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_country_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_organization_names(&self, names: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .get_organization_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_organization_unit_names(&self, names: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .get_organization_unit_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_x509cert_principal_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_x509cert_principal_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for X509certPrincipal {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_x509cert_principal_t> for &X509certPrincipal {
    fn as_raw(self) -> *mut _cef_x509cert_principal_t {
        ImplX509certPrincipal::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_x509cert_principal_t> for &mut X509certPrincipal {
    fn as_raw(self) -> *mut _cef_x509cert_principal_t {
        ImplX509certPrincipal::get_raw(self)
    }
}
impl ConvertReturnValue<X509certPrincipal> for *mut _cef_x509cert_principal_t {
    fn as_wrapper(self) -> X509certPrincipal {
        X509certPrincipal(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_x509cert_principal_t> for X509certPrincipal {
    fn into(self) -> *mut _cef_x509cert_principal_t {
        let object = ImplX509certPrincipal::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for X509certPrincipal {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_x509certificate_t] for more documentation.
#[derive(Clone)]
pub struct X509certificate(RefGuard<_cef_x509certificate_t>);
impl X509certificate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapX509certificate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplX509certificate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapX509certificate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_x509certificate_t).as_wrapper()
        }
    }
}
pub trait WrapX509certificate: ImplX509certificate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_x509certificate_t, Self>);
}
pub trait ImplX509certificate: Clone + Sized + Rc {
    fn get_subject(&self) -> Option<X509certPrincipal> {
        Default::default()
    }
    fn get_issuer(&self) -> Option<X509certPrincipal> {
        Default::default()
    }
    fn get_serial_number(&self) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_valid_start(&self) -> Basetime {
        Default::default()
    }
    fn get_valid_expiry(&self) -> Basetime {
        Default::default()
    }
    fn get_derencoded(&self) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_pemencoded(&self) -> Option<BinaryValue> {
        Default::default()
    }
    fn get_issuer_chain_size(&self) -> usize {
        Default::default()
    }
    fn get_derencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>) {}
    fn get_pemencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>) {}
    fn init_methods(object: &mut _cef_x509certificate_t) {
        impl_cef_x509certificate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_x509certificate_t;
}
mod impl_cef_x509certificate_t {
    use super::*;
    pub fn init_methods<I: ImplX509certificate>(object: &mut _cef_x509certificate_t) {
        object.get_subject = Some(get_subject::<I>);
        object.get_issuer = Some(get_issuer::<I>);
        object.get_serial_number = Some(get_serial_number::<I>);
        object.get_valid_start = Some(get_valid_start::<I>);
        object.get_valid_expiry = Some(get_valid_expiry::<I>);
        object.get_derencoded = Some(get_derencoded::<I>);
        object.get_pemencoded = Some(get_pemencoded::<I>);
        object.get_issuer_chain_size = Some(get_issuer_chain_size::<I>);
        object.get_derencoded_issuer_chain = Some(get_derencoded_issuer_chain::<I>);
        object.get_pemencoded_issuer_chain = Some(get_pemencoded_issuer_chain::<I>);
    }
    extern "C" fn get_subject<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_x509cert_principal_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_subject(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_issuer<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_x509cert_principal_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_issuer(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_serial_number<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_serial_number(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_valid_start<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_valid_start(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_valid_expiry<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_valid_expiry(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_derencoded<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_derencoded(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_pemencoded<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_pemencoded(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_issuer_chain_size<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplX509certificate::get_issuer_chain_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_derencoded_issuer_chain<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
        chain_count: *mut usize,
        chain: *mut *mut _cef_binary_value_t,
    ) {
        let (arg_self_, arg_chain_count, arg_chain) = (self_, chain_count, chain);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let out_chain_count = unsafe { arg_chain_count.as_mut() };
        let out_chain = unsafe { arg_chain.as_mut() };
        let arg_chain_count = out_chain_count
            .as_ref()
            .map(|count| **count)
            .unwrap_or_default();
        let mut vec_chain = unsafe { arg_chain.as_mut() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts_mut(std::ptr::from_mut(arg), arg_chain_count) };
            arg.iter_mut()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(BinaryValue(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_chain = vec_chain.as_mut();
        let result =
            ImplX509certificate::get_derencoded_issuer_chain(&arg_self_.interface, arg_chain);
        if let (Some(out_chain_count), Some(vec_chain)) = (out_chain_count, vec_chain.as_mut()) {
            let size = vec_chain.len().min(*out_chain_count);
            for elem in &mut vec_chain[..size] {
                if let Some(elem) = elem.as_ref() {
                    unsafe { elem.add_ref() };
                }
            }
            *out_chain_count = size;
        }
    }
    extern "C" fn get_pemencoded_issuer_chain<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
        chain_count: *mut usize,
        chain: *mut *mut _cef_binary_value_t,
    ) {
        let (arg_self_, arg_chain_count, arg_chain) = (self_, chain_count, chain);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let out_chain_count = unsafe { arg_chain_count.as_mut() };
        let out_chain = unsafe { arg_chain.as_mut() };
        let arg_chain_count = out_chain_count
            .as_ref()
            .map(|count| **count)
            .unwrap_or_default();
        let mut vec_chain = unsafe { arg_chain.as_mut() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts_mut(std::ptr::from_mut(arg), arg_chain_count) };
            arg.iter_mut()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(BinaryValue(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_chain = vec_chain.as_mut();
        let result =
            ImplX509certificate::get_pemencoded_issuer_chain(&arg_self_.interface, arg_chain);
        if let (Some(out_chain_count), Some(vec_chain)) = (out_chain_count, vec_chain.as_mut()) {
            let size = vec_chain.len().min(*out_chain_count);
            for elem in &mut vec_chain[..size] {
                if let Some(elem) = elem.as_ref() {
                    unsafe { elem.add_ref() };
                }
            }
            *out_chain_count = size;
        }
    }
}
impl ImplX509certificate for X509certificate {
    fn get_subject(&self) -> Option<X509certPrincipal> {
        unsafe {
            self.0
                .get_subject
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_issuer(&self) -> Option<X509certPrincipal> {
        unsafe {
            self.0
                .get_issuer
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_serial_number(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_serial_number
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_valid_start(&self) -> Basetime {
        unsafe {
            self.0
                .get_valid_start
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_valid_expiry(&self) -> Basetime {
        unsafe {
            self.0
                .get_valid_expiry
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_derencoded(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_derencoded
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_pemencoded(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_pemencoded
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_issuer_chain_size(&self) -> usize {
        unsafe {
            self.0
                .get_issuer_chain_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_derencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>) {
        unsafe {
            self.0
                .get_derencoded_issuer_chain
                .map(|f| {
                    let arg_chain = chain;
                    let arg_self_ = self.as_raw();
                    let mut out_chain_count =
                        arg_chain.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_chain_count = &mut out_chain_count;
                    let out_chain = arg_chain;
                    let mut vec_chain = out_chain
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_chain = if vec_chain.is_empty() {
                        std::ptr::null_mut()
                    } else {
                        vec_chain.as_mut_ptr()
                    };
                    let result = f(arg_self_, arg_chain_count, arg_chain);
                    if let Some(out_chain) = out_chain {
                        *out_chain = vec_chain
                            .into_iter()
                            .take(out_chain_count)
                            .map(|elem| {
                                if elem.is_null() {
                                    None
                                } else {
                                    Some(elem.as_wrapper())
                                }
                            })
                            .collect();
                    }
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_pemencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>) {
        unsafe {
            self.0
                .get_pemencoded_issuer_chain
                .map(|f| {
                    let arg_chain = chain;
                    let arg_self_ = self.as_raw();
                    let mut out_chain_count =
                        arg_chain.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_chain_count = &mut out_chain_count;
                    let out_chain = arg_chain;
                    let mut vec_chain = out_chain
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_chain = if vec_chain.is_empty() {
                        std::ptr::null_mut()
                    } else {
                        vec_chain.as_mut_ptr()
                    };
                    let result = f(arg_self_, arg_chain_count, arg_chain);
                    if let Some(out_chain) = out_chain {
                        *out_chain = vec_chain
                            .into_iter()
                            .take(out_chain_count)
                            .map(|elem| {
                                if elem.is_null() {
                                    None
                                } else {
                                    Some(elem.as_wrapper())
                                }
                            })
                            .collect();
                    }
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_x509certificate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_x509certificate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for X509certificate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_x509certificate_t> for &X509certificate {
    fn as_raw(self) -> *mut _cef_x509certificate_t {
        ImplX509certificate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_x509certificate_t> for &mut X509certificate {
    fn as_raw(self) -> *mut _cef_x509certificate_t {
        ImplX509certificate::get_raw(self)
    }
}
impl ConvertReturnValue<X509certificate> for *mut _cef_x509certificate_t {
    fn as_wrapper(self) -> X509certificate {
        X509certificate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_x509certificate_t> for X509certificate {
    fn into(self) -> *mut _cef_x509certificate_t {
        let object = ImplX509certificate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for X509certificate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_sslstatus_t] for more documentation.
#[derive(Clone)]
pub struct Sslstatus(RefGuard<_cef_sslstatus_t>);
impl Sslstatus {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSslstatus,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSslstatus>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSslstatus>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_sslstatus_t).as_wrapper()
        }
    }
}
pub trait WrapSslstatus: ImplSslstatus {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_sslstatus_t, Self>);
}
pub trait ImplSslstatus: Clone + Sized + Rc {
    fn is_secure_connection(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_cert_status(&self) -> CertStatus {
        Default::default()
    }
    fn get_sslversion(&self) -> SslVersion {
        Default::default()
    }
    fn get_content_status(&self) -> SslContentStatus {
        Default::default()
    }
    fn get_x509certificate(&self) -> Option<X509certificate> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_sslstatus_t) {
        impl_cef_sslstatus_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_sslstatus_t;
}
mod impl_cef_sslstatus_t {
    use super::*;
    pub fn init_methods<I: ImplSslstatus>(object: &mut _cef_sslstatus_t) {
        object.is_secure_connection = Some(is_secure_connection::<I>);
        object.get_cert_status = Some(get_cert_status::<I>);
        object.get_sslversion = Some(get_sslversion::<I>);
        object.get_content_status = Some(get_content_status::<I>);
        object.get_x509certificate = Some(get_x509certificate::<I>);
    }
    extern "C" fn is_secure_connection<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSslstatus::is_secure_connection(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_cert_status<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> cef_cert_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSslstatus::get_cert_status(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_sslversion<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> cef_ssl_version_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSslstatus::get_sslversion(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_content_status<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> cef_ssl_content_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSslstatus::get_content_status(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_x509certificate<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> *mut _cef_x509certificate_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSslstatus::get_x509certificate(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplSslstatus for Sslstatus {
    fn is_secure_connection(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_secure_connection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_cert_status(&self) -> CertStatus {
        unsafe {
            self.0
                .get_cert_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_sslversion(&self) -> SslVersion {
        unsafe {
            self.0
                .get_sslversion
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_content_status(&self) -> SslContentStatus {
        unsafe {
            self.0
                .get_content_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_x509certificate(&self) -> Option<X509certificate> {
        unsafe {
            self.0
                .get_x509certificate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_sslstatus_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_sslstatus_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Sslstatus {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_sslstatus_t> for &Sslstatus {
    fn as_raw(self) -> *mut _cef_sslstatus_t {
        ImplSslstatus::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_sslstatus_t> for &mut Sslstatus {
    fn as_raw(self) -> *mut _cef_sslstatus_t {
        ImplSslstatus::get_raw(self)
    }
}
impl ConvertReturnValue<Sslstatus> for *mut _cef_sslstatus_t {
    fn as_wrapper(self) -> Sslstatus {
        Sslstatus(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_sslstatus_t> for Sslstatus {
    fn into(self) -> *mut _cef_sslstatus_t {
        let object = ImplSslstatus::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Sslstatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_navigation_entry_t] for more documentation.
#[derive(Clone)]
pub struct NavigationEntry(RefGuard<_cef_navigation_entry_t>);
impl NavigationEntry {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapNavigationEntry,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplNavigationEntry>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapNavigationEntry>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_navigation_entry_t).as_wrapper()
        }
    }
}
pub trait WrapNavigationEntry: ImplNavigationEntry {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_navigation_entry_t, Self>);
}
pub trait ImplNavigationEntry: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_display_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_original_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_title(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_transition_type(&self) -> TransitionType {
        Default::default()
    }
    fn has_post_data(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_completion_time(&self) -> Basetime {
        Default::default()
    }
    fn get_http_status_code(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_sslstatus(&self) -> Option<Sslstatus> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_navigation_entry_t) {
        impl_cef_navigation_entry_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_navigation_entry_t;
}
mod impl_cef_navigation_entry_t {
    use super::*;
    pub fn init_methods<I: ImplNavigationEntry>(object: &mut _cef_navigation_entry_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_url = Some(get_url::<I>);
        object.get_display_url = Some(get_display_url::<I>);
        object.get_original_url = Some(get_original_url::<I>);
        object.get_title = Some(get_title::<I>);
        object.get_transition_type = Some(get_transition_type::<I>);
        object.has_post_data = Some(has_post_data::<I>);
        object.get_completion_time = Some(get_completion_time::<I>);
        object.get_http_status_code = Some(get_http_status_code::<I>);
        object.get_sslstatus = Some(get_sslstatus::<I>);
    }
    extern "C" fn is_valid<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_url<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_display_url<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_display_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_original_url<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_original_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_title<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_title(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_transition_type<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> cef_transition_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_transition_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_post_data<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::has_post_data(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_completion_time<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_completion_time(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_http_status_code<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_http_status_code(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_sslstatus<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_sslstatus_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplNavigationEntry::get_sslstatus(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplNavigationEntry for NavigationEntry {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_display_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_display_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_original_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_original_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_title(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_transition_type(&self) -> TransitionType {
        unsafe {
            self.0
                .get_transition_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_post_data(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_post_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_completion_time(&self) -> Basetime {
        unsafe {
            self.0
                .get_completion_time
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_http_status_code(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_http_status_code
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_sslstatus(&self) -> Option<Sslstatus> {
        unsafe {
            self.0
                .get_sslstatus
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_navigation_entry_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_navigation_entry_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for NavigationEntry {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_navigation_entry_t> for &NavigationEntry {
    fn as_raw(self) -> *mut _cef_navigation_entry_t {
        ImplNavigationEntry::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_navigation_entry_t> for &mut NavigationEntry {
    fn as_raw(self) -> *mut _cef_navigation_entry_t {
        ImplNavigationEntry::get_raw(self)
    }
}
impl ConvertReturnValue<NavigationEntry> for *mut _cef_navigation_entry_t {
    fn as_wrapper(self) -> NavigationEntry {
        NavigationEntry(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_navigation_entry_t> for NavigationEntry {
    fn into(self) -> *mut _cef_navigation_entry_t {
        let object = ImplNavigationEntry::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for NavigationEntry {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_registration_t] for more documentation.
#[derive(Clone)]
pub struct Registration(RefGuard<_cef_registration_t>);
impl Registration {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRegistration,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRegistration>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRegistration>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_registration_t).as_wrapper()
        }
    }
}
pub trait WrapRegistration: ImplRegistration {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_registration_t, Self>);
}
pub trait ImplRegistration: Clone + Sized + Rc {
    fn init_methods(object: &mut _cef_registration_t) {
        impl_cef_registration_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_registration_t;
}
mod impl_cef_registration_t {
    use super::*;
    pub fn init_methods<I: ImplRegistration>(object: &mut _cef_registration_t) {}
}
impl ImplRegistration for Registration {
    fn get_raw(&self) -> *mut _cef_registration_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_registration_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Registration {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_registration_t> for &Registration {
    fn as_raw(self) -> *mut _cef_registration_t {
        ImplRegistration::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_registration_t> for &mut Registration {
    fn as_raw(self) -> *mut _cef_registration_t {
        ImplRegistration::get_raw(self)
    }
}
impl ConvertReturnValue<Registration> for *mut _cef_registration_t {
    fn as_wrapper(self) -> Registration {
        Registration(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_registration_t> for Registration {
    fn into(self) -> *mut _cef_registration_t {
        let object = ImplRegistration::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Registration {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_callback_t] for more documentation.
#[derive(Clone)]
pub struct Callback(RefGuard<_cef_callback_t>);
impl Callback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_callback_t).as_wrapper()
        }
    }
}
pub trait WrapCallback: ImplCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_callback_t, Self>);
}
pub trait ImplCallback: Clone + Sized + Rc {
    fn cont(&self) {}
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_callback_t) {
        impl_cef_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_callback_t;
}
mod impl_cef_callback_t {
    use super::*;
    pub fn init_methods<I: ImplCallback>(object: &mut _cef_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplCallback>(self_: *mut _cef_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCallback::cont(&arg_self_.interface);
    }
    extern "C" fn cancel<I: ImplCallback>(self_: *mut _cef_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCallback::cancel(&arg_self_.interface);
    }
}
impl ImplCallback for Callback {
    fn cont(&self) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Callback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_callback_t> for &Callback {
    fn as_raw(self) -> *mut _cef_callback_t {
        ImplCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_callback_t> for &mut Callback {
    fn as_raw(self) -> *mut _cef_callback_t {
        ImplCallback::get_raw(self)
    }
}
impl ConvertReturnValue<Callback> for *mut _cef_callback_t {
    fn as_wrapper(self) -> Callback {
        Callback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_callback_t> for Callback {
    fn into(self) -> *mut _cef_callback_t {
        let object = ImplCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Callback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_completion_callback_t] for more documentation.
#[derive(Clone)]
pub struct CompletionCallback(RefGuard<_cef_completion_callback_t>);
impl CompletionCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCompletionCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCompletionCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCompletionCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_completion_callback_t).as_wrapper()
        }
    }
}
pub trait WrapCompletionCallback: ImplCompletionCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_completion_callback_t, Self>);
}
pub trait ImplCompletionCallback: Clone + Sized + Rc {
    fn on_complete(&self) {}
    fn init_methods(object: &mut _cef_completion_callback_t) {
        impl_cef_completion_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_completion_callback_t;
}
mod impl_cef_completion_callback_t {
    use super::*;
    pub fn init_methods<I: ImplCompletionCallback>(object: &mut _cef_completion_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplCompletionCallback>(self_: *mut _cef_completion_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCompletionCallback::on_complete(&arg_self_.interface);
    }
}
impl ImplCompletionCallback for CompletionCallback {
    fn on_complete(&self) {
        unsafe {
            self.0
                .on_complete
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_completion_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_completion_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CompletionCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_completion_callback_t> for &CompletionCallback {
    fn as_raw(self) -> *mut _cef_completion_callback_t {
        ImplCompletionCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_completion_callback_t> for &mut CompletionCallback {
    fn as_raw(self) -> *mut _cef_completion_callback_t {
        ImplCompletionCallback::get_raw(self)
    }
}
impl ConvertReturnValue<CompletionCallback> for *mut _cef_completion_callback_t {
    fn as_wrapper(self) -> CompletionCallback {
        CompletionCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_completion_callback_t> for CompletionCallback {
    fn into(self) -> *mut _cef_completion_callback_t {
        let object = ImplCompletionCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for CompletionCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_cookie_manager_t] for more documentation.
#[derive(Clone)]
pub struct CookieManager(RefGuard<_cef_cookie_manager_t>);
impl CookieManager {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCookieManager,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCookieManager>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCookieManager>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_cookie_manager_t).as_wrapper()
        }
    }
}
pub trait WrapCookieManager: ImplCookieManager {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_cookie_manager_t, Self>);
}
pub trait ImplCookieManager: Clone + Sized + Rc {
    fn visit_all_cookies(
        &self,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn visit_url_cookies(
        &self,
        url: Option<&CefStringUtf16>,
        include_http_only: ::std::os::raw::c_int,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_cookie(
        &self,
        url: Option<&CefStringUtf16>,
        cookie: Option<&Cookie>,
        callback: Option<&mut impl ImplSetCookieCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn delete_cookies(
        &self,
        url: Option<&CefStringUtf16>,
        cookie_name: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplDeleteCookiesCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn flush_store(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_cookie_manager_t) {
        impl_cef_cookie_manager_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_cookie_manager_t;
}
mod impl_cef_cookie_manager_t {
    use super::*;
    pub fn init_methods<I: ImplCookieManager>(object: &mut _cef_cookie_manager_t) {
        object.visit_all_cookies = Some(visit_all_cookies::<I>);
        object.visit_url_cookies = Some(visit_url_cookies::<I>);
        object.set_cookie = Some(set_cookie::<I>);
        object.delete_cookies = Some(delete_cookies::<I>);
        object.flush_store = Some(flush_store::<I>);
    }
    extern "C" fn visit_all_cookies<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        visitor: *mut _cef_cookie_visitor_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_visitor = unsafe { arg_visitor.as_mut() }
            .map(|arg| CookieVisitor(unsafe { RefGuard::from_raw(arg) }));
        let arg_visitor = arg_visitor.as_mut();
        let result = ImplCookieManager::visit_all_cookies(&arg_self_.interface, arg_visitor);
        result.into()
    }
    extern "C" fn visit_url_cookies<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        url: *const _cef_string_utf16_t,
        include_http_only: ::std::os::raw::c_int,
        visitor: *mut _cef_cookie_visitor_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_url, arg_include_http_only, arg_visitor) =
            (self_, url, include_http_only, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let arg_include_http_only = arg_include_http_only.as_raw();
        let mut arg_visitor = unsafe { arg_visitor.as_mut() }
            .map(|arg| CookieVisitor(unsafe { RefGuard::from_raw(arg) }));
        let arg_visitor = arg_visitor.as_mut();
        let result = ImplCookieManager::visit_url_cookies(
            &arg_self_.interface,
            arg_url,
            arg_include_http_only,
            arg_visitor,
        );
        result.into()
    }
    extern "C" fn set_cookie<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        url: *const _cef_string_utf16_t,
        cookie: *const _cef_cookie_t,
        callback: *mut _cef_set_cookie_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_url, arg_cookie, arg_callback) = (self_, url, cookie, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let arg_cookie = if arg_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<Cookie>::from(arg_cookie))
        };
        let arg_cookie = arg_cookie.as_ref().map(|arg| arg.as_ref());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| SetCookieCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result =
            ImplCookieManager::set_cookie(&arg_self_.interface, arg_url, arg_cookie, arg_callback);
        result.into()
    }
    extern "C" fn delete_cookies<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        url: *const _cef_string_utf16_t,
        cookie_name: *const _cef_string_utf16_t,
        callback: *mut _cef_delete_cookies_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_url, arg_cookie_name, arg_callback) =
            (self_, url, cookie_name, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let arg_cookie_name = if arg_cookie_name.is_null() {
            None
        } else {
            Some(arg_cookie_name.into())
        };
        let arg_cookie_name = arg_cookie_name.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| DeleteCookiesCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplCookieManager::delete_cookies(
            &arg_self_.interface,
            arg_url,
            arg_cookie_name,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn flush_store<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        callback: *mut _cef_completion_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| CompletionCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplCookieManager::flush_store(&arg_self_.interface, arg_callback);
        result.into()
    }
}
impl ImplCookieManager for CookieManager {
    fn visit_all_cookies(
        &self,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit_all_cookies
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplCookieVisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn visit_url_cookies(
        &self,
        url: Option<&CefStringUtf16>,
        include_http_only: ::std::os::raw::c_int,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit_url_cookies
                .map(|f| {
                    let (arg_url, arg_include_http_only, arg_visitor) =
                        (url, include_http_only, visitor);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_include_http_only = arg_include_http_only;
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplCookieVisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_url, arg_include_http_only, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_cookie(
        &self,
        url: Option<&CefStringUtf16>,
        cookie: Option<&Cookie>,
        callback: Option<&mut impl ImplSetCookieCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_cookie
                .map(|f| {
                    let (arg_url, arg_cookie, arg_callback) = (url, cookie, callback);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplSetCookieCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_url, arg_cookie, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn delete_cookies(
        &self,
        url: Option<&CefStringUtf16>,
        cookie_name: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplDeleteCookiesCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_cookies
                .map(|f| {
                    let (arg_url, arg_cookie_name, arg_callback) = (url, cookie_name, callback);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_cookie_name = arg_cookie_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplDeleteCookiesCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_url, arg_cookie_name, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn flush_store(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush_store
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_cookie_manager_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_cookie_manager_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieManager {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_manager_t> for &CookieManager {
    fn as_raw(self) -> *mut _cef_cookie_manager_t {
        ImplCookieManager::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_cookie_manager_t> for &mut CookieManager {
    fn as_raw(self) -> *mut _cef_cookie_manager_t {
        ImplCookieManager::get_raw(self)
    }
}
impl ConvertReturnValue<CookieManager> for *mut _cef_cookie_manager_t {
    fn as_wrapper(self) -> CookieManager {
        CookieManager(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_cookie_manager_t> for CookieManager {
    fn into(self) -> *mut _cef_cookie_manager_t {
        let object = ImplCookieManager::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for CookieManager {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_cookie_visitor_t] for more documentation.
#[derive(Clone)]
pub struct CookieVisitor(RefGuard<_cef_cookie_visitor_t>);
impl CookieVisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCookieVisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCookieVisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCookieVisitor>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_cookie_visitor_t).as_wrapper()
        }
    }
}
pub trait WrapCookieVisitor: ImplCookieVisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_cookie_visitor_t, Self>);
}
pub trait ImplCookieVisitor: Clone + Sized + Rc {
    fn visit(
        &self,
        cookie: Option<&Cookie>,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_cookie_visitor_t) {
        impl_cef_cookie_visitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_cookie_visitor_t;
}
mod impl_cef_cookie_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplCookieVisitor>(object: &mut _cef_cookie_visitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplCookieVisitor>(
        self_: *mut _cef_cookie_visitor_t,
        cookie: *const _cef_cookie_t,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_cookie, arg_count, arg_total, arg_delete_cookie) =
            (self_, cookie, count, total, delete_cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_cookie = if arg_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<Cookie>::from(arg_cookie))
        };
        let arg_cookie = arg_cookie.as_ref().map(|arg| arg.as_ref());
        let arg_count = arg_count.as_raw();
        let arg_total = arg_total.as_raw();
        let mut arg_delete_cookie = if arg_delete_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_delete_cookie,
            ))
        };
        let arg_delete_cookie = arg_delete_cookie.as_mut().map(|arg| arg.as_mut());
        let result = ImplCookieVisitor::visit(
            &arg_self_.interface,
            arg_cookie,
            arg_count,
            arg_total,
            arg_delete_cookie,
        );
        result.into()
    }
}
impl ImplCookieVisitor for CookieVisitor {
    fn visit(
        &self,
        cookie: Option<&Cookie>,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let (arg_cookie, arg_count, arg_total, arg_delete_cookie) =
                        (cookie, count, total, delete_cookie);
                    let arg_self_ = self.as_raw();
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_count = arg_count;
                    let arg_total = arg_total;
                    let arg_delete_cookie = arg_delete_cookie
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_cookie,
                        arg_count,
                        arg_total,
                        arg_delete_cookie,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_cookie_visitor_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_cookie_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_visitor_t> for &CookieVisitor {
    fn as_raw(self) -> *mut _cef_cookie_visitor_t {
        ImplCookieVisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_cookie_visitor_t> for &mut CookieVisitor {
    fn as_raw(self) -> *mut _cef_cookie_visitor_t {
        ImplCookieVisitor::get_raw(self)
    }
}
impl ConvertReturnValue<CookieVisitor> for *mut _cef_cookie_visitor_t {
    fn as_wrapper(self) -> CookieVisitor {
        CookieVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_cookie_visitor_t> for CookieVisitor {
    fn into(self) -> *mut _cef_cookie_visitor_t {
        let object = ImplCookieVisitor::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for CookieVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_set_cookie_callback_t] for more documentation.
#[derive(Clone)]
pub struct SetCookieCallback(RefGuard<_cef_set_cookie_callback_t>);
impl SetCookieCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSetCookieCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSetCookieCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSetCookieCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_set_cookie_callback_t).as_wrapper()
        }
    }
}
pub trait WrapSetCookieCallback: ImplSetCookieCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_set_cookie_callback_t, Self>);
}
pub trait ImplSetCookieCallback: Clone + Sized + Rc {
    fn on_complete(&self, success: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_set_cookie_callback_t) {
        impl_cef_set_cookie_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_set_cookie_callback_t;
}
mod impl_cef_set_cookie_callback_t {
    use super::*;
    pub fn init_methods<I: ImplSetCookieCallback>(object: &mut _cef_set_cookie_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplSetCookieCallback>(
        self_: *mut _cef_set_cookie_callback_t,
        success: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_success) = (self_, success);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_success = arg_success.as_raw();
        let result = ImplSetCookieCallback::on_complete(&arg_self_.interface, arg_success);
    }
}
impl ImplSetCookieCallback for SetCookieCallback {
    fn on_complete(&self, success: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_complete
                .map(|f| {
                    let arg_success = success;
                    let arg_self_ = self.as_raw();
                    let arg_success = arg_success;
                    let result = f(arg_self_, arg_success);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_set_cookie_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_set_cookie_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SetCookieCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_set_cookie_callback_t> for &SetCookieCallback {
    fn as_raw(self) -> *mut _cef_set_cookie_callback_t {
        ImplSetCookieCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_set_cookie_callback_t> for &mut SetCookieCallback {
    fn as_raw(self) -> *mut _cef_set_cookie_callback_t {
        ImplSetCookieCallback::get_raw(self)
    }
}
impl ConvertReturnValue<SetCookieCallback> for *mut _cef_set_cookie_callback_t {
    fn as_wrapper(self) -> SetCookieCallback {
        SetCookieCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_set_cookie_callback_t> for SetCookieCallback {
    fn into(self) -> *mut _cef_set_cookie_callback_t {
        let object = ImplSetCookieCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for SetCookieCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_delete_cookies_callback_t] for more documentation.
#[derive(Clone)]
pub struct DeleteCookiesCallback(RefGuard<_cef_delete_cookies_callback_t>);
impl DeleteCookiesCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDeleteCookiesCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDeleteCookiesCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDeleteCookiesCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_delete_cookies_callback_t).as_wrapper()
        }
    }
}
pub trait WrapDeleteCookiesCallback: ImplDeleteCookiesCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_delete_cookies_callback_t, Self>);
}
pub trait ImplDeleteCookiesCallback: Clone + Sized + Rc {
    fn on_complete(&self, num_deleted: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_delete_cookies_callback_t) {
        impl_cef_delete_cookies_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_delete_cookies_callback_t;
}
mod impl_cef_delete_cookies_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDeleteCookiesCallback>(object: &mut _cef_delete_cookies_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplDeleteCookiesCallback>(
        self_: *mut _cef_delete_cookies_callback_t,
        num_deleted: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_num_deleted) = (self_, num_deleted);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_num_deleted = arg_num_deleted.as_raw();
        let result = ImplDeleteCookiesCallback::on_complete(&arg_self_.interface, arg_num_deleted);
    }
}
impl ImplDeleteCookiesCallback for DeleteCookiesCallback {
    fn on_complete(&self, num_deleted: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_complete
                .map(|f| {
                    let arg_num_deleted = num_deleted;
                    let arg_self_ = self.as_raw();
                    let arg_num_deleted = arg_num_deleted;
                    let result = f(arg_self_, arg_num_deleted);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_delete_cookies_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_delete_cookies_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DeleteCookiesCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_delete_cookies_callback_t> for &DeleteCookiesCallback {
    fn as_raw(self) -> *mut _cef_delete_cookies_callback_t {
        ImplDeleteCookiesCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_delete_cookies_callback_t> for &mut DeleteCookiesCallback {
    fn as_raw(self) -> *mut _cef_delete_cookies_callback_t {
        ImplDeleteCookiesCallback::get_raw(self)
    }
}
impl ConvertReturnValue<DeleteCookiesCallback> for *mut _cef_delete_cookies_callback_t {
    fn as_wrapper(self) -> DeleteCookiesCallback {
        DeleteCookiesCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_delete_cookies_callback_t> for DeleteCookiesCallback {
    fn into(self) -> *mut _cef_delete_cookies_callback_t {
        let object = ImplDeleteCookiesCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DeleteCookiesCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_router_t] for more documentation.
#[derive(Clone)]
pub struct MediaRouter(RefGuard<_cef_media_router_t>);
impl MediaRouter {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaRouter,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaRouter>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaRouter>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_router_t).as_wrapper()
        }
    }
}
pub trait WrapMediaRouter: ImplMediaRouter {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_router_t, Self>);
}
pub trait ImplMediaRouter: Clone + Sized + Rc {
    fn add_observer(&self, observer: Option<&mut impl ImplMediaObserver>) -> Option<Registration> {
        Default::default()
    }
    fn get_source(&self, urn: Option<&CefStringUtf16>) -> Option<MediaSource> {
        Default::default()
    }
    fn notify_current_sinks(&self) {}
    fn create_route(
        &self,
        source: Option<&mut impl ImplMediaSource>,
        sink: Option<&mut impl ImplMediaSink>,
        callback: Option<&mut impl ImplMediaRouteCreateCallback>,
    ) {
    }
    fn notify_current_routes(&self) {}
    fn init_methods(object: &mut _cef_media_router_t) {
        impl_cef_media_router_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_router_t;
}
mod impl_cef_media_router_t {
    use super::*;
    pub fn init_methods<I: ImplMediaRouter>(object: &mut _cef_media_router_t) {
        object.add_observer = Some(add_observer::<I>);
        object.get_source = Some(get_source::<I>);
        object.notify_current_sinks = Some(notify_current_sinks::<I>);
        object.create_route = Some(create_route::<I>);
        object.notify_current_routes = Some(notify_current_routes::<I>);
    }
    extern "C" fn add_observer<I: ImplMediaRouter>(
        self_: *mut _cef_media_router_t,
        observer: *mut _cef_media_observer_t,
    ) -> *mut _cef_registration_t {
        let (arg_self_, arg_observer) = (self_, observer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_observer = unsafe { arg_observer.as_mut() }
            .map(|arg| MediaObserver(unsafe { RefGuard::from_raw(arg) }));
        let arg_observer = arg_observer.as_mut();
        let result = ImplMediaRouter::add_observer(&arg_self_.interface, arg_observer);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_source<I: ImplMediaRouter>(
        self_: *mut _cef_media_router_t,
        urn: *const _cef_string_utf16_t,
    ) -> *mut _cef_media_source_t {
        let (arg_self_, arg_urn) = (self_, urn);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_urn = if arg_urn.is_null() {
            None
        } else {
            Some(arg_urn.into())
        };
        let arg_urn = arg_urn.as_ref();
        let result = ImplMediaRouter::get_source(&arg_self_.interface, arg_urn);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn notify_current_sinks<I: ImplMediaRouter>(self_: *mut _cef_media_router_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaRouter::notify_current_sinks(&arg_self_.interface);
    }
    extern "C" fn create_route<I: ImplMediaRouter>(
        self_: *mut _cef_media_router_t,
        source: *mut _cef_media_source_t,
        sink: *mut _cef_media_sink_t,
        callback: *mut _cef_media_route_create_callback_t,
    ) {
        let (arg_self_, arg_source, arg_sink, arg_callback) = (self_, source, sink, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_source = unsafe { arg_source.as_mut() }
            .map(|arg| MediaSource(unsafe { RefGuard::from_raw(arg) }));
        let arg_source = arg_source.as_mut();
        let mut arg_sink =
            unsafe { arg_sink.as_mut() }.map(|arg| MediaSink(unsafe { RefGuard::from_raw(arg) }));
        let arg_sink = arg_sink.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| MediaRouteCreateCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result =
            ImplMediaRouter::create_route(&arg_self_.interface, arg_source, arg_sink, arg_callback);
    }
    extern "C" fn notify_current_routes<I: ImplMediaRouter>(self_: *mut _cef_media_router_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaRouter::notify_current_routes(&arg_self_.interface);
    }
}
impl ImplMediaRouter for MediaRouter {
    fn add_observer(&self, observer: Option<&mut impl ImplMediaObserver>) -> Option<Registration> {
        unsafe {
            self.0
                .add_observer
                .map(|f| {
                    let arg_observer = observer;
                    let arg_self_ = self.as_raw();
                    let arg_observer = arg_observer
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaObserver::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_observer);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_source(&self, urn: Option<&CefStringUtf16>) -> Option<MediaSource> {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_urn = urn;
                    let arg_self_ = self.as_raw();
                    let arg_urn = arg_urn.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_urn);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn notify_current_sinks(&self) {
        unsafe {
            self.0
                .notify_current_sinks
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn create_route(
        &self,
        source: Option<&mut impl ImplMediaSource>,
        sink: Option<&mut impl ImplMediaSink>,
        callback: Option<&mut impl ImplMediaRouteCreateCallback>,
    ) {
        unsafe {
            self.0
                .create_route
                .map(|f| {
                    let (arg_source, arg_sink, arg_callback) = (source, sink, callback);
                    let arg_self_ = self.as_raw();
                    let arg_source = arg_source
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaSource::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_sink = arg_sink
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaSink::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaRouteCreateCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_source, arg_sink, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn notify_current_routes(&self) {
        unsafe {
            self.0
                .notify_current_routes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_media_router_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_router_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRouter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_router_t> for &MediaRouter {
    fn as_raw(self) -> *mut _cef_media_router_t {
        ImplMediaRouter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_router_t> for &mut MediaRouter {
    fn as_raw(self) -> *mut _cef_media_router_t {
        ImplMediaRouter::get_raw(self)
    }
}
impl ConvertReturnValue<MediaRouter> for *mut _cef_media_router_t {
    fn as_wrapper(self) -> MediaRouter {
        MediaRouter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_router_t> for MediaRouter {
    fn into(self) -> *mut _cef_media_router_t {
        let object = ImplMediaRouter::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaRouter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_observer_t] for more documentation.
#[derive(Clone)]
pub struct MediaObserver(RefGuard<_cef_media_observer_t>);
impl MediaObserver {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaObserver,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaObserver>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaObserver>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_observer_t).as_wrapper()
        }
    }
}
pub trait WrapMediaObserver: ImplMediaObserver {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_observer_t, Self>);
}
pub trait ImplMediaObserver: Clone + Sized + Rc {
    fn on_sinks(&self, sinks: Option<&[Option<impl ImplMediaSink>]>) {}
    fn on_routes(&self, routes: Option<&[Option<impl ImplMediaRoute>]>) {}
    fn on_route_state_changed(
        &self,
        route: Option<&mut impl ImplMediaRoute>,
        state: MediaRouteConnectionState,
    ) {
    }
    fn on_route_message_received(
        &self,
        route: Option<&mut impl ImplMediaRoute>,
        message: Option<&[u8]>,
    ) {
    }
    fn init_methods(object: &mut _cef_media_observer_t) {
        impl_cef_media_observer_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_observer_t;
}
mod impl_cef_media_observer_t {
    use super::*;
    pub fn init_methods<I: ImplMediaObserver>(object: &mut _cef_media_observer_t) {
        object.on_sinks = Some(on_sinks::<I>);
        object.on_routes = Some(on_routes::<I>);
        object.on_route_state_changed = Some(on_route_state_changed::<I>);
        object.on_route_message_received = Some(on_route_message_received::<I>);
    }
    extern "C" fn on_sinks<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        sinks_count: usize,
        sinks: *const *mut _cef_media_sink_t,
    ) {
        let (arg_self_, arg_sinks_count, arg_sinks) = (self_, sinks_count, sinks);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let vec_sinks = unsafe { arg_sinks.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_sinks_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(MediaSink(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_sinks = vec_sinks.as_ref().map(|arg| arg.as_slice());
        let result = ImplMediaObserver::on_sinks(&arg_self_.interface, arg_sinks);
    }
    extern "C" fn on_routes<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        routes_count: usize,
        routes: *const *mut _cef_media_route_t,
    ) {
        let (arg_self_, arg_routes_count, arg_routes) = (self_, routes_count, routes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let vec_routes = unsafe { arg_routes.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_routes_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(MediaRoute(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_routes = vec_routes.as_ref().map(|arg| arg.as_slice());
        let result = ImplMediaObserver::on_routes(&arg_self_.interface, arg_routes);
    }
    extern "C" fn on_route_state_changed<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        route: *mut _cef_media_route_t,
        state: cef_media_route_connection_state_t,
    ) {
        let (arg_self_, arg_route, arg_state) = (self_, route, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_route =
            unsafe { arg_route.as_mut() }.map(|arg| MediaRoute(unsafe { RefGuard::from_raw(arg) }));
        let arg_route = arg_route.as_mut();
        let arg_state = arg_state.as_raw();
        let result =
            ImplMediaObserver::on_route_state_changed(&arg_self_.interface, arg_route, arg_state);
    }
    extern "C" fn on_route_message_received<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        route: *mut _cef_media_route_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) {
        let (arg_self_, arg_route, arg_message, arg_message_size) =
            (self_, route, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_route =
            unsafe { arg_route.as_mut() }.map(|arg| MediaRoute(unsafe { RefGuard::from_raw(arg) }));
        let arg_route = arg_route.as_mut();
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        let result = ImplMediaObserver::on_route_message_received(
            &arg_self_.interface,
            arg_route,
            arg_message,
        );
    }
}
impl ImplMediaObserver for MediaObserver {
    fn on_sinks(&self, sinks: Option<&[Option<impl ImplMediaSink>]>) {
        unsafe {
            self.0
                .on_sinks
                .map(|f| {
                    let arg_sinks = sinks;
                    let arg_self_ = self.as_raw();
                    let arg_sinks_count =
                        arg_sinks.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let vec_sinks = arg_sinks
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_sinks = if vec_sinks.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_sinks.as_ptr()
                    };
                    let result = f(arg_self_, arg_sinks_count, arg_sinks);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_routes(&self, routes: Option<&[Option<impl ImplMediaRoute>]>) {
        unsafe {
            self.0
                .on_routes
                .map(|f| {
                    let arg_routes = routes;
                    let arg_self_ = self.as_raw();
                    let arg_routes_count =
                        arg_routes.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let vec_routes = arg_routes
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_routes = if vec_routes.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_routes.as_ptr()
                    };
                    let result = f(arg_self_, arg_routes_count, arg_routes);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_route_state_changed(
        &self,
        route: Option<&mut impl ImplMediaRoute>,
        state: MediaRouteConnectionState,
    ) {
        unsafe {
            self.0
                .on_route_state_changed
                .map(|f| {
                    let (arg_route, arg_state) = (route, state);
                    let arg_self_ = self.as_raw();
                    let arg_route = arg_route
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaRoute::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_state = arg_state.as_raw();
                    let result = f(arg_self_, arg_route, arg_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_route_message_received(
        &self,
        route: Option<&mut impl ImplMediaRoute>,
        message: Option<&[u8]>,
    ) {
        unsafe {
            self.0
                .on_route_message_received
                .map(|f| {
                    let (arg_route, arg_message) = (route, message);
                    let arg_self_ = self.as_raw();
                    let arg_route = arg_route
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaRoute::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_message_size = arg_message
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_message = arg_message
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_route, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_media_observer_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_observer_t> for &MediaObserver {
    fn as_raw(self) -> *mut _cef_media_observer_t {
        ImplMediaObserver::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_observer_t> for &mut MediaObserver {
    fn as_raw(self) -> *mut _cef_media_observer_t {
        ImplMediaObserver::get_raw(self)
    }
}
impl ConvertReturnValue<MediaObserver> for *mut _cef_media_observer_t {
    fn as_wrapper(self) -> MediaObserver {
        MediaObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_observer_t> for MediaObserver {
    fn into(self) -> *mut _cef_media_observer_t {
        let object = ImplMediaObserver::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_route_t] for more documentation.
#[derive(Clone)]
pub struct MediaRoute(RefGuard<_cef_media_route_t>);
impl MediaRoute {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaRoute,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaRoute>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaRoute>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_route_t).as_wrapper()
        }
    }
}
pub trait WrapMediaRoute: ImplMediaRoute {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_route_t, Self>);
}
pub trait ImplMediaRoute: Clone + Sized + Rc {
    fn get_id(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_source(&self) -> Option<MediaSource> {
        Default::default()
    }
    fn get_sink(&self) -> Option<MediaSink> {
        Default::default()
    }
    fn send_route_message(&self, message: Option<&[u8]>) {}
    fn terminate(&self) {}
    fn init_methods(object: &mut _cef_media_route_t) {
        impl_cef_media_route_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_route_t;
}
mod impl_cef_media_route_t {
    use super::*;
    pub fn init_methods<I: ImplMediaRoute>(object: &mut _cef_media_route_t) {
        object.get_id = Some(get_id::<I>);
        object.get_source = Some(get_source::<I>);
        object.get_sink = Some(get_sink::<I>);
        object.send_route_message = Some(send_route_message::<I>);
        object.terminate = Some(terminate::<I>);
    }
    extern "C" fn get_id<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaRoute::get_id(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_source<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
    ) -> *mut _cef_media_source_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaRoute::get_source(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_sink<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
    ) -> *mut _cef_media_sink_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaRoute::get_sink(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn send_route_message<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) {
        let (arg_self_, arg_message, arg_message_size) = (self_, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        let result = ImplMediaRoute::send_route_message(&arg_self_.interface, arg_message);
    }
    extern "C" fn terminate<I: ImplMediaRoute>(self_: *mut _cef_media_route_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaRoute::terminate(&arg_self_.interface);
    }
}
impl ImplMediaRoute for MediaRoute {
    fn get_id(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_source(&self) -> Option<MediaSource> {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_sink(&self) -> Option<MediaSink> {
        unsafe {
            self.0
                .get_sink
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn send_route_message(&self, message: Option<&[u8]>) {
        unsafe {
            self.0
                .send_route_message
                .map(|f| {
                    let arg_message = message;
                    let arg_self_ = self.as_raw();
                    let arg_message_size = arg_message
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_message = arg_message
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn terminate(&self) {
        unsafe {
            self.0
                .terminate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_media_route_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_route_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRoute {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_route_t> for &MediaRoute {
    fn as_raw(self) -> *mut _cef_media_route_t {
        ImplMediaRoute::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_route_t> for &mut MediaRoute {
    fn as_raw(self) -> *mut _cef_media_route_t {
        ImplMediaRoute::get_raw(self)
    }
}
impl ConvertReturnValue<MediaRoute> for *mut _cef_media_route_t {
    fn as_wrapper(self) -> MediaRoute {
        MediaRoute(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_route_t> for MediaRoute {
    fn into(self) -> *mut _cef_media_route_t {
        let object = ImplMediaRoute::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaRoute {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_route_create_callback_t] for more documentation.
#[derive(Clone)]
pub struct MediaRouteCreateCallback(RefGuard<_cef_media_route_create_callback_t>);
impl MediaRouteCreateCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaRouteCreateCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaRouteCreateCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaRouteCreateCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_route_create_callback_t).as_wrapper()
        }
    }
}
pub trait WrapMediaRouteCreateCallback: ImplMediaRouteCreateCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_route_create_callback_t, Self>);
}
pub trait ImplMediaRouteCreateCallback: Clone + Sized + Rc {
    fn on_media_route_create_finished(
        &self,
        result: MediaRouteCreateResult,
        error: Option<&CefStringUtf16>,
        route: Option<&mut impl ImplMediaRoute>,
    ) {
    }
    fn init_methods(object: &mut _cef_media_route_create_callback_t) {
        impl_cef_media_route_create_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_route_create_callback_t;
}
mod impl_cef_media_route_create_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaRouteCreateCallback>(
        object: &mut _cef_media_route_create_callback_t,
    ) {
        object.on_media_route_create_finished = Some(on_media_route_create_finished::<I>);
    }
    extern "C" fn on_media_route_create_finished<I: ImplMediaRouteCreateCallback>(
        self_: *mut _cef_media_route_create_callback_t,
        result: cef_media_route_create_result_t,
        error: *const _cef_string_utf16_t,
        route: *mut _cef_media_route_t,
    ) {
        let (arg_self_, arg_result, arg_error, arg_route) = (self_, result, error, route);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.as_raw();
        let arg_error = if arg_error.is_null() {
            None
        } else {
            Some(arg_error.into())
        };
        let arg_error = arg_error.as_ref();
        let mut arg_route =
            unsafe { arg_route.as_mut() }.map(|arg| MediaRoute(unsafe { RefGuard::from_raw(arg) }));
        let arg_route = arg_route.as_mut();
        let result = ImplMediaRouteCreateCallback::on_media_route_create_finished(
            &arg_self_.interface,
            arg_result,
            arg_error,
            arg_route,
        );
    }
}
impl ImplMediaRouteCreateCallback for MediaRouteCreateCallback {
    fn on_media_route_create_finished(
        &self,
        result: MediaRouteCreateResult,
        error: Option<&CefStringUtf16>,
        route: Option<&mut impl ImplMediaRoute>,
    ) {
        unsafe {
            self.0
                .on_media_route_create_finished
                .map(|f| {
                    let (arg_result, arg_error, arg_route) = (result, error, route);
                    let arg_self_ = self.as_raw();
                    let arg_result = arg_result.as_raw();
                    let arg_error = arg_error
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_route = arg_route
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaRoute::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_result, arg_error, arg_route);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_media_route_create_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_route_create_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRouteCreateCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_route_create_callback_t> for &MediaRouteCreateCallback {
    fn as_raw(self) -> *mut _cef_media_route_create_callback_t {
        ImplMediaRouteCreateCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_route_create_callback_t> for &mut MediaRouteCreateCallback {
    fn as_raw(self) -> *mut _cef_media_route_create_callback_t {
        ImplMediaRouteCreateCallback::get_raw(self)
    }
}
impl ConvertReturnValue<MediaRouteCreateCallback> for *mut _cef_media_route_create_callback_t {
    fn as_wrapper(self) -> MediaRouteCreateCallback {
        MediaRouteCreateCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_route_create_callback_t> for MediaRouteCreateCallback {
    fn into(self) -> *mut _cef_media_route_create_callback_t {
        let object = ImplMediaRouteCreateCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaRouteCreateCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_sink_t] for more documentation.
#[derive(Clone)]
pub struct MediaSink(RefGuard<_cef_media_sink_t>);
impl MediaSink {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaSink,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaSink>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaSink>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_sink_t).as_wrapper()
        }
    }
}
pub trait WrapMediaSink: ImplMediaSink {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_sink_t, Self>);
}
pub trait ImplMediaSink: Clone + Sized + Rc {
    fn get_id(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_icon_type(&self) -> MediaSinkIconType {
        Default::default()
    }
    fn get_device_info(&self, callback: Option<&mut impl ImplMediaSinkDeviceInfoCallback>) {}
    fn is_cast_sink(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_dial_sink(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_compatible_with(
        &self,
        source: Option<&mut impl ImplMediaSource>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_media_sink_t) {
        impl_cef_media_sink_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_sink_t;
}
mod impl_cef_media_sink_t {
    use super::*;
    pub fn init_methods<I: ImplMediaSink>(object: &mut _cef_media_sink_t) {
        object.get_id = Some(get_id::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_icon_type = Some(get_icon_type::<I>);
        object.get_device_info = Some(get_device_info::<I>);
        object.is_cast_sink = Some(is_cast_sink::<I>);
        object.is_dial_sink = Some(is_dial_sink::<I>);
        object.is_compatible_with = Some(is_compatible_with::<I>);
    }
    extern "C" fn get_id<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSink::get_id(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_name<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSink::get_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_icon_type<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> cef_media_sink_icon_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSink::get_icon_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_device_info<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
        callback: *mut _cef_media_sink_device_info_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| MediaSinkDeviceInfoCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplMediaSink::get_device_info(&arg_self_.interface, arg_callback);
    }
    extern "C" fn is_cast_sink<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSink::is_cast_sink(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_dial_sink<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSink::is_dial_sink(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_compatible_with<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
        source: *mut _cef_media_source_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_source) = (self_, source);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_source = unsafe { arg_source.as_mut() }
            .map(|arg| MediaSource(unsafe { RefGuard::from_raw(arg) }));
        let arg_source = arg_source.as_mut();
        let result = ImplMediaSink::is_compatible_with(&arg_self_.interface, arg_source);
        result.into()
    }
}
impl ImplMediaSink for MediaSink {
    fn get_id(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_icon_type(&self) -> MediaSinkIconType {
        unsafe {
            self.0
                .get_icon_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_device_info(&self, callback: Option<&mut impl ImplMediaSinkDeviceInfoCallback>) {
        unsafe {
            self.0
                .get_device_info
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaSinkDeviceInfoCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_cast_sink(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_cast_sink
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_dial_sink(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_dial_sink
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_compatible_with(
        &self,
        source: Option<&mut impl ImplMediaSource>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_compatible_with
                .map(|f| {
                    let arg_source = source;
                    let arg_self_ = self.as_raw();
                    let arg_source = arg_source
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaSource::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_source);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_media_sink_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_sink_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSink {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_sink_t> for &MediaSink {
    fn as_raw(self) -> *mut _cef_media_sink_t {
        ImplMediaSink::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_sink_t> for &mut MediaSink {
    fn as_raw(self) -> *mut _cef_media_sink_t {
        ImplMediaSink::get_raw(self)
    }
}
impl ConvertReturnValue<MediaSink> for *mut _cef_media_sink_t {
    fn as_wrapper(self) -> MediaSink {
        MediaSink(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_sink_t> for MediaSink {
    fn into(self) -> *mut _cef_media_sink_t {
        let object = ImplMediaSink::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaSink {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_sink_device_info_callback_t] for more documentation.
#[derive(Clone)]
pub struct MediaSinkDeviceInfoCallback(RefGuard<_cef_media_sink_device_info_callback_t>);
impl MediaSinkDeviceInfoCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaSinkDeviceInfoCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaSinkDeviceInfoCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaSinkDeviceInfoCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_sink_device_info_callback_t).as_wrapper()
        }
    }
}
pub trait WrapMediaSinkDeviceInfoCallback: ImplMediaSinkDeviceInfoCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_sink_device_info_callback_t, Self>);
}
pub trait ImplMediaSinkDeviceInfoCallback: Clone + Sized + Rc {
    fn on_media_sink_device_info(&self, device_info: Option<&MediaSinkDeviceInfo>) {}
    fn init_methods(object: &mut _cef_media_sink_device_info_callback_t) {
        impl_cef_media_sink_device_info_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_sink_device_info_callback_t;
}
mod impl_cef_media_sink_device_info_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaSinkDeviceInfoCallback>(
        object: &mut _cef_media_sink_device_info_callback_t,
    ) {
        object.on_media_sink_device_info = Some(on_media_sink_device_info::<I>);
    }
    extern "C" fn on_media_sink_device_info<I: ImplMediaSinkDeviceInfoCallback>(
        self_: *mut _cef_media_sink_device_info_callback_t,
        device_info: *const _cef_media_sink_device_info_t,
    ) {
        let (arg_self_, arg_device_info) = (self_, device_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_device_info = if arg_device_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<MediaSinkDeviceInfo>::from(arg_device_info))
        };
        let arg_device_info = arg_device_info.as_ref().map(|arg| arg.as_ref());
        let result = ImplMediaSinkDeviceInfoCallback::on_media_sink_device_info(
            &arg_self_.interface,
            arg_device_info,
        );
    }
}
impl ImplMediaSinkDeviceInfoCallback for MediaSinkDeviceInfoCallback {
    fn on_media_sink_device_info(&self, device_info: Option<&MediaSinkDeviceInfo>) {
        unsafe {
            self.0
                .on_media_sink_device_info
                .map(|f| {
                    let arg_device_info = device_info;
                    let arg_self_ = self.as_raw();
                    let arg_device_info = arg_device_info.cloned().map(|arg| arg.into());
                    let arg_device_info = arg_device_info
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_device_info);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_media_sink_device_info_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_sink_device_info_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSinkDeviceInfoCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_sink_device_info_callback_t> for &MediaSinkDeviceInfoCallback {
    fn as_raw(self) -> *mut _cef_media_sink_device_info_callback_t {
        ImplMediaSinkDeviceInfoCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_sink_device_info_callback_t>
    for &mut MediaSinkDeviceInfoCallback
{
    fn as_raw(self) -> *mut _cef_media_sink_device_info_callback_t {
        ImplMediaSinkDeviceInfoCallback::get_raw(self)
    }
}
impl ConvertReturnValue<MediaSinkDeviceInfoCallback>
    for *mut _cef_media_sink_device_info_callback_t
{
    fn as_wrapper(self) -> MediaSinkDeviceInfoCallback {
        MediaSinkDeviceInfoCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_sink_device_info_callback_t> for MediaSinkDeviceInfoCallback {
    fn into(self) -> *mut _cef_media_sink_device_info_callback_t {
        let object = ImplMediaSinkDeviceInfoCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaSinkDeviceInfoCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_source_t] for more documentation.
#[derive(Clone)]
pub struct MediaSource(RefGuard<_cef_media_source_t>);
impl MediaSource {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaSource,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaSource>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaSource>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_source_t).as_wrapper()
        }
    }
}
pub trait WrapMediaSource: ImplMediaSource {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_source_t, Self>);
}
pub trait ImplMediaSource: Clone + Sized + Rc {
    fn get_id(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn is_cast_source(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_dial_source(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_media_source_t) {
        impl_cef_media_source_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_source_t;
}
mod impl_cef_media_source_t {
    use super::*;
    pub fn init_methods<I: ImplMediaSource>(object: &mut _cef_media_source_t) {
        object.get_id = Some(get_id::<I>);
        object.is_cast_source = Some(is_cast_source::<I>);
        object.is_dial_source = Some(is_dial_source::<I>);
    }
    extern "C" fn get_id<I: ImplMediaSource>(
        self_: *mut _cef_media_source_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSource::get_id(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_cast_source<I: ImplMediaSource>(
        self_: *mut _cef_media_source_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSource::is_cast_source(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_dial_source<I: ImplMediaSource>(
        self_: *mut _cef_media_source_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaSource::is_dial_source(&arg_self_.interface);
        result.into()
    }
}
impl ImplMediaSource for MediaSource {
    fn get_id(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_cast_source(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_cast_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_dial_source(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_dial_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_media_source_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_source_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSource {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_source_t> for &MediaSource {
    fn as_raw(self) -> *mut _cef_media_source_t {
        ImplMediaSource::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_source_t> for &mut MediaSource {
    fn as_raw(self) -> *mut _cef_media_source_t {
        ImplMediaSource::get_raw(self)
    }
}
impl ConvertReturnValue<MediaSource> for *mut _cef_media_source_t {
    fn as_wrapper(self) -> MediaSource {
        MediaSource(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_source_t> for MediaSource {
    fn into(self) -> *mut _cef_media_source_t {
        let object = ImplMediaSource::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaSource {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_preference_registrar_t] for more documentation.
#[derive(Clone, Copy)]
pub struct PreferenceRegistrar(*mut _cef_preference_registrar_t);
pub trait ImplPreferenceRegistrar: Sized {
    fn add_preference(
        &self,
        name: Option<&CefStringUtf16>,
        default_value: Option<&mut impl ImplValue>,
    ) -> ::std::os::raw::c_int;
    fn init_methods(object: &mut _cef_preference_registrar_t) {
        impl_cef_preference_registrar_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_preference_registrar_t;
}
mod impl_cef_preference_registrar_t {
    use super::*;
    pub fn init_methods<I: ImplPreferenceRegistrar>(object: &mut _cef_preference_registrar_t) {
        object.add_preference = Some(add_preference::<I>);
    }
    extern "C" fn add_preference<I: ImplPreferenceRegistrar>(
        self_: *mut _cef_preference_registrar_t,
        name: *const _cef_string_utf16_t,
        default_value: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_default_value) = (self_, name, default_value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_default_value = unsafe { arg_default_value.as_mut() }
            .map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_default_value = arg_default_value.as_mut();
        let result = ImplPreferenceRegistrar::add_preference(
            &arg_self_.interface,
            arg_name,
            arg_default_value,
        );
        result.into()
    }
}
impl ImplPreferenceRegistrar for PreferenceRegistrar {
    fn add_preference(
        &self,
        name: Option<&CefStringUtf16>,
        default_value: Option<&mut impl ImplValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .as_ref()
                .and_then(|this| this.add_preference)
                .map(|f| {
                    let (arg_name, arg_default_value) = (name, default_value);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_default_value = arg_default_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_default_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_preference_registrar_t {
        self.0
    }
}
impl ConvertParam<*mut _cef_preference_registrar_t> for &PreferenceRegistrar {
    fn as_raw(self) -> *mut _cef_preference_registrar_t {
        ImplPreferenceRegistrar::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_preference_registrar_t> for &mut PreferenceRegistrar {
    fn as_raw(self) -> *mut _cef_preference_registrar_t {
        ImplPreferenceRegistrar::get_raw(self)
    }
}
impl ConvertReturnValue<PreferenceRegistrar> for *mut _cef_preference_registrar_t {
    fn as_wrapper(self) -> PreferenceRegistrar {
        PreferenceRegistrar(self)
    }
}
impl Into<*mut _cef_preference_registrar_t> for PreferenceRegistrar {
    fn into(self) -> *mut _cef_preference_registrar_t {
        ImplPreferenceRegistrar::get_raw(&self)
    }
}
impl Default for PreferenceRegistrar {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

/// See [_cef_preference_manager_t] for more documentation.
#[derive(Clone)]
pub struct PreferenceManager(RefGuard<_cef_preference_manager_t>);
impl PreferenceManager {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPreferenceManager,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPreferenceManager>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPreferenceManager>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_preference_manager_t).as_wrapper()
        }
    }
}
pub trait WrapPreferenceManager: ImplPreferenceManager {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_preference_manager_t, Self>);
}
pub trait ImplPreferenceManager: Clone + Sized + Rc {
    fn has_preference(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_preference(&self, name: Option<&CefStringUtf16>) -> Option<Value> {
        Default::default()
    }
    fn get_all_preferences(
        &self,
        include_defaults: ::std::os::raw::c_int,
    ) -> Option<DictionaryValue> {
        Default::default()
    }
    fn can_set_preference(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_preference(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplValue>,
        error: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_preference_manager_t) {
        impl_cef_preference_manager_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_preference_manager_t;
}
mod impl_cef_preference_manager_t {
    use super::*;
    pub fn init_methods<I: ImplPreferenceManager>(object: &mut _cef_preference_manager_t) {
        object.has_preference = Some(has_preference::<I>);
        object.get_preference = Some(get_preference::<I>);
        object.get_all_preferences = Some(get_all_preferences::<I>);
        object.can_set_preference = Some(can_set_preference::<I>);
        object.set_preference = Some(set_preference::<I>);
    }
    extern "C" fn has_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplPreferenceManager::has_preference(&arg_self_.interface, arg_name);
        result.into()
    }
    extern "C" fn get_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplPreferenceManager::get_preference(&arg_self_.interface, arg_name);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_all_preferences<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        include_defaults: ::std::os::raw::c_int,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_include_defaults) = (self_, include_defaults);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_include_defaults = arg_include_defaults.as_raw();
        let result =
            ImplPreferenceManager::get_all_preferences(&arg_self_.interface, arg_include_defaults);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn can_set_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplPreferenceManager::can_set_preference(&arg_self_.interface, arg_name);
        result.into()
    }
    extern "C" fn set_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
        value: *mut _cef_value_t,
        error: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_value, arg_error) = (self_, name, value, error);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let mut arg_error = if arg_error.is_null() {
            None
        } else {
            Some(arg_error.into())
        };
        let arg_error = arg_error.as_mut();
        let result = ImplPreferenceManager::set_preference(
            &arg_self_.interface,
            arg_name,
            arg_value,
            arg_error,
        );
        result.into()
    }
}
impl ImplPreferenceManager for PreferenceManager {
    fn has_preference(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_preference(&self, name: Option<&CefStringUtf16>) -> Option<Value> {
        unsafe {
            self.0
                .get_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_all_preferences(
        &self,
        include_defaults: ::std::os::raw::c_int,
    ) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_all_preferences
                .map(|f| {
                    let arg_include_defaults = include_defaults;
                    let arg_self_ = self.as_raw();
                    let arg_include_defaults = arg_include_defaults;
                    let result = f(arg_self_, arg_include_defaults);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn can_set_preference(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_set_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_preference(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplValue>,
        error: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_preference
                .map(|f| {
                    let (arg_name, arg_value, arg_error) = (name, value, error);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_error = arg_error
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_value, arg_error);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_preference_manager_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_preference_manager_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PreferenceManager {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_preference_manager_t> for &PreferenceManager {
    fn as_raw(self) -> *mut _cef_preference_manager_t {
        ImplPreferenceManager::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_preference_manager_t> for &mut PreferenceManager {
    fn as_raw(self) -> *mut _cef_preference_manager_t {
        ImplPreferenceManager::get_raw(self)
    }
}
impl ConvertReturnValue<PreferenceManager> for *mut _cef_preference_manager_t {
    fn as_wrapper(self) -> PreferenceManager {
        PreferenceManager(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_preference_manager_t> for PreferenceManager {
    fn into(self) -> *mut _cef_preference_manager_t {
        let object = ImplPreferenceManager::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PreferenceManager {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_resolve_callback_t] for more documentation.
#[derive(Clone)]
pub struct ResolveCallback(RefGuard<_cef_resolve_callback_t>);
impl ResolveCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResolveCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResolveCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResolveCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_resolve_callback_t).as_wrapper()
        }
    }
}
pub trait WrapResolveCallback: ImplResolveCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resolve_callback_t, Self>);
}
pub trait ImplResolveCallback: Clone + Sized + Rc {
    fn on_resolve_completed(&self, result: Errorcode, resolved_ips: Option<&mut CefStringList>) {}
    fn init_methods(object: &mut _cef_resolve_callback_t) {
        impl_cef_resolve_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resolve_callback_t;
}
mod impl_cef_resolve_callback_t {
    use super::*;
    pub fn init_methods<I: ImplResolveCallback>(object: &mut _cef_resolve_callback_t) {
        object.on_resolve_completed = Some(on_resolve_completed::<I>);
    }
    extern "C" fn on_resolve_completed<I: ImplResolveCallback>(
        self_: *mut _cef_resolve_callback_t,
        result: cef_errorcode_t,
        resolved_ips: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_result, arg_resolved_ips) = (self_, result, resolved_ips);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.as_raw();
        let mut arg_resolved_ips = if arg_resolved_ips.is_null() {
            None
        } else {
            Some(arg_resolved_ips.into())
        };
        let arg_resolved_ips = arg_resolved_ips.as_mut();
        let result = ImplResolveCallback::on_resolve_completed(
            &arg_self_.interface,
            arg_result,
            arg_resolved_ips,
        );
    }
}
impl ImplResolveCallback for ResolveCallback {
    fn on_resolve_completed(&self, result: Errorcode, resolved_ips: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .on_resolve_completed
                .map(|f| {
                    let (arg_result, arg_resolved_ips) = (result, resolved_ips);
                    let arg_self_ = self.as_raw();
                    let arg_result = arg_result.as_raw();
                    let arg_resolved_ips = arg_resolved_ips
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_result, arg_resolved_ips);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_resolve_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_resolve_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResolveCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resolve_callback_t> for &ResolveCallback {
    fn as_raw(self) -> *mut _cef_resolve_callback_t {
        ImplResolveCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resolve_callback_t> for &mut ResolveCallback {
    fn as_raw(self) -> *mut _cef_resolve_callback_t {
        ImplResolveCallback::get_raw(self)
    }
}
impl ConvertReturnValue<ResolveCallback> for *mut _cef_resolve_callback_t {
    fn as_wrapper(self) -> ResolveCallback {
        ResolveCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resolve_callback_t> for ResolveCallback {
    fn into(self) -> *mut _cef_resolve_callback_t {
        let object = ImplResolveCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ResolveCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_request_context_t] for more documentation.
#[derive(Clone)]
pub struct RequestContext(RefGuard<_cef_request_context_t>);
impl RequestContext {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRequestContext,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRequestContext>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRequestContext>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_request_context_t).as_wrapper()
        }
    }
}
pub trait WrapRequestContext: ImplRequestContext {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_request_context_t, Self>);
}
pub trait ImplRequestContext: ImplPreferenceManager {
    fn is_same(&self, other: Option<&mut impl ImplRequestContext>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_sharing_with(
        &self,
        other: Option<&mut impl ImplRequestContext>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_global(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_handler(&self) -> Option<RequestContextHandler> {
        Default::default()
    }
    fn get_cache_path(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_cookie_manager(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<CookieManager> {
        Default::default()
    }
    fn register_scheme_handler_factory(
        &self,
        scheme_name: Option<&CefStringUtf16>,
        domain_name: Option<&CefStringUtf16>,
        factory: Option<&mut impl ImplSchemeHandlerFactory>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn clear_scheme_handler_factories(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn clear_certificate_exceptions(&self, callback: Option<&mut impl ImplCompletionCallback>) {}
    fn clear_http_auth_credentials(&self, callback: Option<&mut impl ImplCompletionCallback>) {}
    fn close_all_connections(&self, callback: Option<&mut impl ImplCompletionCallback>) {}
    fn resolve_host(
        &self,
        origin: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplResolveCallback>,
    ) {
    }
    fn get_media_router(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<MediaRouter> {
        Default::default()
    }
    fn get_website_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
    ) -> Option<Value> {
        Default::default()
    }
    fn set_website_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
        value: Option<&mut impl ImplValue>,
    ) {
    }
    fn get_content_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
    ) -> ContentSettingValues {
        Default::default()
    }
    fn set_content_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
        value: ContentSettingValues,
    ) {
    }
    fn set_chrome_color_scheme(&self, variant: ColorVariant, user_color: u32) {}
    fn get_chrome_color_scheme_mode(&self) -> ColorVariant {
        Default::default()
    }
    fn get_chrome_color_scheme_color(&self) -> cef_color_t {
        Default::default()
    }
    fn get_chrome_color_scheme_variant(&self) -> ColorVariant {
        Default::default()
    }
    fn init_methods(object: &mut _cef_request_context_t) {
        impl_cef_preference_manager_t::init_methods::<Self>(&mut object.base);
        impl_cef_request_context_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_request_context_t {
        <Self as ImplPreferenceManager>::get_raw(self) as *mut _
    }
}
mod impl_cef_request_context_t {
    use super::*;
    pub fn init_methods<I: ImplRequestContext>(object: &mut _cef_request_context_t) {
        object.is_same = Some(is_same::<I>);
        object.is_sharing_with = Some(is_sharing_with::<I>);
        object.is_global = Some(is_global::<I>);
        object.get_handler = Some(get_handler::<I>);
        object.get_cache_path = Some(get_cache_path::<I>);
        object.get_cookie_manager = Some(get_cookie_manager::<I>);
        object.register_scheme_handler_factory = Some(register_scheme_handler_factory::<I>);
        object.clear_scheme_handler_factories = Some(clear_scheme_handler_factories::<I>);
        object.clear_certificate_exceptions = Some(clear_certificate_exceptions::<I>);
        object.clear_http_auth_credentials = Some(clear_http_auth_credentials::<I>);
        object.close_all_connections = Some(close_all_connections::<I>);
        object.resolve_host = Some(resolve_host::<I>);
        object.get_media_router = Some(get_media_router::<I>);
        object.get_website_setting = Some(get_website_setting::<I>);
        object.set_website_setting = Some(set_website_setting::<I>);
        object.get_content_setting = Some(get_content_setting::<I>);
        object.set_content_setting = Some(set_content_setting::<I>);
        object.set_chrome_color_scheme = Some(set_chrome_color_scheme::<I>);
        object.get_chrome_color_scheme_mode = Some(get_chrome_color_scheme_mode::<I>);
        object.get_chrome_color_scheme_color = Some(get_chrome_color_scheme_color::<I>);
        object.get_chrome_color_scheme_variant = Some(get_chrome_color_scheme_variant::<I>);
    }
    extern "C" fn is_same<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        other: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_other) = (self_, other);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_other = unsafe { arg_other.as_mut() }
            .map(|arg| RequestContext(unsafe { RefGuard::from_raw(arg) }));
        let arg_other = arg_other.as_mut();
        let result = ImplRequestContext::is_same(&arg_self_.interface, arg_other);
        result.into()
    }
    extern "C" fn is_sharing_with<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        other: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_other) = (self_, other);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_other = unsafe { arg_other.as_mut() }
            .map(|arg| RequestContext(unsafe { RefGuard::from_raw(arg) }));
        let arg_other = arg_other.as_mut();
        let result = ImplRequestContext::is_sharing_with(&arg_self_.interface, arg_other);
        result.into()
    }
    extern "C" fn is_global<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequestContext::is_global(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_handler<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> *mut _cef_request_context_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequestContext::get_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_cache_path<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequestContext::get_cache_path(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_cookie_manager<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) -> *mut _cef_cookie_manager_t {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| CompletionCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplRequestContext::get_cookie_manager(&arg_self_.interface, arg_callback);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn register_scheme_handler_factory<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        scheme_name: *const _cef_string_utf16_t,
        domain_name: *const _cef_string_utf16_t,
        factory: *mut _cef_scheme_handler_factory_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scheme_name, arg_domain_name, arg_factory) =
            (self_, scheme_name, domain_name, factory);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scheme_name = if arg_scheme_name.is_null() {
            None
        } else {
            Some(arg_scheme_name.into())
        };
        let arg_scheme_name = arg_scheme_name.as_ref();
        let arg_domain_name = if arg_domain_name.is_null() {
            None
        } else {
            Some(arg_domain_name.into())
        };
        let arg_domain_name = arg_domain_name.as_ref();
        let mut arg_factory = unsafe { arg_factory.as_mut() }
            .map(|arg| SchemeHandlerFactory(unsafe { RefGuard::from_raw(arg) }));
        let arg_factory = arg_factory.as_mut();
        let result = ImplRequestContext::register_scheme_handler_factory(
            &arg_self_.interface,
            arg_scheme_name,
            arg_domain_name,
            arg_factory,
        );
        result.into()
    }
    extern "C" fn clear_scheme_handler_factories<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequestContext::clear_scheme_handler_factories(&arg_self_.interface);
        result.into()
    }
    extern "C" fn clear_certificate_exceptions<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| CompletionCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result =
            ImplRequestContext::clear_certificate_exceptions(&arg_self_.interface, arg_callback);
    }
    extern "C" fn clear_http_auth_credentials<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| CompletionCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result =
            ImplRequestContext::clear_http_auth_credentials(&arg_self_.interface, arg_callback);
    }
    extern "C" fn close_all_connections<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| CompletionCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplRequestContext::close_all_connections(&arg_self_.interface, arg_callback);
    }
    extern "C" fn resolve_host<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        origin: *const _cef_string_utf16_t,
        callback: *mut _cef_resolve_callback_t,
    ) {
        let (arg_self_, arg_origin, arg_callback) = (self_, origin, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_origin = if arg_origin.is_null() {
            None
        } else {
            Some(arg_origin.into())
        };
        let arg_origin = arg_origin.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| ResolveCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result =
            ImplRequestContext::resolve_host(&arg_self_.interface, arg_origin, arg_callback);
    }
    extern "C" fn get_media_router<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) -> *mut _cef_media_router_t {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| CompletionCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplRequestContext::get_media_router(&arg_self_.interface, arg_callback);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_website_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type) =
            (self_, requesting_url, top_level_url, content_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = if arg_requesting_url.is_null() {
            None
        } else {
            Some(arg_requesting_url.into())
        };
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = if arg_top_level_url.is_null() {
            None
        } else {
            Some(arg_top_level_url.into())
        };
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        let result = ImplRequestContext::get_website_setting(
            &arg_self_.interface,
            arg_requesting_url,
            arg_top_level_url,
            arg_content_type,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_website_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
            (self_, requesting_url, top_level_url, content_type, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = if arg_requesting_url.is_null() {
            None
        } else {
            Some(arg_requesting_url.into())
        };
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = if arg_top_level_url.is_null() {
            None
        } else {
            Some(arg_top_level_url.into())
        };
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplRequestContext::set_website_setting(
            &arg_self_.interface,
            arg_requesting_url,
            arg_top_level_url,
            arg_content_type,
            arg_value,
        );
    }
    extern "C" fn get_content_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
    ) -> cef_content_setting_values_t {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type) =
            (self_, requesting_url, top_level_url, content_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = if arg_requesting_url.is_null() {
            None
        } else {
            Some(arg_requesting_url.into())
        };
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = if arg_top_level_url.is_null() {
            None
        } else {
            Some(arg_top_level_url.into())
        };
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        let result = ImplRequestContext::get_content_setting(
            &arg_self_.interface,
            arg_requesting_url,
            arg_top_level_url,
            arg_content_type,
        );
        result.into()
    }
    extern "C" fn set_content_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
        value: cef_content_setting_values_t,
    ) {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
            (self_, requesting_url, top_level_url, content_type, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = if arg_requesting_url.is_null() {
            None
        } else {
            Some(arg_requesting_url.into())
        };
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = if arg_top_level_url.is_null() {
            None
        } else {
            Some(arg_top_level_url.into())
        };
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        let arg_value = arg_value.as_raw();
        let result = ImplRequestContext::set_content_setting(
            &arg_self_.interface,
            arg_requesting_url,
            arg_top_level_url,
            arg_content_type,
            arg_value,
        );
    }
    extern "C" fn set_chrome_color_scheme<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        variant: cef_color_variant_t,
        user_color: u32,
    ) {
        let (arg_self_, arg_variant, arg_user_color) = (self_, variant, user_color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_variant = arg_variant.as_raw();
        let arg_user_color = arg_user_color.as_raw();
        let result = ImplRequestContext::set_chrome_color_scheme(
            &arg_self_.interface,
            arg_variant,
            arg_user_color,
        );
    }
    extern "C" fn get_chrome_color_scheme_mode<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> cef_color_variant_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequestContext::get_chrome_color_scheme_mode(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_chrome_color_scheme_color<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequestContext::get_chrome_color_scheme_color(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_chrome_color_scheme_variant<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> cef_color_variant_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRequestContext::get_chrome_color_scheme_variant(&arg_self_.interface);
        result.into()
    }
}
impl ImplPreferenceManager for RequestContext {
    fn has_preference(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .has_preference(name)
    }
    fn get_preference(&self, name: Option<&CefStringUtf16>) -> Option<Value> {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .get_preference(name)
    }
    fn get_all_preferences(
        &self,
        include_defaults: ::std::os::raw::c_int,
    ) -> Option<DictionaryValue> {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .get_all_preferences(include_defaults)
    }
    fn can_set_preference(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .can_set_preference(name)
    }
    fn set_preference(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplValue>,
        error: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .set_preference(name, value, error)
    }
    fn get_raw(&self) -> *mut _cef_preference_manager_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplRequestContext for RequestContext {
    fn is_same(&self, other: Option<&mut impl ImplRequestContext>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_other = other;
                    let arg_self_ = self.as_raw();
                    let arg_other = arg_other
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequestContext::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_other);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_sharing_with(
        &self,
        other: Option<&mut impl ImplRequestContext>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_sharing_with
                .map(|f| {
                    let arg_other = other;
                    let arg_self_ = self.as_raw();
                    let arg_other = arg_other
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequestContext::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_other);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_global(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_global
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_handler(&self) -> Option<RequestContextHandler> {
        unsafe {
            self.0
                .get_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_cache_path(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_cache_path
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_cookie_manager(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<CookieManager> {
        unsafe {
            self.0
                .get_cookie_manager
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn register_scheme_handler_factory(
        &self,
        scheme_name: Option<&CefStringUtf16>,
        domain_name: Option<&CefStringUtf16>,
        factory: Option<&mut impl ImplSchemeHandlerFactory>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .register_scheme_handler_factory
                .map(|f| {
                    let (arg_scheme_name, arg_domain_name, arg_factory) =
                        (scheme_name, domain_name, factory);
                    let arg_self_ = self.as_raw();
                    let arg_scheme_name = arg_scheme_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_domain_name = arg_domain_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_factory = arg_factory
                        .map(|arg| {
                            arg.add_ref();
                            ImplSchemeHandlerFactory::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_scheme_name, arg_domain_name, arg_factory);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn clear_scheme_handler_factories(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear_scheme_handler_factories
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn clear_certificate_exceptions(&self, callback: Option<&mut impl ImplCompletionCallback>) {
        unsafe {
            self.0
                .clear_certificate_exceptions
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_http_auth_credentials(&self, callback: Option<&mut impl ImplCompletionCallback>) {
        unsafe {
            self.0
                .clear_http_auth_credentials
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn close_all_connections(&self, callback: Option<&mut impl ImplCompletionCallback>) {
        unsafe {
            self.0
                .close_all_connections
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn resolve_host(
        &self,
        origin: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplResolveCallback>,
    ) {
        unsafe {
            self.0
                .resolve_host
                .map(|f| {
                    let (arg_origin, arg_callback) = (origin, callback);
                    let arg_self_ = self.as_raw();
                    let arg_origin = arg_origin
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplResolveCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_origin, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_media_router(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<MediaRouter> {
        unsafe {
            self.0
                .get_media_router
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_website_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
    ) -> Option<Value> {
        unsafe {
            self.0
                .get_website_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type) =
                        (requesting_url, top_level_url, content_type);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_top_level_url = arg_top_level_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_content_type = arg_content_type.as_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_website_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
        value: Option<&mut impl ImplValue>,
    ) {
        unsafe {
            self.0
                .set_website_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
                        (requesting_url, top_level_url, content_type, value);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_top_level_url = arg_top_level_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_content_type = arg_content_type.as_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                        arg_value,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_content_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
    ) -> ContentSettingValues {
        unsafe {
            self.0
                .get_content_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type) =
                        (requesting_url, top_level_url, content_type);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_top_level_url = arg_top_level_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_content_type = arg_content_type.as_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_content_setting(
        &self,
        requesting_url: Option<&CefStringUtf16>,
        top_level_url: Option<&CefStringUtf16>,
        content_type: ContentSettingTypes,
        value: ContentSettingValues,
    ) {
        unsafe {
            self.0
                .set_content_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
                        (requesting_url, top_level_url, content_type, value);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_top_level_url = arg_top_level_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_content_type = arg_content_type.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                        arg_value,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_chrome_color_scheme(&self, variant: ColorVariant, user_color: u32) {
        unsafe {
            self.0
                .set_chrome_color_scheme
                .map(|f| {
                    let (arg_variant, arg_user_color) = (variant, user_color);
                    let arg_self_ = self.as_raw();
                    let arg_variant = arg_variant.as_raw();
                    let arg_user_color = arg_user_color;
                    let result = f(arg_self_, arg_variant, arg_user_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_chrome_color_scheme_mode(&self) -> ColorVariant {
        unsafe {
            self.0
                .get_chrome_color_scheme_mode
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_chrome_color_scheme_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_chrome_color_scheme_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_chrome_color_scheme_variant(&self) -> ColorVariant {
        unsafe {
            self.0
                .get_chrome_color_scheme_variant
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_request_context_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_request_context_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestContext {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_context_t> for &RequestContext {
    fn as_raw(self) -> *mut _cef_request_context_t {
        ImplRequestContext::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_context_t> for &mut RequestContext {
    fn as_raw(self) -> *mut _cef_request_context_t {
        ImplRequestContext::get_raw(self)
    }
}
impl ConvertReturnValue<RequestContext> for *mut _cef_request_context_t {
    fn as_wrapper(self) -> RequestContext {
        RequestContext(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_context_t> for RequestContext {
    fn into(self) -> *mut _cef_request_context_t {
        let object = ImplRequestContext::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RequestContext {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_browser_t] for more documentation.
#[derive(Clone)]
pub struct Browser(RefGuard<_cef_browser_t>);
impl Browser {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBrowser,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBrowser>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBrowser>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_browser_t).as_wrapper()
        }
    }
}
pub trait WrapBrowser: ImplBrowser {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_browser_t, Self>);
}
pub trait ImplBrowser: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_host(&self) -> Option<BrowserHost> {
        Default::default()
    }
    fn can_go_back(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn go_back(&self) {}
    fn can_go_forward(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn go_forward(&self) {}
    fn is_loading(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn reload(&self) {}
    fn reload_ignore_cache(&self) {}
    fn stop_load(&self) {}
    fn get_identifier(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplBrowser>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_popup(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_document(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_main_frame(&self) -> Option<Frame> {
        Default::default()
    }
    fn get_focused_frame(&self) -> Option<Frame> {
        Default::default()
    }
    fn get_frame_by_identifier(&self, identifier: Option<&CefStringUtf16>) -> Option<Frame> {
        Default::default()
    }
    fn get_frame_by_name(&self, name: Option<&CefStringUtf16>) -> Option<Frame> {
        Default::default()
    }
    fn get_frame_count(&self) -> usize {
        Default::default()
    }
    fn get_frame_identifiers(&self, identifiers: Option<&mut CefStringList>) {}
    fn get_frame_names(&self, names: Option<&mut CefStringList>) {}
    fn init_methods(object: &mut _cef_browser_t) {
        impl_cef_browser_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_browser_t;
}
mod impl_cef_browser_t {
    use super::*;
    pub fn init_methods<I: ImplBrowser>(object: &mut _cef_browser_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_host = Some(get_host::<I>);
        object.can_go_back = Some(can_go_back::<I>);
        object.go_back = Some(go_back::<I>);
        object.can_go_forward = Some(can_go_forward::<I>);
        object.go_forward = Some(go_forward::<I>);
        object.is_loading = Some(is_loading::<I>);
        object.reload = Some(reload::<I>);
        object.reload_ignore_cache = Some(reload_ignore_cache::<I>);
        object.stop_load = Some(stop_load::<I>);
        object.get_identifier = Some(get_identifier::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_popup = Some(is_popup::<I>);
        object.has_document = Some(has_document::<I>);
        object.get_main_frame = Some(get_main_frame::<I>);
        object.get_focused_frame = Some(get_focused_frame::<I>);
        object.get_frame_by_identifier = Some(get_frame_by_identifier::<I>);
        object.get_frame_by_name = Some(get_frame_by_name::<I>);
        object.get_frame_count = Some(get_frame_count::<I>);
        object.get_frame_identifiers = Some(get_frame_identifiers::<I>);
        object.get_frame_names = Some(get_frame_names::<I>);
    }
    extern "C" fn is_valid<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_host<I: ImplBrowser>(self_: *mut _cef_browser_t) -> *mut _cef_browser_host_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::get_host(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn can_go_back<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::can_go_back(&arg_self_.interface);
        result.into()
    }
    extern "C" fn go_back<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::go_back(&arg_self_.interface);
    }
    extern "C" fn can_go_forward<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::can_go_forward(&arg_self_.interface);
        result.into()
    }
    extern "C" fn go_forward<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::go_forward(&arg_self_.interface);
    }
    extern "C" fn is_loading<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::is_loading(&arg_self_.interface);
        result.into()
    }
    extern "C" fn reload<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::reload(&arg_self_.interface);
    }
    extern "C" fn reload_ignore_cache<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::reload_ignore_cache(&arg_self_.interface);
    }
    extern "C" fn stop_load<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::stop_load(&arg_self_.interface);
    }
    extern "C" fn get_identifier<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::get_identifier(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        that: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplBrowser::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn is_popup<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::is_popup(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_document<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::has_document(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_main_frame<I: ImplBrowser>(self_: *mut _cef_browser_t) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::get_main_frame(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_focused_frame<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::get_focused_frame(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame_by_identifier<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        identifier: *const _cef_string_utf16_t,
    ) -> *mut _cef_frame_t {
        let (arg_self_, arg_identifier) = (self_, identifier);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_identifier = if arg_identifier.is_null() {
            None
        } else {
            Some(arg_identifier.into())
        };
        let arg_identifier = arg_identifier.as_ref();
        let result = ImplBrowser::get_frame_by_identifier(&arg_self_.interface, arg_identifier);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame_by_name<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_frame_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplBrowser::get_frame_by_name(&arg_self_.interface, arg_name);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame_count<I: ImplBrowser>(self_: *mut _cef_browser_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowser::get_frame_count(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_frame_identifiers<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        identifiers: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_identifiers) = (self_, identifiers);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_identifiers = if arg_identifiers.is_null() {
            None
        } else {
            Some(arg_identifiers.into())
        };
        let arg_identifiers = arg_identifiers.as_mut();
        let result = ImplBrowser::get_frame_identifiers(&arg_self_.interface, arg_identifiers);
    }
    extern "C" fn get_frame_names<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        names: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = if arg_names.is_null() {
            None
        } else {
            Some(arg_names.into())
        };
        let arg_names = arg_names.as_mut();
        let result = ImplBrowser::get_frame_names(&arg_self_.interface, arg_names);
    }
}
impl ImplBrowser for Browser {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_host(&self) -> Option<BrowserHost> {
        unsafe {
            self.0
                .get_host
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn can_go_back(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_go_back
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn go_back(&self) {
        unsafe {
            self.0
                .go_back
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_go_forward(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_go_forward
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn go_forward(&self) {
        unsafe {
            self.0
                .go_forward
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_loading(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_loading
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn reload(&self) {
        unsafe {
            self.0
                .reload
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reload_ignore_cache(&self) {
        unsafe {
            self.0
                .reload_ignore_cache
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn stop_load(&self) {
        unsafe {
            self.0
                .stop_load
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_identifier(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplBrowser>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_popup(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_popup
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_document(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_document
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_main_frame(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_main_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_focused_frame(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_focused_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_by_identifier(&self, identifier: Option<&CefStringUtf16>) -> Option<Frame> {
        unsafe {
            self.0
                .get_frame_by_identifier
                .map(|f| {
                    let arg_identifier = identifier;
                    let arg_self_ = self.as_raw();
                    let arg_identifier = arg_identifier
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_identifier);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_by_name(&self, name: Option<&CefStringUtf16>) -> Option<Frame> {
        unsafe {
            self.0
                .get_frame_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_count(&self) -> usize {
        unsafe {
            self.0
                .get_frame_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_identifiers(&self, identifiers: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .get_frame_identifiers
                .map(|f| {
                    let arg_identifiers = identifiers;
                    let arg_self_ = self.as_raw();
                    let arg_identifiers = arg_identifiers
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_identifiers);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_names(&self, names: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .get_frame_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_browser_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Browser {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_t> for &Browser {
    fn as_raw(self) -> *mut _cef_browser_t {
        ImplBrowser::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_t> for &mut Browser {
    fn as_raw(self) -> *mut _cef_browser_t {
        ImplBrowser::get_raw(self)
    }
}
impl ConvertReturnValue<Browser> for *mut _cef_browser_t {
    fn as_wrapper(self) -> Browser {
        Browser(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_t> for Browser {
    fn into(self) -> *mut _cef_browser_t {
        let object = ImplBrowser::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Browser {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_run_file_dialog_callback_t] for more documentation.
#[derive(Clone)]
pub struct RunFileDialogCallback(RefGuard<_cef_run_file_dialog_callback_t>);
impl RunFileDialogCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRunFileDialogCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRunFileDialogCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRunFileDialogCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_run_file_dialog_callback_t).as_wrapper()
        }
    }
}
pub trait WrapRunFileDialogCallback: ImplRunFileDialogCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_run_file_dialog_callback_t, Self>);
}
pub trait ImplRunFileDialogCallback: Clone + Sized + Rc {
    fn on_file_dialog_dismissed(&self, file_paths: Option<&mut CefStringList>) {}
    fn init_methods(object: &mut _cef_run_file_dialog_callback_t) {
        impl_cef_run_file_dialog_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_run_file_dialog_callback_t;
}
mod impl_cef_run_file_dialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplRunFileDialogCallback>(
        object: &mut _cef_run_file_dialog_callback_t,
    ) {
        object.on_file_dialog_dismissed = Some(on_file_dialog_dismissed::<I>);
    }
    extern "C" fn on_file_dialog_dismissed<I: ImplRunFileDialogCallback>(
        self_: *mut _cef_run_file_dialog_callback_t,
        file_paths: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_file_paths) = (self_, file_paths);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_file_paths = if arg_file_paths.is_null() {
            None
        } else {
            Some(arg_file_paths.into())
        };
        let arg_file_paths = arg_file_paths.as_mut();
        let result = ImplRunFileDialogCallback::on_file_dialog_dismissed(
            &arg_self_.interface,
            arg_file_paths,
        );
    }
}
impl ImplRunFileDialogCallback for RunFileDialogCallback {
    fn on_file_dialog_dismissed(&self, file_paths: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .on_file_dialog_dismissed
                .map(|f| {
                    let arg_file_paths = file_paths;
                    let arg_self_ = self.as_raw();
                    let arg_file_paths = arg_file_paths
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_file_paths);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_run_file_dialog_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_run_file_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunFileDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_file_dialog_callback_t> for &RunFileDialogCallback {
    fn as_raw(self) -> *mut _cef_run_file_dialog_callback_t {
        ImplRunFileDialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_run_file_dialog_callback_t> for &mut RunFileDialogCallback {
    fn as_raw(self) -> *mut _cef_run_file_dialog_callback_t {
        ImplRunFileDialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<RunFileDialogCallback> for *mut _cef_run_file_dialog_callback_t {
    fn as_wrapper(self) -> RunFileDialogCallback {
        RunFileDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_run_file_dialog_callback_t> for RunFileDialogCallback {
    fn into(self) -> *mut _cef_run_file_dialog_callback_t {
        let object = ImplRunFileDialogCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RunFileDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_navigation_entry_visitor_t] for more documentation.
#[derive(Clone)]
pub struct NavigationEntryVisitor(RefGuard<_cef_navigation_entry_visitor_t>);
impl NavigationEntryVisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapNavigationEntryVisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplNavigationEntryVisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapNavigationEntryVisitor>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_navigation_entry_visitor_t).as_wrapper()
        }
    }
}
pub trait WrapNavigationEntryVisitor: ImplNavigationEntryVisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_navigation_entry_visitor_t, Self>);
}
pub trait ImplNavigationEntryVisitor: Clone + Sized + Rc {
    fn visit(
        &self,
        entry: Option<&mut impl ImplNavigationEntry>,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_navigation_entry_visitor_t) {
        impl_cef_navigation_entry_visitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_navigation_entry_visitor_t;
}
mod impl_cef_navigation_entry_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplNavigationEntryVisitor>(
        object: &mut _cef_navigation_entry_visitor_t,
    ) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplNavigationEntryVisitor>(
        self_: *mut _cef_navigation_entry_visitor_t,
        entry: *mut _cef_navigation_entry_t,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_entry, arg_current, arg_index, arg_total) =
            (self_, entry, current, index, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_entry = unsafe { arg_entry.as_mut() }
            .map(|arg| NavigationEntry(unsafe { RefGuard::from_raw(arg) }));
        let arg_entry = arg_entry.as_mut();
        let arg_current = arg_current.as_raw();
        let arg_index = arg_index.as_raw();
        let arg_total = arg_total.as_raw();
        let result = ImplNavigationEntryVisitor::visit(
            &arg_self_.interface,
            arg_entry,
            arg_current,
            arg_index,
            arg_total,
        );
        result.into()
    }
}
impl ImplNavigationEntryVisitor for NavigationEntryVisitor {
    fn visit(
        &self,
        entry: Option<&mut impl ImplNavigationEntry>,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let (arg_entry, arg_current, arg_index, arg_total) =
                        (entry, current, index, total);
                    let arg_self_ = self.as_raw();
                    let arg_entry = arg_entry
                        .map(|arg| {
                            arg.add_ref();
                            ImplNavigationEntry::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_current = arg_current;
                    let arg_index = arg_index;
                    let arg_total = arg_total;
                    let result = f(arg_self_, arg_entry, arg_current, arg_index, arg_total);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_navigation_entry_visitor_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_navigation_entry_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for NavigationEntryVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_navigation_entry_visitor_t> for &NavigationEntryVisitor {
    fn as_raw(self) -> *mut _cef_navigation_entry_visitor_t {
        ImplNavigationEntryVisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_navigation_entry_visitor_t> for &mut NavigationEntryVisitor {
    fn as_raw(self) -> *mut _cef_navigation_entry_visitor_t {
        ImplNavigationEntryVisitor::get_raw(self)
    }
}
impl ConvertReturnValue<NavigationEntryVisitor> for *mut _cef_navigation_entry_visitor_t {
    fn as_wrapper(self) -> NavigationEntryVisitor {
        NavigationEntryVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_navigation_entry_visitor_t> for NavigationEntryVisitor {
    fn into(self) -> *mut _cef_navigation_entry_visitor_t {
        let object = ImplNavigationEntryVisitor::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for NavigationEntryVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_pdf_print_callback_t] for more documentation.
#[derive(Clone)]
pub struct PdfPrintCallback(RefGuard<_cef_pdf_print_callback_t>);
impl PdfPrintCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPdfPrintCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPdfPrintCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPdfPrintCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_pdf_print_callback_t).as_wrapper()
        }
    }
}
pub trait WrapPdfPrintCallback: ImplPdfPrintCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_pdf_print_callback_t, Self>);
}
pub trait ImplPdfPrintCallback: Clone + Sized + Rc {
    fn on_pdf_print_finished(&self, path: Option<&CefStringUtf16>, ok: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_pdf_print_callback_t) {
        impl_cef_pdf_print_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_pdf_print_callback_t;
}
mod impl_cef_pdf_print_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPdfPrintCallback>(object: &mut _cef_pdf_print_callback_t) {
        object.on_pdf_print_finished = Some(on_pdf_print_finished::<I>);
    }
    extern "C" fn on_pdf_print_finished<I: ImplPdfPrintCallback>(
        self_: *mut _cef_pdf_print_callback_t,
        path: *const _cef_string_utf16_t,
        ok: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_path, arg_ok) = (self_, path, ok);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_path = if arg_path.is_null() {
            None
        } else {
            Some(arg_path.into())
        };
        let arg_path = arg_path.as_ref();
        let arg_ok = arg_ok.as_raw();
        let result =
            ImplPdfPrintCallback::on_pdf_print_finished(&arg_self_.interface, arg_path, arg_ok);
    }
}
impl ImplPdfPrintCallback for PdfPrintCallback {
    fn on_pdf_print_finished(&self, path: Option<&CefStringUtf16>, ok: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_pdf_print_finished
                .map(|f| {
                    let (arg_path, arg_ok) = (path, ok);
                    let arg_self_ = self.as_raw();
                    let arg_path = arg_path.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_ok = arg_ok;
                    let result = f(arg_self_, arg_path, arg_ok);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_pdf_print_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_pdf_print_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PdfPrintCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_pdf_print_callback_t> for &PdfPrintCallback {
    fn as_raw(self) -> *mut _cef_pdf_print_callback_t {
        ImplPdfPrintCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_pdf_print_callback_t> for &mut PdfPrintCallback {
    fn as_raw(self) -> *mut _cef_pdf_print_callback_t {
        ImplPdfPrintCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PdfPrintCallback> for *mut _cef_pdf_print_callback_t {
    fn as_wrapper(self) -> PdfPrintCallback {
        PdfPrintCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_pdf_print_callback_t> for PdfPrintCallback {
    fn into(self) -> *mut _cef_pdf_print_callback_t {
        let object = ImplPdfPrintCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PdfPrintCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_download_image_callback_t] for more documentation.
#[derive(Clone)]
pub struct DownloadImageCallback(RefGuard<_cef_download_image_callback_t>);
impl DownloadImageCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDownloadImageCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDownloadImageCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDownloadImageCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_download_image_callback_t).as_wrapper()
        }
    }
}
pub trait WrapDownloadImageCallback: ImplDownloadImageCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_download_image_callback_t, Self>);
}
pub trait ImplDownloadImageCallback: Clone + Sized + Rc {
    fn on_download_image_finished(
        &self,
        image_url: Option<&CefStringUtf16>,
        http_status_code: ::std::os::raw::c_int,
        image: Option<&mut impl ImplImage>,
    ) {
    }
    fn init_methods(object: &mut _cef_download_image_callback_t) {
        impl_cef_download_image_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_download_image_callback_t;
}
mod impl_cef_download_image_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadImageCallback>(object: &mut _cef_download_image_callback_t) {
        object.on_download_image_finished = Some(on_download_image_finished::<I>);
    }
    extern "C" fn on_download_image_finished<I: ImplDownloadImageCallback>(
        self_: *mut _cef_download_image_callback_t,
        image_url: *const _cef_string_utf16_t,
        http_status_code: ::std::os::raw::c_int,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_image_url, arg_http_status_code, arg_image) =
            (self_, image_url, http_status_code, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_image_url = if arg_image_url.is_null() {
            None
        } else {
            Some(arg_image_url.into())
        };
        let arg_image_url = arg_image_url.as_ref();
        let arg_http_status_code = arg_http_status_code.as_raw();
        let mut arg_image =
            unsafe { arg_image.as_mut() }.map(|arg| Image(unsafe { RefGuard::from_raw(arg) }));
        let arg_image = arg_image.as_mut();
        let result = ImplDownloadImageCallback::on_download_image_finished(
            &arg_self_.interface,
            arg_image_url,
            arg_http_status_code,
            arg_image,
        );
    }
}
impl ImplDownloadImageCallback for DownloadImageCallback {
    fn on_download_image_finished(
        &self,
        image_url: Option<&CefStringUtf16>,
        http_status_code: ::std::os::raw::c_int,
        image: Option<&mut impl ImplImage>,
    ) {
        unsafe {
            self.0
                .on_download_image_finished
                .map(|f| {
                    let (arg_image_url, arg_http_status_code, arg_image) =
                        (image_url, http_status_code, image);
                    let arg_self_ = self.as_raw();
                    let arg_image_url = arg_image_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_http_status_code = arg_http_status_code;
                    let arg_image = arg_image
                        .map(|arg| {
                            arg.add_ref();
                            ImplImage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_image_url, arg_http_status_code, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_download_image_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_download_image_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadImageCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_image_callback_t> for &DownloadImageCallback {
    fn as_raw(self) -> *mut _cef_download_image_callback_t {
        ImplDownloadImageCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_image_callback_t> for &mut DownloadImageCallback {
    fn as_raw(self) -> *mut _cef_download_image_callback_t {
        ImplDownloadImageCallback::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadImageCallback> for *mut _cef_download_image_callback_t {
    fn as_wrapper(self) -> DownloadImageCallback {
        DownloadImageCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_image_callback_t> for DownloadImageCallback {
    fn into(self) -> *mut _cef_download_image_callback_t {
        let object = ImplDownloadImageCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DownloadImageCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_browser_host_t] for more documentation.
#[derive(Clone)]
pub struct BrowserHost(RefGuard<_cef_browser_host_t>);
impl BrowserHost {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBrowserHost,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBrowserHost>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBrowserHost>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_browser_host_t).as_wrapper()
        }
    }
}
pub trait WrapBrowserHost: ImplBrowserHost {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_browser_host_t, Self>);
}
pub trait ImplBrowserHost: Clone + Sized + Rc {
    fn get_browser(&self) -> Option<Browser> {
        Default::default()
    }
    fn close_browser(&self, force_close: ::std::os::raw::c_int) {}
    fn try_close_browser(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_ready_to_be_closed(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_focus(&self, focus: ::std::os::raw::c_int) {}
    fn get_window_handle(&self) -> ::std::os::raw::c_ulong {
        Default::default()
    }
    fn get_opener_window_handle(&self) -> ::std::os::raw::c_ulong {
        Default::default()
    }
    fn get_opener_identifier(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_view(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_client(&self) -> Option<Client> {
        Default::default()
    }
    fn get_request_context(&self) -> Option<RequestContext> {
        Default::default()
    }
    fn can_zoom(&self, command: ZoomCommand) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn zoom(&self, command: ZoomCommand) {}
    fn get_default_zoom_level(&self) -> f64 {
        Default::default()
    }
    fn get_zoom_level(&self) -> f64 {
        Default::default()
    }
    fn set_zoom_level(&self, zoom_level: f64) {}
    fn run_file_dialog(
        &self,
        mode: FileDialogMode,
        title: Option<&CefStringUtf16>,
        default_file_path: Option<&CefStringUtf16>,
        accept_filters: Option<&mut CefStringList>,
        callback: Option<&mut impl ImplRunFileDialogCallback>,
    ) {
    }
    fn start_download(&self, url: Option<&CefStringUtf16>) {}
    fn download_image(
        &self,
        image_url: Option<&CefStringUtf16>,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplDownloadImageCallback>,
    ) {
    }
    fn print(&self) {}
    fn print_to_pdf(
        &self,
        path: Option<&CefStringUtf16>,
        settings: Option<&PdfPrintSettings>,
        callback: Option<&mut impl ImplPdfPrintCallback>,
    ) {
    }
    fn find(
        &self,
        search_text: Option<&CefStringUtf16>,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    ) {
    }
    fn stop_finding(&self, clear_selection: ::std::os::raw::c_int) {}
    fn show_dev_tools(
        &self,
        window_info: Option<&WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&BrowserSettings>,
        inspect_element_at: Option<&Point>,
    ) {
    }
    fn close_dev_tools(&self) {}
    fn has_dev_tools(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn send_dev_tools_message(&self, message: Option<&[u8]>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn execute_dev_tools_method(
        &self,
        message_id: ::std::os::raw::c_int,
        method: Option<&CefStringUtf16>,
        params: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_dev_tools_message_observer(
        &self,
        observer: Option<&mut impl ImplDevToolsMessageObserver>,
    ) -> Option<Registration> {
        Default::default()
    }
    fn get_navigation_entries(
        &self,
        visitor: Option<&mut impl ImplNavigationEntryVisitor>,
        current_only: ::std::os::raw::c_int,
    ) {
    }
    fn replace_misspelling(&self, word: Option<&CefStringUtf16>) {}
    fn add_word_to_dictionary(&self, word: Option<&CefStringUtf16>) {}
    fn is_window_rendering_disabled(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn was_resized(&self) {}
    fn was_hidden(&self, hidden: ::std::os::raw::c_int) {}
    fn notify_screen_info_changed(&self) {}
    fn invalidate(&self, type_: PaintElementType) {}
    fn send_external_begin_frame(&self) {}
    fn send_key_event(&self, event: Option<&KeyEvent>) {}
    fn send_mouse_click_event(
        &self,
        event: Option<&MouseEvent>,
        type_: MouseButtonType,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    ) {
    }
    fn send_mouse_move_event(
        &self,
        event: Option<&MouseEvent>,
        mouse_leave: ::std::os::raw::c_int,
    ) {
    }
    fn send_mouse_wheel_event(
        &self,
        event: Option<&MouseEvent>,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) {
    }
    fn send_touch_event(&self, event: Option<&TouchEvent>) {}
    fn send_capture_lost_event(&self) {}
    fn notify_move_or_resize_started(&self) {}
    fn get_windowless_frame_rate(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_windowless_frame_rate(&self, frame_rate: ::std::os::raw::c_int) {}
    fn ime_set_composition(
        &self,
        text: Option<&CefStringUtf16>,
        underlines_count: usize,
        underlines: Option<&CompositionUnderline>,
        replacement_range: Option<&Range>,
        selection_range: Option<&Range>,
    ) {
    }
    fn ime_commit_text(
        &self,
        text: Option<&CefStringUtf16>,
        replacement_range: Option<&Range>,
        relative_cursor_pos: ::std::os::raw::c_int,
    ) {
    }
    fn ime_finish_composing_text(&self, keep_selection: ::std::os::raw::c_int) {}
    fn ime_cancel_composition(&self) {}
    fn drag_target_drag_enter(
        &self,
        drag_data: Option<&mut impl ImplDragData>,
        event: Option<&MouseEvent>,
        allowed_ops: DragOperationsMask,
    ) {
    }
    fn drag_target_drag_over(&self, event: Option<&MouseEvent>, allowed_ops: DragOperationsMask) {}
    fn drag_target_drag_leave(&self) {}
    fn drag_target_drop(&self, event: Option<&MouseEvent>) {}
    fn drag_source_ended_at(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: DragOperationsMask,
    ) {
    }
    fn drag_source_system_drag_ended(&self) {}
    fn get_visible_navigation_entry(&self) -> Option<NavigationEntry> {
        Default::default()
    }
    fn set_accessibility_state(&self, accessibility_state: State) {}
    fn set_auto_resize_enabled(
        &self,
        enabled: ::std::os::raw::c_int,
        min_size: Option<&Size>,
        max_size: Option<&Size>,
    ) {
    }
    fn set_audio_muted(&self, mute: ::std::os::raw::c_int) {}
    fn is_audio_muted(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_fullscreen(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn exit_fullscreen(&self, will_cause_resize: ::std::os::raw::c_int) {}
    fn can_execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) {
    }
    fn is_render_process_unresponsive(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_runtime_style(&self) -> RuntimeStyle {
        Default::default()
    }
    fn init_methods(object: &mut _cef_browser_host_t) {
        impl_cef_browser_host_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_browser_host_t;
}
mod impl_cef_browser_host_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserHost>(object: &mut _cef_browser_host_t) {
        object.get_browser = Some(get_browser::<I>);
        object.close_browser = Some(close_browser::<I>);
        object.try_close_browser = Some(try_close_browser::<I>);
        object.is_ready_to_be_closed = Some(is_ready_to_be_closed::<I>);
        object.set_focus = Some(set_focus::<I>);
        object.get_window_handle = Some(get_window_handle::<I>);
        object.get_opener_window_handle = Some(get_opener_window_handle::<I>);
        object.get_opener_identifier = Some(get_opener_identifier::<I>);
        object.has_view = Some(has_view::<I>);
        object.get_client = Some(get_client::<I>);
        object.get_request_context = Some(get_request_context::<I>);
        object.can_zoom = Some(can_zoom::<I>);
        object.zoom = Some(zoom::<I>);
        object.get_default_zoom_level = Some(get_default_zoom_level::<I>);
        object.get_zoom_level = Some(get_zoom_level::<I>);
        object.set_zoom_level = Some(set_zoom_level::<I>);
        object.run_file_dialog = Some(run_file_dialog::<I>);
        object.start_download = Some(start_download::<I>);
        object.download_image = Some(download_image::<I>);
        object.print = Some(print::<I>);
        object.print_to_pdf = Some(print_to_pdf::<I>);
        object.find = Some(find::<I>);
        object.stop_finding = Some(stop_finding::<I>);
        object.show_dev_tools = Some(show_dev_tools::<I>);
        object.close_dev_tools = Some(close_dev_tools::<I>);
        object.has_dev_tools = Some(has_dev_tools::<I>);
        object.send_dev_tools_message = Some(send_dev_tools_message::<I>);
        object.execute_dev_tools_method = Some(execute_dev_tools_method::<I>);
        object.add_dev_tools_message_observer = Some(add_dev_tools_message_observer::<I>);
        object.get_navigation_entries = Some(get_navigation_entries::<I>);
        object.replace_misspelling = Some(replace_misspelling::<I>);
        object.add_word_to_dictionary = Some(add_word_to_dictionary::<I>);
        object.is_window_rendering_disabled = Some(is_window_rendering_disabled::<I>);
        object.was_resized = Some(was_resized::<I>);
        object.was_hidden = Some(was_hidden::<I>);
        object.notify_screen_info_changed = Some(notify_screen_info_changed::<I>);
        object.invalidate = Some(invalidate::<I>);
        object.send_external_begin_frame = Some(send_external_begin_frame::<I>);
        object.send_key_event = Some(send_key_event::<I>);
        object.send_mouse_click_event = Some(send_mouse_click_event::<I>);
        object.send_mouse_move_event = Some(send_mouse_move_event::<I>);
        object.send_mouse_wheel_event = Some(send_mouse_wheel_event::<I>);
        object.send_touch_event = Some(send_touch_event::<I>);
        object.send_capture_lost_event = Some(send_capture_lost_event::<I>);
        object.notify_move_or_resize_started = Some(notify_move_or_resize_started::<I>);
        object.get_windowless_frame_rate = Some(get_windowless_frame_rate::<I>);
        object.set_windowless_frame_rate = Some(set_windowless_frame_rate::<I>);
        object.ime_set_composition = Some(ime_set_composition::<I>);
        object.ime_commit_text = Some(ime_commit_text::<I>);
        object.ime_finish_composing_text = Some(ime_finish_composing_text::<I>);
        object.ime_cancel_composition = Some(ime_cancel_composition::<I>);
        object.drag_target_drag_enter = Some(drag_target_drag_enter::<I>);
        object.drag_target_drag_over = Some(drag_target_drag_over::<I>);
        object.drag_target_drag_leave = Some(drag_target_drag_leave::<I>);
        object.drag_target_drop = Some(drag_target_drop::<I>);
        object.drag_source_ended_at = Some(drag_source_ended_at::<I>);
        object.drag_source_system_drag_ended = Some(drag_source_system_drag_ended::<I>);
        object.get_visible_navigation_entry = Some(get_visible_navigation_entry::<I>);
        object.set_accessibility_state = Some(set_accessibility_state::<I>);
        object.set_auto_resize_enabled = Some(set_auto_resize_enabled::<I>);
        object.set_audio_muted = Some(set_audio_muted::<I>);
        object.is_audio_muted = Some(is_audio_muted::<I>);
        object.is_fullscreen = Some(is_fullscreen::<I>);
        object.exit_fullscreen = Some(exit_fullscreen::<I>);
        object.can_execute_chrome_command = Some(can_execute_chrome_command::<I>);
        object.execute_chrome_command = Some(execute_chrome_command::<I>);
        object.is_render_process_unresponsive = Some(is_render_process_unresponsive::<I>);
        object.get_runtime_style = Some(get_runtime_style::<I>);
    }
    extern "C" fn get_browser<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_browser(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn close_browser<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        force_close: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_force_close) = (self_, force_close);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_force_close = arg_force_close.as_raw();
        let result = ImplBrowserHost::close_browser(&arg_self_.interface, arg_force_close);
    }
    extern "C" fn try_close_browser<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::try_close_browser(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_ready_to_be_closed<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::is_ready_to_be_closed(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_focus<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        focus: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_focus) = (self_, focus);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_focus = arg_focus.as_raw();
        let result = ImplBrowserHost::set_focus(&arg_self_.interface, arg_focus);
    }
    extern "C" fn get_window_handle<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_ulong {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_window_handle(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_opener_window_handle<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_ulong {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_opener_window_handle(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_opener_identifier<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_opener_identifier(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_view<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::has_view(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_client<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_client_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_client(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_request_context<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_request_context_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_request_context(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn can_zoom<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command: cef_zoom_command_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command) = (self_, command);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command = arg_command.as_raw();
        let result = ImplBrowserHost::can_zoom(&arg_self_.interface, arg_command);
        result.into()
    }
    extern "C" fn zoom<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command: cef_zoom_command_t,
    ) {
        let (arg_self_, arg_command) = (self_, command);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command = arg_command.as_raw();
        let result = ImplBrowserHost::zoom(&arg_self_.interface, arg_command);
    }
    extern "C" fn get_default_zoom_level<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_default_zoom_level(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_zoom_level<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_zoom_level(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_zoom_level<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        zoom_level: f64,
    ) {
        let (arg_self_, arg_zoom_level) = (self_, zoom_level);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_zoom_level = arg_zoom_level.as_raw();
        let result = ImplBrowserHost::set_zoom_level(&arg_self_.interface, arg_zoom_level);
    }
    extern "C" fn run_file_dialog<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        mode: cef_file_dialog_mode_t,
        title: *const _cef_string_utf16_t,
        default_file_path: *const _cef_string_utf16_t,
        accept_filters: *mut _cef_string_list_t,
        callback: *mut _cef_run_file_dialog_callback_t,
    ) {
        let (
            arg_self_,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_callback,
        ) = (
            self_,
            mode,
            title,
            default_file_path,
            accept_filters,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mode = arg_mode.as_raw();
        let arg_title = if arg_title.is_null() {
            None
        } else {
            Some(arg_title.into())
        };
        let arg_title = arg_title.as_ref();
        let arg_default_file_path = if arg_default_file_path.is_null() {
            None
        } else {
            Some(arg_default_file_path.into())
        };
        let arg_default_file_path = arg_default_file_path.as_ref();
        let mut arg_accept_filters = if arg_accept_filters.is_null() {
            None
        } else {
            Some(arg_accept_filters.into())
        };
        let arg_accept_filters = arg_accept_filters.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| RunFileDialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplBrowserHost::run_file_dialog(
            &arg_self_.interface,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_callback,
        );
    }
    extern "C" fn start_download<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let result = ImplBrowserHost::start_download(&arg_self_.interface, arg_url);
    }
    extern "C" fn download_image<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        image_url: *const _cef_string_utf16_t,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: *mut _cef_download_image_callback_t,
    ) {
        let (
            arg_self_,
            arg_image_url,
            arg_is_favicon,
            arg_max_image_size,
            arg_bypass_cache,
            arg_callback,
        ) = (
            self_,
            image_url,
            is_favicon,
            max_image_size,
            bypass_cache,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_image_url = if arg_image_url.is_null() {
            None
        } else {
            Some(arg_image_url.into())
        };
        let arg_image_url = arg_image_url.as_ref();
        let arg_is_favicon = arg_is_favicon.as_raw();
        let arg_max_image_size = arg_max_image_size.as_raw();
        let arg_bypass_cache = arg_bypass_cache.as_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| DownloadImageCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplBrowserHost::download_image(
            &arg_self_.interface,
            arg_image_url,
            arg_is_favicon,
            arg_max_image_size,
            arg_bypass_cache,
            arg_callback,
        );
    }
    extern "C" fn print<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::print(&arg_self_.interface);
    }
    extern "C" fn print_to_pdf<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        path: *const _cef_string_utf16_t,
        settings: *const _cef_pdf_print_settings_t,
        callback: *mut _cef_pdf_print_callback_t,
    ) {
        let (arg_self_, arg_path, arg_settings, arg_callback) = (self_, path, settings, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_path = if arg_path.is_null() {
            None
        } else {
            Some(arg_path.into())
        };
        let arg_path = arg_path.as_ref();
        let arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<PdfPrintSettings>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_ref().map(|arg| arg.as_ref());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| PdfPrintCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplBrowserHost::print_to_pdf(
            &arg_self_.interface,
            arg_path,
            arg_settings,
            arg_callback,
        );
    }
    extern "C" fn find<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        search_text: *const _cef_string_utf16_t,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_search_text, arg_forward, arg_match_case, arg_find_next) =
            (self_, search_text, forward, match_case, find_next);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_search_text = if arg_search_text.is_null() {
            None
        } else {
            Some(arg_search_text.into())
        };
        let arg_search_text = arg_search_text.as_ref();
        let arg_forward = arg_forward.as_raw();
        let arg_match_case = arg_match_case.as_raw();
        let arg_find_next = arg_find_next.as_raw();
        let result = ImplBrowserHost::find(
            &arg_self_.interface,
            arg_search_text,
            arg_forward,
            arg_match_case,
            arg_find_next,
        );
    }
    extern "C" fn stop_finding<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        clear_selection: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_clear_selection) = (self_, clear_selection);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_clear_selection = arg_clear_selection.as_raw();
        let result = ImplBrowserHost::stop_finding(&arg_self_.interface, arg_clear_selection);
    }
    extern "C" fn show_dev_tools<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        window_info: *const _cef_window_info_t,
        client: *mut _cef_client_t,
        settings: *const _cef_browser_settings_t,
        inspect_element_at: *const _cef_point_t,
    ) {
        let (arg_self_, arg_window_info, arg_client, arg_settings, arg_inspect_element_at) =
            (self_, window_info, client, settings, inspect_element_at);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window_info = if arg_window_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<WindowInfo>::from(arg_window_info))
        };
        let arg_window_info = arg_window_info.as_ref().map(|arg| arg.as_ref());
        let mut arg_client =
            unsafe { arg_client.as_mut() }.map(|arg| Client(unsafe { RefGuard::from_raw(arg) }));
        let arg_client = arg_client.as_mut();
        let arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BrowserSettings>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_ref().map(|arg| arg.as_ref());
        let arg_inspect_element_at = if arg_inspect_element_at.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_inspect_element_at))
        };
        let arg_inspect_element_at = arg_inspect_element_at.as_ref().map(|arg| arg.as_ref());
        let result = ImplBrowserHost::show_dev_tools(
            &arg_self_.interface,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_inspect_element_at,
        );
    }
    extern "C" fn close_dev_tools<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::close_dev_tools(&arg_self_.interface);
    }
    extern "C" fn has_dev_tools<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::has_dev_tools(&arg_self_.interface);
        result.into()
    }
    extern "C" fn send_dev_tools_message<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_message, arg_message_size) = (self_, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        let result = ImplBrowserHost::send_dev_tools_message(&arg_self_.interface, arg_message);
        result.into()
    }
    extern "C" fn execute_dev_tools_method<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        message_id: ::std::os::raw::c_int,
        method: *const _cef_string_utf16_t,
        params: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_message_id, arg_method, arg_params) =
            (self_, message_id, method, params);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_message_id = arg_message_id.as_raw();
        let arg_method = if arg_method.is_null() {
            None
        } else {
            Some(arg_method.into())
        };
        let arg_method = arg_method.as_ref();
        let mut arg_params = unsafe { arg_params.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_params = arg_params.as_mut();
        let result = ImplBrowserHost::execute_dev_tools_method(
            &arg_self_.interface,
            arg_message_id,
            arg_method,
            arg_params,
        );
        result.into()
    }
    extern "C" fn add_dev_tools_message_observer<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        observer: *mut _cef_dev_tools_message_observer_t,
    ) -> *mut _cef_registration_t {
        let (arg_self_, arg_observer) = (self_, observer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_observer = unsafe { arg_observer.as_mut() }
            .map(|arg| DevToolsMessageObserver(unsafe { RefGuard::from_raw(arg) }));
        let arg_observer = arg_observer.as_mut();
        let result =
            ImplBrowserHost::add_dev_tools_message_observer(&arg_self_.interface, arg_observer);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_navigation_entries<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        visitor: *mut _cef_navigation_entry_visitor_t,
        current_only: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_visitor, arg_current_only) = (self_, visitor, current_only);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_visitor = unsafe { arg_visitor.as_mut() }
            .map(|arg| NavigationEntryVisitor(unsafe { RefGuard::from_raw(arg) }));
        let arg_visitor = arg_visitor.as_mut();
        let arg_current_only = arg_current_only.as_raw();
        let result = ImplBrowserHost::get_navigation_entries(
            &arg_self_.interface,
            arg_visitor,
            arg_current_only,
        );
    }
    extern "C" fn replace_misspelling<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        word: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_word) = (self_, word);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_word = if arg_word.is_null() {
            None
        } else {
            Some(arg_word.into())
        };
        let arg_word = arg_word.as_ref();
        let result = ImplBrowserHost::replace_misspelling(&arg_self_.interface, arg_word);
    }
    extern "C" fn add_word_to_dictionary<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        word: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_word) = (self_, word);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_word = if arg_word.is_null() {
            None
        } else {
            Some(arg_word.into())
        };
        let arg_word = arg_word.as_ref();
        let result = ImplBrowserHost::add_word_to_dictionary(&arg_self_.interface, arg_word);
    }
    extern "C" fn is_window_rendering_disabled<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::is_window_rendering_disabled(&arg_self_.interface);
        result.into()
    }
    extern "C" fn was_resized<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::was_resized(&arg_self_.interface);
    }
    extern "C" fn was_hidden<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        hidden: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_hidden) = (self_, hidden);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_hidden = arg_hidden.as_raw();
        let result = ImplBrowserHost::was_hidden(&arg_self_.interface, arg_hidden);
    }
    extern "C" fn notify_screen_info_changed<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::notify_screen_info_changed(&arg_self_.interface);
    }
    extern "C" fn invalidate<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        type_: cef_paint_element_type_t,
    ) {
        let (arg_self_, arg_type_) = (self_, type_);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_type_ = arg_type_.as_raw();
        let result = ImplBrowserHost::invalidate(&arg_self_.interface, arg_type_);
    }
    extern "C" fn send_external_begin_frame<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::send_external_begin_frame(&arg_self_.interface);
    }
    extern "C" fn send_key_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_key_event_t,
    ) {
        let (arg_self_, arg_event) = (self_, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let result = ImplBrowserHost::send_key_event(&arg_self_.interface, arg_event);
    }
    extern "C" fn send_mouse_click_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        type_: cef_mouse_button_type_t,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_event, arg_type_, arg_mouse_up, arg_click_count) =
            (self_, event, type_, mouse_up, click_count);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<MouseEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let arg_type_ = arg_type_.as_raw();
        let arg_mouse_up = arg_mouse_up.as_raw();
        let arg_click_count = arg_click_count.as_raw();
        let result = ImplBrowserHost::send_mouse_click_event(
            &arg_self_.interface,
            arg_event,
            arg_type_,
            arg_mouse_up,
            arg_click_count,
        );
    }
    extern "C" fn send_mouse_move_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        mouse_leave: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_event, arg_mouse_leave) = (self_, event, mouse_leave);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<MouseEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let arg_mouse_leave = arg_mouse_leave.as_raw();
        let result = ImplBrowserHost::send_mouse_move_event(
            &arg_self_.interface,
            arg_event,
            arg_mouse_leave,
        );
    }
    extern "C" fn send_mouse_wheel_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_event, arg_delta_x, arg_delta_y) = (self_, event, delta_x, delta_y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<MouseEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let arg_delta_x = arg_delta_x.as_raw();
        let arg_delta_y = arg_delta_y.as_raw();
        let result = ImplBrowserHost::send_mouse_wheel_event(
            &arg_self_.interface,
            arg_event,
            arg_delta_x,
            arg_delta_y,
        );
    }
    extern "C" fn send_touch_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_touch_event_t,
    ) {
        let (arg_self_, arg_event) = (self_, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<TouchEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let result = ImplBrowserHost::send_touch_event(&arg_self_.interface, arg_event);
    }
    extern "C" fn send_capture_lost_event<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::send_capture_lost_event(&arg_self_.interface);
    }
    extern "C" fn notify_move_or_resize_started<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::notify_move_or_resize_started(&arg_self_.interface);
    }
    extern "C" fn get_windowless_frame_rate<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_windowless_frame_rate(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_windowless_frame_rate<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        frame_rate: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_frame_rate) = (self_, frame_rate);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_frame_rate = arg_frame_rate.as_raw();
        let result =
            ImplBrowserHost::set_windowless_frame_rate(&arg_self_.interface, arg_frame_rate);
    }
    extern "C" fn ime_set_composition<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        text: *const _cef_string_utf16_t,
        underlines_count: usize,
        underlines: *const _cef_composition_underline_t,
        replacement_range: *const _cef_range_t,
        selection_range: *const _cef_range_t,
    ) {
        let (
            arg_self_,
            arg_text,
            arg_underlines_count,
            arg_underlines,
            arg_replacement_range,
            arg_selection_range,
        ) = (
            self_,
            text,
            underlines_count,
            underlines,
            replacement_range,
            selection_range,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let arg_underlines_count = arg_underlines_count.as_raw();
        let arg_underlines = if arg_underlines.is_null() {
            None
        } else {
            Some(WrapParamRef::<CompositionUnderline>::from(arg_underlines))
        };
        let arg_underlines = arg_underlines.as_ref().map(|arg| arg.as_ref());
        let arg_replacement_range = if arg_replacement_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_replacement_range))
        };
        let arg_replacement_range = arg_replacement_range.as_ref().map(|arg| arg.as_ref());
        let arg_selection_range = if arg_selection_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_selection_range))
        };
        let arg_selection_range = arg_selection_range.as_ref().map(|arg| arg.as_ref());
        let result = ImplBrowserHost::ime_set_composition(
            &arg_self_.interface,
            arg_text,
            arg_underlines_count,
            arg_underlines,
            arg_replacement_range,
            arg_selection_range,
        );
    }
    extern "C" fn ime_commit_text<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        text: *const _cef_string_utf16_t,
        replacement_range: *const _cef_range_t,
        relative_cursor_pos: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_text, arg_replacement_range, arg_relative_cursor_pos) =
            (self_, text, replacement_range, relative_cursor_pos);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let arg_replacement_range = if arg_replacement_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_replacement_range))
        };
        let arg_replacement_range = arg_replacement_range.as_ref().map(|arg| arg.as_ref());
        let arg_relative_cursor_pos = arg_relative_cursor_pos.as_raw();
        let result = ImplBrowserHost::ime_commit_text(
            &arg_self_.interface,
            arg_text,
            arg_replacement_range,
            arg_relative_cursor_pos,
        );
    }
    extern "C" fn ime_finish_composing_text<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        keep_selection: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_keep_selection) = (self_, keep_selection);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_keep_selection = arg_keep_selection.as_raw();
        let result =
            ImplBrowserHost::ime_finish_composing_text(&arg_self_.interface, arg_keep_selection);
    }
    extern "C" fn ime_cancel_composition<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::ime_cancel_composition(&arg_self_.interface);
    }
    extern "C" fn drag_target_drag_enter<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        drag_data: *mut _cef_drag_data_t,
        event: *const _cef_mouse_event_t,
        allowed_ops: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_drag_data, arg_event, arg_allowed_ops) =
            (self_, drag_data, event, allowed_ops);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_drag_data = unsafe { arg_drag_data.as_mut() }
            .map(|arg| DragData(unsafe { RefGuard::from_raw(arg) }));
        let arg_drag_data = arg_drag_data.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<MouseEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let arg_allowed_ops = arg_allowed_ops.as_raw();
        let result = ImplBrowserHost::drag_target_drag_enter(
            &arg_self_.interface,
            arg_drag_data,
            arg_event,
            arg_allowed_ops,
        );
    }
    extern "C" fn drag_target_drag_over<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        allowed_ops: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_event, arg_allowed_ops) = (self_, event, allowed_ops);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<MouseEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let arg_allowed_ops = arg_allowed_ops.as_raw();
        let result = ImplBrowserHost::drag_target_drag_over(
            &arg_self_.interface,
            arg_event,
            arg_allowed_ops,
        );
    }
    extern "C" fn drag_target_drag_leave<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::drag_target_drag_leave(&arg_self_.interface);
    }
    extern "C" fn drag_target_drop<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
    ) {
        let (arg_self_, arg_event) = (self_, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<MouseEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let result = ImplBrowserHost::drag_target_drop(&arg_self_.interface, arg_event);
    }
    extern "C" fn drag_source_ended_at<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_x, arg_y, arg_op) = (self_, x, y, op);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_x = arg_x.as_raw();
        let arg_y = arg_y.as_raw();
        let arg_op = arg_op.as_raw();
        let result =
            ImplBrowserHost::drag_source_ended_at(&arg_self_.interface, arg_x, arg_y, arg_op);
    }
    extern "C" fn drag_source_system_drag_ended<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::drag_source_system_drag_ended(&arg_self_.interface);
    }
    extern "C" fn get_visible_navigation_entry<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_navigation_entry_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_visible_navigation_entry(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_accessibility_state<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        accessibility_state: cef_state_t,
    ) {
        let (arg_self_, arg_accessibility_state) = (self_, accessibility_state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_accessibility_state = arg_accessibility_state.as_raw();
        let result =
            ImplBrowserHost::set_accessibility_state(&arg_self_.interface, arg_accessibility_state);
    }
    extern "C" fn set_auto_resize_enabled<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        enabled: ::std::os::raw::c_int,
        min_size: *const _cef_size_t,
        max_size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_enabled, arg_min_size, arg_max_size) =
            (self_, enabled, min_size, max_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_enabled = arg_enabled.as_raw();
        let arg_min_size = if arg_min_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_min_size))
        };
        let arg_min_size = arg_min_size.as_ref().map(|arg| arg.as_ref());
        let arg_max_size = if arg_max_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_max_size))
        };
        let arg_max_size = arg_max_size.as_ref().map(|arg| arg.as_ref());
        let result = ImplBrowserHost::set_auto_resize_enabled(
            &arg_self_.interface,
            arg_enabled,
            arg_min_size,
            arg_max_size,
        );
    }
    extern "C" fn set_audio_muted<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        mute: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_mute) = (self_, mute);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mute = arg_mute.as_raw();
        let result = ImplBrowserHost::set_audio_muted(&arg_self_.interface, arg_mute);
    }
    extern "C" fn is_audio_muted<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::is_audio_muted(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_fullscreen<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::is_fullscreen(&arg_self_.interface);
        result.into()
    }
    extern "C" fn exit_fullscreen<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        will_cause_resize: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_will_cause_resize) = (self_, will_cause_resize);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_will_cause_resize = arg_will_cause_resize.as_raw();
        let result = ImplBrowserHost::exit_fullscreen(&arg_self_.interface, arg_will_cause_resize);
    }
    extern "C" fn can_execute_chrome_command<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result =
            ImplBrowserHost::can_execute_chrome_command(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn execute_chrome_command<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command_id: ::std::os::raw::c_int,
        disposition: cef_window_open_disposition_t,
    ) {
        let (arg_self_, arg_command_id, arg_disposition) = (self_, command_id, disposition);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_disposition = arg_disposition.as_raw();
        let result = ImplBrowserHost::execute_chrome_command(
            &arg_self_.interface,
            arg_command_id,
            arg_disposition,
        );
    }
    extern "C" fn is_render_process_unresponsive<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::is_render_process_unresponsive(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_runtime_style<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserHost::get_runtime_style(&arg_self_.interface);
        result.into()
    }
}
impl ImplBrowserHost for BrowserHost {
    fn get_browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn close_browser(&self, force_close: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .close_browser
                .map(|f| {
                    let arg_force_close = force_close;
                    let arg_self_ = self.as_raw();
                    let arg_force_close = arg_force_close;
                    let result = f(arg_self_, arg_force_close);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn try_close_browser(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .try_close_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_ready_to_be_closed(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_ready_to_be_closed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_focus(&self, focus: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_focus
                .map(|f| {
                    let arg_focus = focus;
                    let arg_self_ = self.as_raw();
                    let arg_focus = arg_focus;
                    let result = f(arg_self_, arg_focus);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_handle(&self) -> ::std::os::raw::c_ulong {
        unsafe {
            self.0
                .get_window_handle
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_opener_window_handle(&self) -> ::std::os::raw::c_ulong {
        unsafe {
            self.0
                .get_opener_window_handle
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_opener_identifier(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_opener_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_view(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_client(&self) -> Option<Client> {
        unsafe {
            self.0
                .get_client
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_request_context(&self) -> Option<RequestContext> {
        unsafe {
            self.0
                .get_request_context
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn can_zoom(&self, command: ZoomCommand) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_zoom
                .map(|f| {
                    let arg_command = command;
                    let arg_self_ = self.as_raw();
                    let arg_command = arg_command.as_raw();
                    let result = f(arg_self_, arg_command);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn zoom(&self, command: ZoomCommand) {
        unsafe {
            self.0
                .zoom
                .map(|f| {
                    let arg_command = command;
                    let arg_self_ = self.as_raw();
                    let arg_command = arg_command.as_raw();
                    let result = f(arg_self_, arg_command);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_default_zoom_level(&self) -> f64 {
        unsafe {
            self.0
                .get_default_zoom_level
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_zoom_level(&self) -> f64 {
        unsafe {
            self.0
                .get_zoom_level
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_zoom_level(&self, zoom_level: f64) {
        unsafe {
            self.0
                .set_zoom_level
                .map(|f| {
                    let arg_zoom_level = zoom_level;
                    let arg_self_ = self.as_raw();
                    let arg_zoom_level = arg_zoom_level;
                    let result = f(arg_self_, arg_zoom_level);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn run_file_dialog(
        &self,
        mode: FileDialogMode,
        title: Option<&CefStringUtf16>,
        default_file_path: Option<&CefStringUtf16>,
        accept_filters: Option<&mut CefStringList>,
        callback: Option<&mut impl ImplRunFileDialogCallback>,
    ) {
        unsafe {
            self.0
                .run_file_dialog
                .map(|f| {
                    let (
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_callback,
                    ) = (mode, title, default_file_path, accept_filters, callback);
                    let arg_self_ = self.as_raw();
                    let arg_mode = arg_mode.as_raw();
                    let arg_title = arg_title
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_default_file_path = arg_default_file_path
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_accept_filters = arg_accept_filters
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplRunFileDialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn start_download(&self, url: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .start_download
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn download_image(
        &self,
        image_url: Option<&CefStringUtf16>,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplDownloadImageCallback>,
    ) {
        unsafe {
            self.0
                .download_image
                .map(|f| {
                    let (
                        arg_image_url,
                        arg_is_favicon,
                        arg_max_image_size,
                        arg_bypass_cache,
                        arg_callback,
                    ) = (
                        image_url,
                        is_favicon,
                        max_image_size,
                        bypass_cache,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_image_url = arg_image_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_is_favicon = arg_is_favicon;
                    let arg_max_image_size = arg_max_image_size;
                    let arg_bypass_cache = arg_bypass_cache;
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplDownloadImageCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_image_url,
                        arg_is_favicon,
                        arg_max_image_size,
                        arg_bypass_cache,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn print(&self) {
        unsafe {
            self.0
                .print
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn print_to_pdf(
        &self,
        path: Option<&CefStringUtf16>,
        settings: Option<&PdfPrintSettings>,
        callback: Option<&mut impl ImplPdfPrintCallback>,
    ) {
        unsafe {
            self.0
                .print_to_pdf
                .map(|f| {
                    let (arg_path, arg_settings, arg_callback) = (path, settings, callback);
                    let arg_self_ = self.as_raw();
                    let arg_path = arg_path.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplPdfPrintCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_path, arg_settings, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn find(
        &self,
        search_text: Option<&CefStringUtf16>,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .find
                .map(|f| {
                    let (arg_search_text, arg_forward, arg_match_case, arg_find_next) =
                        (search_text, forward, match_case, find_next);
                    let arg_self_ = self.as_raw();
                    let arg_search_text = arg_search_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_forward = arg_forward;
                    let arg_match_case = arg_match_case;
                    let arg_find_next = arg_find_next;
                    let result = f(
                        arg_self_,
                        arg_search_text,
                        arg_forward,
                        arg_match_case,
                        arg_find_next,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn stop_finding(&self, clear_selection: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .stop_finding
                .map(|f| {
                    let arg_clear_selection = clear_selection;
                    let arg_self_ = self.as_raw();
                    let arg_clear_selection = arg_clear_selection;
                    let result = f(arg_self_, arg_clear_selection);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn show_dev_tools(
        &self,
        window_info: Option<&WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&BrowserSettings>,
        inspect_element_at: Option<&Point>,
    ) {
        unsafe {
            self.0
                .show_dev_tools
                .map(|f| {
                    let (arg_window_info, arg_client, arg_settings, arg_inspect_element_at) =
                        (window_info, client, settings, inspect_element_at);
                    let arg_self_ = self.as_raw();
                    let arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
                    let arg_window_info = arg_window_info
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_client = arg_client
                        .map(|arg| {
                            arg.add_ref();
                            ImplClient::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_inspect_element_at =
                        arg_inspect_element_at.cloned().map(|arg| arg.into());
                    let arg_inspect_element_at = arg_inspect_element_at
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_inspect_element_at,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn close_dev_tools(&self) {
        unsafe {
            self.0
                .close_dev_tools
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_dev_tools(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_dev_tools
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn send_dev_tools_message(&self, message: Option<&[u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .send_dev_tools_message
                .map(|f| {
                    let arg_message = message;
                    let arg_self_ = self.as_raw();
                    let arg_message_size = arg_message
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_message = arg_message
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn execute_dev_tools_method(
        &self,
        message_id: ::std::os::raw::c_int,
        method: Option<&CefStringUtf16>,
        params: Option<&mut impl ImplDictionaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .execute_dev_tools_method
                .map(|f| {
                    let (arg_message_id, arg_method, arg_params) = (message_id, method, params);
                    let arg_self_ = self.as_raw();
                    let arg_message_id = arg_message_id;
                    let arg_method = arg_method
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_params = arg_params
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_message_id, arg_method, arg_params);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_dev_tools_message_observer(
        &self,
        observer: Option<&mut impl ImplDevToolsMessageObserver>,
    ) -> Option<Registration> {
        unsafe {
            self.0
                .add_dev_tools_message_observer
                .map(|f| {
                    let arg_observer = observer;
                    let arg_self_ = self.as_raw();
                    let arg_observer = arg_observer
                        .map(|arg| {
                            arg.add_ref();
                            ImplDevToolsMessageObserver::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_observer);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_navigation_entries(
        &self,
        visitor: Option<&mut impl ImplNavigationEntryVisitor>,
        current_only: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .get_navigation_entries
                .map(|f| {
                    let (arg_visitor, arg_current_only) = (visitor, current_only);
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplNavigationEntryVisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_current_only = arg_current_only;
                    let result = f(arg_self_, arg_visitor, arg_current_only);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn replace_misspelling(&self, word: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .replace_misspelling
                .map(|f| {
                    let arg_word = word;
                    let arg_self_ = self.as_raw();
                    let arg_word = arg_word.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_word);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_word_to_dictionary(&self, word: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .add_word_to_dictionary
                .map(|f| {
                    let arg_word = word;
                    let arg_self_ = self.as_raw();
                    let arg_word = arg_word.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_word);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_window_rendering_disabled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_window_rendering_disabled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn was_resized(&self) {
        unsafe {
            self.0
                .was_resized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn was_hidden(&self, hidden: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .was_hidden
                .map(|f| {
                    let arg_hidden = hidden;
                    let arg_self_ = self.as_raw();
                    let arg_hidden = arg_hidden;
                    let result = f(arg_self_, arg_hidden);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn notify_screen_info_changed(&self) {
        unsafe {
            self.0
                .notify_screen_info_changed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn invalidate(&self, type_: PaintElementType) {
        unsafe {
            self.0
                .invalidate
                .map(|f| {
                    let arg_type_ = type_;
                    let arg_self_ = self.as_raw();
                    let arg_type_ = arg_type_.as_raw();
                    let result = f(arg_self_, arg_type_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_external_begin_frame(&self) {
        unsafe {
            self.0
                .send_external_begin_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_key_event(&self, event: Option<&KeyEvent>) {
        unsafe {
            self.0
                .send_key_event
                .map(|f| {
                    let arg_event = event;
                    let arg_self_ = self.as_raw();
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_click_event(
        &self,
        event: Option<&MouseEvent>,
        type_: MouseButtonType,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_click_event
                .map(|f| {
                    let (arg_event, arg_type_, arg_mouse_up, arg_click_count) =
                        (event, type_, mouse_up, click_count);
                    let arg_self_ = self.as_raw();
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_type_ = arg_type_.as_raw();
                    let arg_mouse_up = arg_mouse_up;
                    let arg_click_count = arg_click_count;
                    let result = f(
                        arg_self_,
                        arg_event,
                        arg_type_,
                        arg_mouse_up,
                        arg_click_count,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_move_event(
        &self,
        event: Option<&MouseEvent>,
        mouse_leave: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_move_event
                .map(|f| {
                    let (arg_event, arg_mouse_leave) = (event, mouse_leave);
                    let arg_self_ = self.as_raw();
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_mouse_leave = arg_mouse_leave;
                    let result = f(arg_self_, arg_event, arg_mouse_leave);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_wheel_event(
        &self,
        event: Option<&MouseEvent>,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_wheel_event
                .map(|f| {
                    let (arg_event, arg_delta_x, arg_delta_y) = (event, delta_x, delta_y);
                    let arg_self_ = self.as_raw();
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_delta_x = arg_delta_x;
                    let arg_delta_y = arg_delta_y;
                    let result = f(arg_self_, arg_event, arg_delta_x, arg_delta_y);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_touch_event(&self, event: Option<&TouchEvent>) {
        unsafe {
            self.0
                .send_touch_event
                .map(|f| {
                    let arg_event = event;
                    let arg_self_ = self.as_raw();
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_capture_lost_event(&self) {
        unsafe {
            self.0
                .send_capture_lost_event
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn notify_move_or_resize_started(&self) {
        unsafe {
            self.0
                .notify_move_or_resize_started
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_windowless_frame_rate(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_windowless_frame_rate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_windowless_frame_rate(&self, frame_rate: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_windowless_frame_rate
                .map(|f| {
                    let arg_frame_rate = frame_rate;
                    let arg_self_ = self.as_raw();
                    let arg_frame_rate = arg_frame_rate;
                    let result = f(arg_self_, arg_frame_rate);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_set_composition(
        &self,
        text: Option<&CefStringUtf16>,
        underlines_count: usize,
        underlines: Option<&CompositionUnderline>,
        replacement_range: Option<&Range>,
        selection_range: Option<&Range>,
    ) {
        unsafe {
            self.0
                .ime_set_composition
                .map(|f| {
                    let (
                        arg_text,
                        arg_underlines_count,
                        arg_underlines,
                        arg_replacement_range,
                        arg_selection_range,
                    ) = (
                        text,
                        underlines_count,
                        underlines,
                        replacement_range,
                        selection_range,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_underlines_count = arg_underlines_count;
                    let arg_underlines = arg_underlines.cloned().map(|arg| arg.into());
                    let arg_underlines = arg_underlines
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_replacement_range =
                        arg_replacement_range.cloned().map(|arg| arg.into());
                    let arg_replacement_range = arg_replacement_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_selection_range = arg_selection_range.cloned().map(|arg| arg.into());
                    let arg_selection_range = arg_selection_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_text,
                        arg_underlines_count,
                        arg_underlines,
                        arg_replacement_range,
                        arg_selection_range,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_commit_text(
        &self,
        text: Option<&CefStringUtf16>,
        replacement_range: Option<&Range>,
        relative_cursor_pos: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .ime_commit_text
                .map(|f| {
                    let (arg_text, arg_replacement_range, arg_relative_cursor_pos) =
                        (text, replacement_range, relative_cursor_pos);
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_replacement_range =
                        arg_replacement_range.cloned().map(|arg| arg.into());
                    let arg_replacement_range = arg_replacement_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_relative_cursor_pos = arg_relative_cursor_pos;
                    let result = f(
                        arg_self_,
                        arg_text,
                        arg_replacement_range,
                        arg_relative_cursor_pos,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_finish_composing_text(&self, keep_selection: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .ime_finish_composing_text
                .map(|f| {
                    let arg_keep_selection = keep_selection;
                    let arg_self_ = self.as_raw();
                    let arg_keep_selection = arg_keep_selection;
                    let result = f(arg_self_, arg_keep_selection);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_cancel_composition(&self) {
        unsafe {
            self.0
                .ime_cancel_composition
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drag_enter(
        &self,
        drag_data: Option<&mut impl ImplDragData>,
        event: Option<&MouseEvent>,
        allowed_ops: DragOperationsMask,
    ) {
        unsafe {
            self.0
                .drag_target_drag_enter
                .map(|f| {
                    let (arg_drag_data, arg_event, arg_allowed_ops) =
                        (drag_data, event, allowed_ops);
                    let arg_self_ = self.as_raw();
                    let arg_drag_data = arg_drag_data
                        .map(|arg| {
                            arg.add_ref();
                            ImplDragData::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_allowed_ops = arg_allowed_ops.as_raw();
                    let result = f(arg_self_, arg_drag_data, arg_event, arg_allowed_ops);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drag_over(&self, event: Option<&MouseEvent>, allowed_ops: DragOperationsMask) {
        unsafe {
            self.0
                .drag_target_drag_over
                .map(|f| {
                    let (arg_event, arg_allowed_ops) = (event, allowed_ops);
                    let arg_self_ = self.as_raw();
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_allowed_ops = arg_allowed_ops.as_raw();
                    let result = f(arg_self_, arg_event, arg_allowed_ops);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drag_leave(&self) {
        unsafe {
            self.0
                .drag_target_drag_leave
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drop(&self, event: Option<&MouseEvent>) {
        unsafe {
            self.0
                .drag_target_drop
                .map(|f| {
                    let arg_event = event;
                    let arg_self_ = self.as_raw();
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_source_ended_at(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: DragOperationsMask,
    ) {
        unsafe {
            self.0
                .drag_source_ended_at
                .map(|f| {
                    let (arg_x, arg_y, arg_op) = (x, y, op);
                    let arg_self_ = self.as_raw();
                    let arg_x = arg_x;
                    let arg_y = arg_y;
                    let arg_op = arg_op.as_raw();
                    let result = f(arg_self_, arg_x, arg_y, arg_op);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_source_system_drag_ended(&self) {
        unsafe {
            self.0
                .drag_source_system_drag_ended
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_visible_navigation_entry(&self) -> Option<NavigationEntry> {
        unsafe {
            self.0
                .get_visible_navigation_entry
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_accessibility_state(&self, accessibility_state: State) {
        unsafe {
            self.0
                .set_accessibility_state
                .map(|f| {
                    let arg_accessibility_state = accessibility_state;
                    let arg_self_ = self.as_raw();
                    let arg_accessibility_state = arg_accessibility_state.as_raw();
                    let result = f(arg_self_, arg_accessibility_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_auto_resize_enabled(
        &self,
        enabled: ::std::os::raw::c_int,
        min_size: Option<&Size>,
        max_size: Option<&Size>,
    ) {
        unsafe {
            self.0
                .set_auto_resize_enabled
                .map(|f| {
                    let (arg_enabled, arg_min_size, arg_max_size) = (enabled, min_size, max_size);
                    let arg_self_ = self.as_raw();
                    let arg_enabled = arg_enabled;
                    let arg_min_size = arg_min_size.cloned().map(|arg| arg.into());
                    let arg_min_size = arg_min_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_max_size = arg_max_size.cloned().map(|arg| arg.into());
                    let arg_max_size = arg_max_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_enabled, arg_min_size, arg_max_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_audio_muted(&self, mute: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_audio_muted
                .map(|f| {
                    let arg_mute = mute;
                    let arg_self_ = self.as_raw();
                    let arg_mute = arg_mute;
                    let result = f(arg_self_, arg_mute);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_audio_muted(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_audio_muted
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_fullscreen(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fullscreen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn exit_fullscreen(&self, will_cause_resize: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .exit_fullscreen
                .map(|f| {
                    let arg_will_cause_resize = will_cause_resize;
                    let arg_self_ = self.as_raw();
                    let arg_will_cause_resize = arg_will_cause_resize;
                    let result = f(arg_self_, arg_will_cause_resize);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_execute_chrome_command
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) {
        unsafe {
            self.0
                .execute_chrome_command
                .map(|f| {
                    let (arg_command_id, arg_disposition) = (command_id, disposition);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_disposition = arg_disposition.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_disposition);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_render_process_unresponsive(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_render_process_unresponsive
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_host_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_browser_host_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserHost {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_host_t> for &BrowserHost {
    fn as_raw(self) -> *mut _cef_browser_host_t {
        ImplBrowserHost::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_host_t> for &mut BrowserHost {
    fn as_raw(self) -> *mut _cef_browser_host_t {
        ImplBrowserHost::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserHost> for *mut _cef_browser_host_t {
    fn as_wrapper(self) -> BrowserHost {
        BrowserHost(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_host_t> for BrowserHost {
    fn into(self) -> *mut _cef_browser_host_t {
        let object = ImplBrowserHost::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for BrowserHost {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_audio_handler_t] for more documentation.
#[derive(Clone)]
pub struct AudioHandler(RefGuard<_cef_audio_handler_t>);
impl AudioHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapAudioHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplAudioHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapAudioHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_audio_handler_t).as_wrapper()
        }
    }
}
pub trait WrapAudioHandler: ImplAudioHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_audio_handler_t, Self>);
}
pub trait ImplAudioHandler: Clone + Sized + Rc {
    fn get_audio_parameters(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        params: Option<&mut AudioParameters>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_audio_stream_started(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        params: Option<&AudioParameters>,
        channels: ::std::os::raw::c_int,
    ) {
    }
    fn on_audio_stream_packet(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
    }
    fn on_audio_stream_stopped(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn on_audio_stream_error(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message: Option<&CefStringUtf16>,
    ) {
    }
    fn init_methods(object: &mut _cef_audio_handler_t) {
        impl_cef_audio_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_audio_handler_t;
}
mod impl_cef_audio_handler_t {
    use super::*;
    pub fn init_methods<I: ImplAudioHandler>(object: &mut _cef_audio_handler_t) {
        object.get_audio_parameters = Some(get_audio_parameters::<I>);
        object.on_audio_stream_started = Some(on_audio_stream_started::<I>);
        object.on_audio_stream_packet = Some(on_audio_stream_packet::<I>);
        object.on_audio_stream_stopped = Some(on_audio_stream_stopped::<I>);
        object.on_audio_stream_error = Some(on_audio_stream_error::<I>);
    }
    extern "C" fn get_audio_parameters<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        params: *mut _cef_audio_parameters_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_params) = (self_, browser, params);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_params = if arg_params.is_null() {
            None
        } else {
            Some(WrapParamRef::<AudioParameters>::from(arg_params))
        };
        let arg_params = arg_params.as_mut().map(|arg| arg.as_mut());
        let result =
            ImplAudioHandler::get_audio_parameters(&arg_self_.interface, arg_browser, arg_params);
        result.into()
    }
    extern "C" fn on_audio_stream_started<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        params: *const _cef_audio_parameters_t,
        channels: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_params, arg_channels) = (self_, browser, params, channels);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_params = if arg_params.is_null() {
            None
        } else {
            Some(WrapParamRef::<AudioParameters>::from(arg_params))
        };
        let arg_params = arg_params.as_ref().map(|arg| arg.as_ref());
        let arg_channels = arg_channels.as_raw();
        let result = ImplAudioHandler::on_audio_stream_started(
            &arg_self_.interface,
            arg_browser,
            arg_params,
            arg_channels,
        );
    }
    extern "C" fn on_audio_stream_packet<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
        let (arg_self_, arg_browser, arg_data, arg_frames, arg_pts) =
            (self_, browser, data, frames, pts);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_data = arg_data.as_raw();
        let arg_frames = arg_frames.as_raw();
        let arg_pts = arg_pts.as_raw();
        let result = ImplAudioHandler::on_audio_stream_packet(
            &arg_self_.interface,
            arg_browser,
            arg_data,
            arg_frames,
            arg_pts,
        );
    }
    extern "C" fn on_audio_stream_stopped<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplAudioHandler::on_audio_stream_stopped(&arg_self_.interface, arg_browser);
    }
    extern "C" fn on_audio_stream_error<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        message: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_message) = (self_, browser, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message = if arg_message.is_null() {
            None
        } else {
            Some(arg_message.into())
        };
        let arg_message = arg_message.as_ref();
        let result =
            ImplAudioHandler::on_audio_stream_error(&arg_self_.interface, arg_browser, arg_message);
    }
}
impl ImplAudioHandler for AudioHandler {
    fn get_audio_parameters(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        params: Option<&mut AudioParameters>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_audio_parameters
                .map(|f| {
                    let (arg_browser, arg_params) = (browser, params);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_params = arg_params.cloned().map(|arg| arg.into());
                    let arg_params = arg_params
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_params);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_audio_stream_started(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        params: Option<&AudioParameters>,
        channels: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_audio_stream_started
                .map(|f| {
                    let (arg_browser, arg_params, arg_channels) = (browser, params, channels);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_params = arg_params.cloned().map(|arg| arg.into());
                    let arg_params = arg_params
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_channels = arg_channels;
                    let result = f(arg_self_, arg_browser, arg_params, arg_channels);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_audio_stream_packet(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
        unsafe {
            self.0
                .on_audio_stream_packet
                .map(|f| {
                    let (arg_browser, arg_data, arg_frames, arg_pts) = (browser, data, frames, pts);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data = arg_data as *mut _;
                    let arg_frames = arg_frames;
                    let arg_pts = arg_pts;
                    let result = f(arg_self_, arg_browser, arg_data, arg_frames, arg_pts);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_audio_stream_stopped(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_audio_stream_stopped
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_audio_stream_error(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message: Option<&CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .on_audio_stream_error
                .map(|f| {
                    let (arg_browser, arg_message) = (browser, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_message = arg_message
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_message);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_audio_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_audio_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AudioHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_audio_handler_t> for &AudioHandler {
    fn as_raw(self) -> *mut _cef_audio_handler_t {
        ImplAudioHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_audio_handler_t> for &mut AudioHandler {
    fn as_raw(self) -> *mut _cef_audio_handler_t {
        ImplAudioHandler::get_raw(self)
    }
}
impl ConvertReturnValue<AudioHandler> for *mut _cef_audio_handler_t {
    fn as_wrapper(self) -> AudioHandler {
        AudioHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_audio_handler_t> for AudioHandler {
    fn into(self) -> *mut _cef_audio_handler_t {
        let object = ImplAudioHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for AudioHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_command_handler_t] for more documentation.
#[derive(Clone)]
pub struct CommandHandler(RefGuard<_cef_command_handler_t>);
impl CommandHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCommandHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCommandHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCommandHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_command_handler_t).as_wrapper()
        }
    }
}
pub trait WrapCommandHandler: ImplCommandHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_command_handler_t, Self>);
}
pub trait ImplCommandHandler: Clone + Sized + Rc {
    fn on_chrome_command(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_chrome_app_menu_item_visible(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_chrome_app_menu_item_enabled(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_chrome_page_action_icon_visible(
        &self,
        icon_type: ChromePageActionIconType,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_chrome_toolbar_button_visible(
        &self,
        button_type: ChromeToolbarButtonType,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_command_handler_t) {
        impl_cef_command_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_command_handler_t;
}
mod impl_cef_command_handler_t {
    use super::*;
    pub fn init_methods<I: ImplCommandHandler>(object: &mut _cef_command_handler_t) {
        object.on_chrome_command = Some(on_chrome_command::<I>);
        object.is_chrome_app_menu_item_visible = Some(is_chrome_app_menu_item_visible::<I>);
        object.is_chrome_app_menu_item_enabled = Some(is_chrome_app_menu_item_enabled::<I>);
        object.is_chrome_page_action_icon_visible = Some(is_chrome_page_action_icon_visible::<I>);
        object.is_chrome_toolbar_button_visible = Some(is_chrome_toolbar_button_visible::<I>);
    }
    extern "C" fn on_chrome_command<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
        disposition: cef_window_open_disposition_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id, arg_disposition) =
            (self_, browser, command_id, disposition);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_command_id = arg_command_id.as_raw();
        let arg_disposition = arg_disposition.as_raw();
        let result = ImplCommandHandler::on_chrome_command(
            &arg_self_.interface,
            arg_browser,
            arg_command_id,
            arg_disposition,
        );
        result.into()
    }
    extern "C" fn is_chrome_app_menu_item_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id) = (self_, browser, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplCommandHandler::is_chrome_app_menu_item_visible(
            &arg_self_.interface,
            arg_browser,
            arg_command_id,
        );
        result.into()
    }
    extern "C" fn is_chrome_app_menu_item_enabled<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id) = (self_, browser, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplCommandHandler::is_chrome_app_menu_item_enabled(
            &arg_self_.interface,
            arg_browser,
            arg_command_id,
        );
        result.into()
    }
    extern "C" fn is_chrome_page_action_icon_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        icon_type: cef_chrome_page_action_icon_type_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_icon_type) = (self_, icon_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_icon_type = arg_icon_type.as_raw();
        let result = ImplCommandHandler::is_chrome_page_action_icon_visible(
            &arg_self_.interface,
            arg_icon_type,
        );
        result.into()
    }
    extern "C" fn is_chrome_toolbar_button_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        button_type: cef_chrome_toolbar_button_type_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_button_type) = (self_, button_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button_type = arg_button_type.as_raw();
        let result = ImplCommandHandler::is_chrome_toolbar_button_visible(
            &arg_self_.interface,
            arg_button_type,
        );
        result.into()
    }
}
impl ImplCommandHandler for CommandHandler {
    fn on_chrome_command(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_chrome_command
                .map(|f| {
                    let (arg_browser, arg_command_id, arg_disposition) =
                        (browser, command_id, disposition);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_command_id = arg_command_id;
                    let arg_disposition = arg_disposition.as_raw();
                    let result = f(arg_self_, arg_browser, arg_command_id, arg_disposition);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_app_menu_item_visible(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_app_menu_item_visible
                .map(|f| {
                    let (arg_browser, arg_command_id) = (browser, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_browser, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_app_menu_item_enabled(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_app_menu_item_enabled
                .map(|f| {
                    let (arg_browser, arg_command_id) = (browser, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_browser, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_page_action_icon_visible(
        &self,
        icon_type: ChromePageActionIconType,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_page_action_icon_visible
                .map(|f| {
                    let arg_icon_type = icon_type;
                    let arg_self_ = self.as_raw();
                    let arg_icon_type = arg_icon_type.as_raw();
                    let result = f(arg_self_, arg_icon_type);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_toolbar_button_visible(
        &self,
        button_type: ChromeToolbarButtonType,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_toolbar_button_visible
                .map(|f| {
                    let arg_button_type = button_type;
                    let arg_self_ = self.as_raw();
                    let arg_button_type = arg_button_type.as_raw();
                    let result = f(arg_self_, arg_button_type);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_command_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_command_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CommandHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_command_handler_t> for &CommandHandler {
    fn as_raw(self) -> *mut _cef_command_handler_t {
        ImplCommandHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_command_handler_t> for &mut CommandHandler {
    fn as_raw(self) -> *mut _cef_command_handler_t {
        ImplCommandHandler::get_raw(self)
    }
}
impl ConvertReturnValue<CommandHandler> for *mut _cef_command_handler_t {
    fn as_wrapper(self) -> CommandHandler {
        CommandHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_command_handler_t> for CommandHandler {
    fn into(self) -> *mut _cef_command_handler_t {
        let object = ImplCommandHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for CommandHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_menu_model_delegate_t] for more documentation.
#[derive(Clone)]
pub struct MenuModelDelegate(RefGuard<_cef_menu_model_delegate_t>);
impl MenuModelDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMenuModelDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMenuModelDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMenuModelDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_menu_model_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapMenuModelDelegate: ImplMenuModelDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_menu_model_delegate_t, Self>);
}
pub trait ImplMenuModelDelegate: Clone + Sized + Rc {
    fn execute_command(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) {
    }
    fn mouse_outside_menu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        screen_point: Option<&Point>,
    ) {
    }
    fn unhandled_open_submenu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
    }
    fn unhandled_close_submenu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
    }
    fn menu_will_show(&self, menu_model: Option<&mut impl ImplMenuModel>) {}
    fn menu_closed(&self, menu_model: Option<&mut impl ImplMenuModel>) {}
    fn format_label(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        label: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_menu_model_delegate_t) {
        impl_cef_menu_model_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_menu_model_delegate_t;
}
mod impl_cef_menu_model_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplMenuModelDelegate>(object: &mut _cef_menu_model_delegate_t) {
        object.execute_command = Some(execute_command::<I>);
        object.mouse_outside_menu = Some(mouse_outside_menu::<I>);
        object.unhandled_open_submenu = Some(unhandled_open_submenu::<I>);
        object.unhandled_close_submenu = Some(unhandled_close_submenu::<I>);
        object.menu_will_show = Some(menu_will_show::<I>);
        object.menu_closed = Some(menu_closed::<I>);
        object.format_label = Some(format_label::<I>);
    }
    extern "C" fn execute_command<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) {
        let (arg_self_, arg_menu_model, arg_command_id, arg_event_flags) =
            (self_, menu_model, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        let result = ImplMenuModelDelegate::execute_command(
            &arg_self_.interface,
            arg_menu_model,
            arg_command_id,
            arg_event_flags,
        );
    }
    extern "C" fn mouse_outside_menu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        screen_point: *const _cef_point_t,
    ) {
        let (arg_self_, arg_menu_model, arg_screen_point) = (self_, menu_model, screen_point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_screen_point = if arg_screen_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_screen_point))
        };
        let arg_screen_point = arg_screen_point.as_ref().map(|arg| arg.as_ref());
        let result = ImplMenuModelDelegate::mouse_outside_menu(
            &arg_self_.interface,
            arg_menu_model,
            arg_screen_point,
        );
    }
    extern "C" fn unhandled_open_submenu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        is_rtl: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_menu_model, arg_is_rtl) = (self_, menu_model, is_rtl);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_is_rtl = arg_is_rtl.as_raw();
        let result = ImplMenuModelDelegate::unhandled_open_submenu(
            &arg_self_.interface,
            arg_menu_model,
            arg_is_rtl,
        );
    }
    extern "C" fn unhandled_close_submenu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        is_rtl: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_menu_model, arg_is_rtl) = (self_, menu_model, is_rtl);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_is_rtl = arg_is_rtl.as_raw();
        let result = ImplMenuModelDelegate::unhandled_close_submenu(
            &arg_self_.interface,
            arg_menu_model,
            arg_is_rtl,
        );
    }
    extern "C" fn menu_will_show<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_menu_model) = (self_, menu_model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let result = ImplMenuModelDelegate::menu_will_show(&arg_self_.interface, arg_menu_model);
    }
    extern "C" fn menu_closed<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_menu_model) = (self_, menu_model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let result = ImplMenuModelDelegate::menu_closed(&arg_self_.interface, arg_menu_model);
    }
    extern "C" fn format_label<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        label: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_menu_model, arg_label) = (self_, menu_model, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let mut arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_mut();
        let result =
            ImplMenuModelDelegate::format_label(&arg_self_.interface, arg_menu_model, arg_label);
        result.into()
    }
}
impl ImplMenuModelDelegate for MenuModelDelegate {
    fn execute_command(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) {
        unsafe {
            self.0
                .execute_command
                .map(|f| {
                    let (arg_menu_model, arg_command_id, arg_event_flags) =
                        (menu_model, command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(arg_self_, arg_menu_model, arg_command_id, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn mouse_outside_menu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        screen_point: Option<&Point>,
    ) {
        unsafe {
            self.0
                .mouse_outside_menu
                .map(|f| {
                    let (arg_menu_model, arg_screen_point) = (menu_model, screen_point);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                    let arg_screen_point = arg_screen_point
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_menu_model, arg_screen_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn unhandled_open_submenu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .unhandled_open_submenu
                .map(|f| {
                    let (arg_menu_model, arg_is_rtl) = (menu_model, is_rtl);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_rtl = arg_is_rtl;
                    let result = f(arg_self_, arg_menu_model, arg_is_rtl);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn unhandled_close_submenu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .unhandled_close_submenu
                .map(|f| {
                    let (arg_menu_model, arg_is_rtl) = (menu_model, is_rtl);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_rtl = arg_is_rtl;
                    let result = f(arg_self_, arg_menu_model, arg_is_rtl);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn menu_will_show(&self, menu_model: Option<&mut impl ImplMenuModel>) {
        unsafe {
            self.0
                .menu_will_show
                .map(|f| {
                    let arg_menu_model = menu_model;
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_menu_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn menu_closed(&self, menu_model: Option<&mut impl ImplMenuModel>) {
        unsafe {
            self.0
                .menu_closed
                .map(|f| {
                    let arg_menu_model = menu_model;
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_menu_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn format_label(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        label: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .format_label
                .map(|f| {
                    let (arg_menu_model, arg_label) = (menu_model, label);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_menu_model, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_model_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_menu_model_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuModelDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_model_delegate_t> for &MenuModelDelegate {
    fn as_raw(self) -> *mut _cef_menu_model_delegate_t {
        ImplMenuModelDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_model_delegate_t> for &mut MenuModelDelegate {
    fn as_raw(self) -> *mut _cef_menu_model_delegate_t {
        ImplMenuModelDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<MenuModelDelegate> for *mut _cef_menu_model_delegate_t {
    fn as_wrapper(self) -> MenuModelDelegate {
        MenuModelDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_model_delegate_t> for MenuModelDelegate {
    fn into(self) -> *mut _cef_menu_model_delegate_t {
        let object = ImplMenuModelDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MenuModelDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_menu_model_t] for more documentation.
#[derive(Clone)]
pub struct MenuModel(RefGuard<_cef_menu_model_t>);
impl MenuModel {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMenuModel,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMenuModel>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMenuModel>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_menu_model_t).as_wrapper()
        }
    }
}
pub trait WrapMenuModel: ImplMenuModel {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_menu_model_t, Self>);
}
pub trait ImplMenuModel: Clone + Sized + Rc {
    fn is_sub_menu(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_count(&self) -> usize {
        Default::default()
    }
    fn add_separator(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_check_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_radio_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn add_sub_menu(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> Option<MenuModel> {
        Default::default()
    }
    fn insert_separator_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn insert_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn insert_check_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn insert_radio_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn insert_sub_menu_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> Option<MenuModel> {
        Default::default()
    }
    fn remove(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn remove_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_index_of(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_command_id_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_command_id_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_label(&self, command_id: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_label_at(&self, index: usize) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_label(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_label_at(&self, index: usize, label: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_type(&self, command_id: ::std::os::raw::c_int) -> MenuItemType {
        Default::default()
    }
    fn get_type_at(&self, index: usize) -> MenuItemType {
        Default::default()
    }
    fn get_group_id(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_group_id_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_group_id(
        &self,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_group_id_at(
        &self,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_sub_menu(&self, command_id: ::std::os::raw::c_int) -> Option<MenuModel> {
        Default::default()
    }
    fn get_sub_menu_at(&self, index: usize) -> Option<MenuModel> {
        Default::default()
    }
    fn is_visible(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_visible_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_visible(
        &self,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_visible_at(
        &self,
        index: usize,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_enabled(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_enabled_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_enabled(
        &self,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_enabled_at(
        &self,
        index: usize,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_checked(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_checked_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_checked(
        &self,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_checked_at(
        &self,
        index: usize,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_accelerator_at(
        &self,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn remove_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_accelerator_at(
        &self,
        index: usize,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_font_list(
        &self,
        command_id: ::std::os::raw::c_int,
        font_list: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_font_list_at(
        &self,
        index: ::std::os::raw::c_int,
        font_list: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_menu_model_t) {
        impl_cef_menu_model_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_menu_model_t;
}
mod impl_cef_menu_model_t {
    use super::*;
    pub fn init_methods<I: ImplMenuModel>(object: &mut _cef_menu_model_t) {
        object.is_sub_menu = Some(is_sub_menu::<I>);
        object.clear = Some(clear::<I>);
        object.get_count = Some(get_count::<I>);
        object.add_separator = Some(add_separator::<I>);
        object.add_item = Some(add_item::<I>);
        object.add_check_item = Some(add_check_item::<I>);
        object.add_radio_item = Some(add_radio_item::<I>);
        object.add_sub_menu = Some(add_sub_menu::<I>);
        object.insert_separator_at = Some(insert_separator_at::<I>);
        object.insert_item_at = Some(insert_item_at::<I>);
        object.insert_check_item_at = Some(insert_check_item_at::<I>);
        object.insert_radio_item_at = Some(insert_radio_item_at::<I>);
        object.insert_sub_menu_at = Some(insert_sub_menu_at::<I>);
        object.remove = Some(remove::<I>);
        object.remove_at = Some(remove_at::<I>);
        object.get_index_of = Some(get_index_of::<I>);
        object.get_command_id_at = Some(get_command_id_at::<I>);
        object.set_command_id_at = Some(set_command_id_at::<I>);
        object.get_label = Some(get_label::<I>);
        object.get_label_at = Some(get_label_at::<I>);
        object.set_label = Some(set_label::<I>);
        object.set_label_at = Some(set_label_at::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_type_at = Some(get_type_at::<I>);
        object.get_group_id = Some(get_group_id::<I>);
        object.get_group_id_at = Some(get_group_id_at::<I>);
        object.set_group_id = Some(set_group_id::<I>);
        object.set_group_id_at = Some(set_group_id_at::<I>);
        object.get_sub_menu = Some(get_sub_menu::<I>);
        object.get_sub_menu_at = Some(get_sub_menu_at::<I>);
        object.is_visible = Some(is_visible::<I>);
        object.is_visible_at = Some(is_visible_at::<I>);
        object.set_visible = Some(set_visible::<I>);
        object.set_visible_at = Some(set_visible_at::<I>);
        object.is_enabled = Some(is_enabled::<I>);
        object.is_enabled_at = Some(is_enabled_at::<I>);
        object.set_enabled = Some(set_enabled::<I>);
        object.set_enabled_at = Some(set_enabled_at::<I>);
        object.is_checked = Some(is_checked::<I>);
        object.is_checked_at = Some(is_checked_at::<I>);
        object.set_checked = Some(set_checked::<I>);
        object.set_checked_at = Some(set_checked_at::<I>);
        object.has_accelerator = Some(has_accelerator::<I>);
        object.has_accelerator_at = Some(has_accelerator_at::<I>);
        object.set_accelerator = Some(set_accelerator::<I>);
        object.set_accelerator_at = Some(set_accelerator_at::<I>);
        object.remove_accelerator = Some(remove_accelerator::<I>);
        object.remove_accelerator_at = Some(remove_accelerator_at::<I>);
        object.get_accelerator = Some(get_accelerator::<I>);
        object.get_accelerator_at = Some(get_accelerator_at::<I>);
        object.set_color = Some(set_color::<I>);
        object.set_color_at = Some(set_color_at::<I>);
        object.get_color = Some(get_color::<I>);
        object.get_color_at = Some(get_color_at::<I>);
        object.set_font_list = Some(set_font_list::<I>);
        object.set_font_list_at = Some(set_font_list_at::<I>);
    }
    extern "C" fn is_sub_menu<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMenuModel::is_sub_menu(&arg_self_.interface);
        result.into()
    }
    extern "C" fn clear<I: ImplMenuModel>(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMenuModel::clear(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_count<I: ImplMenuModel>(self_: *mut _cef_menu_model_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMenuModel::get_count(&arg_self_.interface);
        result.into()
    }
    extern "C" fn add_separator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMenuModel::add_separator(&arg_self_.interface);
        result.into()
    }
    extern "C" fn add_item<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::add_item(&arg_self_.interface, arg_command_id, arg_label);
        result.into()
    }
    extern "C" fn add_check_item<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::add_check_item(&arg_self_.interface, arg_command_id, arg_label);
        result.into()
    }
    extern "C" fn add_radio_item<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label, arg_group_id) =
            (self_, command_id, label, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let arg_group_id = arg_group_id.as_raw();
        let result = ImplMenuModel::add_radio_item(
            &arg_self_.interface,
            arg_command_id,
            arg_label,
            arg_group_id,
        );
        result.into()
    }
    extern "C" fn add_sub_menu<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::add_sub_menu(&arg_self_.interface, arg_command_id, arg_label);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn insert_separator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::insert_separator_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn insert_item_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id, arg_label) = (self_, index, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::insert_item_at(
            &arg_self_.interface,
            arg_index,
            arg_command_id,
            arg_label,
        );
        result.into()
    }
    extern "C" fn insert_check_item_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id, arg_label) = (self_, index, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::insert_check_item_at(
            &arg_self_.interface,
            arg_index,
            arg_command_id,
            arg_label,
        );
        result.into()
    }
    extern "C" fn insert_radio_item_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id, arg_label, arg_group_id) =
            (self_, index, command_id, label, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let arg_group_id = arg_group_id.as_raw();
        let result = ImplMenuModel::insert_radio_item_at(
            &arg_self_.interface,
            arg_index,
            arg_command_id,
            arg_label,
            arg_group_id,
        );
        result.into()
    }
    extern "C" fn insert_sub_menu_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_index, arg_command_id, arg_label) = (self_, index, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::insert_sub_menu_at(
            &arg_self_.interface,
            arg_index,
            arg_command_id,
            arg_label,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn remove<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::remove(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn remove_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::remove_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_index_of<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::get_index_of(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn get_command_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::get_command_id_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn set_command_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id) = (self_, index, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let result =
            ImplMenuModel::set_command_id_at(&arg_self_.interface, arg_index, arg_command_id);
        result.into()
    }
    extern "C" fn get_label<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::get_label(&arg_self_.interface, arg_command_id);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_label_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::get_label_at(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_label<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::set_label(&arg_self_.interface, arg_command_id, arg_label);
        result.into()
    }
    extern "C" fn set_label_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_label) = (self_, index, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_ref();
        let result = ImplMenuModel::set_label_at(&arg_self_.interface, arg_index, arg_label);
        result.into()
    }
    extern "C" fn get_type<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> cef_menu_item_type_t {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::get_type(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn get_type_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> cef_menu_item_type_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::get_type_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_group_id<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::get_group_id(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn get_group_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::get_group_id_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn set_group_id<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_group_id) = (self_, command_id, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_group_id = arg_group_id.as_raw();
        let result =
            ImplMenuModel::set_group_id(&arg_self_.interface, arg_command_id, arg_group_id);
        result.into()
    }
    extern "C" fn set_group_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_group_id) = (self_, index, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_group_id = arg_group_id.as_raw();
        let result = ImplMenuModel::set_group_id_at(&arg_self_.interface, arg_index, arg_group_id);
        result.into()
    }
    extern "C" fn get_sub_menu<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::get_sub_menu(&arg_self_.interface, arg_command_id);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_sub_menu_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::get_sub_menu_at(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_visible<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::is_visible(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn is_visible_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::is_visible_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn set_visible<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_visible) = (self_, command_id, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_visible = arg_visible.as_raw();
        let result = ImplMenuModel::set_visible(&arg_self_.interface, arg_command_id, arg_visible);
        result.into()
    }
    extern "C" fn set_visible_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_visible) = (self_, index, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_visible = arg_visible.as_raw();
        let result = ImplMenuModel::set_visible_at(&arg_self_.interface, arg_index, arg_visible);
        result.into()
    }
    extern "C" fn is_enabled<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::is_enabled(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn is_enabled_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::is_enabled_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn set_enabled<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_enabled) = (self_, command_id, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_enabled = arg_enabled.as_raw();
        let result = ImplMenuModel::set_enabled(&arg_self_.interface, arg_command_id, arg_enabled);
        result.into()
    }
    extern "C" fn set_enabled_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_enabled) = (self_, index, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_enabled = arg_enabled.as_raw();
        let result = ImplMenuModel::set_enabled_at(&arg_self_.interface, arg_index, arg_enabled);
        result.into()
    }
    extern "C" fn is_checked<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::is_checked(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn is_checked_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::is_checked_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn set_checked<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_checked) = (self_, command_id, checked);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_checked = arg_checked.as_raw();
        let result = ImplMenuModel::set_checked(&arg_self_.interface, arg_command_id, arg_checked);
        result.into()
    }
    extern "C" fn set_checked_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_checked) = (self_, index, checked);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_checked = arg_checked.as_raw();
        let result = ImplMenuModel::set_checked_at(&arg_self_.interface, arg_index, arg_checked);
        result.into()
    }
    extern "C" fn has_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::has_accelerator(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn has_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::has_accelerator_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn set_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            command_id,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_key_code = arg_key_code.as_raw();
        let arg_shift_pressed = arg_shift_pressed.as_raw();
        let arg_ctrl_pressed = arg_ctrl_pressed.as_raw();
        let arg_alt_pressed = arg_alt_pressed.as_raw();
        let result = ImplMenuModel::set_accelerator(
            &arg_self_.interface,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        );
        result.into()
    }
    extern "C" fn set_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_index,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            index,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_key_code = arg_key_code.as_raw();
        let arg_shift_pressed = arg_shift_pressed.as_raw();
        let arg_ctrl_pressed = arg_ctrl_pressed.as_raw();
        let arg_alt_pressed = arg_alt_pressed.as_raw();
        let result = ImplMenuModel::set_accelerator_at(
            &arg_self_.interface,
            arg_index,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        );
        result.into()
    }
    extern "C" fn remove_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplMenuModel::remove_accelerator(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn remove_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplMenuModel::remove_accelerator_at(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            command_id,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let mut arg_key_code = if arg_key_code.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_key_code))
        };
        let arg_key_code = arg_key_code.as_mut().map(|arg| arg.as_mut());
        let mut arg_shift_pressed = if arg_shift_pressed.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_shift_pressed,
            ))
        };
        let arg_shift_pressed = arg_shift_pressed.as_mut().map(|arg| arg.as_mut());
        let mut arg_ctrl_pressed = if arg_ctrl_pressed.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_ctrl_pressed,
            ))
        };
        let arg_ctrl_pressed = arg_ctrl_pressed.as_mut().map(|arg| arg.as_mut());
        let mut arg_alt_pressed = if arg_alt_pressed.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_alt_pressed))
        };
        let arg_alt_pressed = arg_alt_pressed.as_mut().map(|arg| arg.as_mut());
        let result = ImplMenuModel::get_accelerator(
            &arg_self_.interface,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        );
        result.into()
    }
    extern "C" fn get_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_index,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            index,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_key_code = if arg_key_code.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_key_code))
        };
        let arg_key_code = arg_key_code.as_mut().map(|arg| arg.as_mut());
        let mut arg_shift_pressed = if arg_shift_pressed.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_shift_pressed,
            ))
        };
        let arg_shift_pressed = arg_shift_pressed.as_mut().map(|arg| arg.as_mut());
        let mut arg_ctrl_pressed = if arg_ctrl_pressed.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_ctrl_pressed,
            ))
        };
        let arg_ctrl_pressed = arg_ctrl_pressed.as_mut().map(|arg| arg.as_mut());
        let mut arg_alt_pressed = if arg_alt_pressed.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_alt_pressed))
        };
        let arg_alt_pressed = arg_alt_pressed.as_mut().map(|arg| arg.as_mut());
        let result = ImplMenuModel::get_accelerator_at(
            &arg_self_.interface,
            arg_index,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        );
        result.into()
    }
    extern "C" fn set_color<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_color_type, arg_color) =
            (self_, command_id, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_color = arg_color.as_raw();
        let result = ImplMenuModel::set_color(
            &arg_self_.interface,
            arg_command_id,
            arg_color_type,
            arg_color,
        );
        result.into()
    }
    extern "C" fn set_color_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_color_type, arg_color) = (self_, index, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_color = arg_color.as_raw();
        let result =
            ImplMenuModel::set_color_at(&arg_self_.interface, arg_index, arg_color_type, arg_color);
        result.into()
    }
    extern "C" fn get_color<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_color_type, arg_color) =
            (self_, command_id, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let mut arg_color = if arg_color.is_null() {
            None
        } else {
            Some(WrapParamRef::<u32>::from(arg_color))
        };
        let arg_color = arg_color.as_mut().map(|arg| arg.as_mut());
        let result = ImplMenuModel::get_color(
            &arg_self_.interface,
            arg_command_id,
            arg_color_type,
            arg_color,
        );
        result.into()
    }
    extern "C" fn get_color_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_color_type, arg_color) = (self_, index, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let mut arg_color = if arg_color.is_null() {
            None
        } else {
            Some(WrapParamRef::<u32>::from(arg_color))
        };
        let arg_color = arg_color.as_mut().map(|arg| arg.as_mut());
        let result =
            ImplMenuModel::get_color_at(&arg_self_.interface, arg_index, arg_color_type, arg_color);
        result.into()
    }
    extern "C" fn set_font_list<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        font_list: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_font_list) = (self_, command_id, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_font_list = if arg_font_list.is_null() {
            None
        } else {
            Some(arg_font_list.into())
        };
        let arg_font_list = arg_font_list.as_ref();
        let result =
            ImplMenuModel::set_font_list(&arg_self_.interface, arg_command_id, arg_font_list);
        result.into()
    }
    extern "C" fn set_font_list_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: ::std::os::raw::c_int,
        font_list: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_font_list) = (self_, index, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_font_list = if arg_font_list.is_null() {
            None
        } else {
            Some(arg_font_list.into())
        };
        let arg_font_list = arg_font_list.as_ref();
        let result =
            ImplMenuModel::set_font_list_at(&arg_self_.interface, arg_index, arg_font_list);
        result.into()
    }
}
impl ImplMenuModel for MenuModel {
    fn is_sub_menu(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_sub_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_count(&self) -> usize {
        unsafe {
            self.0
                .get_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_separator(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_separator
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_item
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_check_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_check_item
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_radio_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_radio_item
                .map(|f| {
                    let (arg_command_id, arg_label, arg_group_id) = (command_id, label, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_command_id, arg_label, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn add_sub_menu(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> Option<MenuModel> {
        unsafe {
            self.0
                .add_sub_menu
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn insert_separator_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_separator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn insert_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn insert_check_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_check_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn insert_radio_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_radio_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label, arg_group_id) =
                        (index, command_id, label, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_group_id = arg_group_id;
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_command_id,
                        arg_label,
                        arg_group_id,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn insert_sub_menu_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> Option<MenuModel> {
        unsafe {
            self.0
                .insert_sub_menu_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn remove(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn remove_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_index_of(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_index_of
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_command_id_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_command_id_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_command_id_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_command_id_at
                .map(|f| {
                    let (arg_index, arg_command_id) = (index, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_index, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_label(&self, command_id: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_label
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_label_at(&self, index: usize) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_label_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_label(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_label
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_label_at(&self, index: usize, label: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_label_at
                .map(|f| {
                    let (arg_index, arg_label) = (index, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_label = arg_label
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self, command_id: ::std::os::raw::c_int) -> MenuItemType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_type_at(&self, index: usize) -> MenuItemType {
        unsafe {
            self.0
                .get_type_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_group_id(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_group_id_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_group_id(
        &self,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_group_id
                .map(|f| {
                    let (arg_command_id, arg_group_id) = (command_id, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_command_id, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_group_id_at(
        &self,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_group_id_at
                .map(|f| {
                    let (arg_index, arg_group_id) = (index, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_index, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_sub_menu(&self, command_id: ::std::os::raw::c_int) -> Option<MenuModel> {
        unsafe {
            self.0
                .get_sub_menu
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_sub_menu_at(&self, index: usize) -> Option<MenuModel> {
        unsafe {
            self.0
                .get_sub_menu_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_visible(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_visible_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_visible(
        &self,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_visible
                .map(|f| {
                    let (arg_command_id, arg_visible) = (command_id, visible);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_command_id, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_visible_at(
        &self,
        index: usize,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_visible_at
                .map(|f| {
                    let (arg_index, arg_visible) = (index, visible);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_index, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_enabled(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_enabled_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_enabled(
        &self,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_enabled
                .map(|f| {
                    let (arg_command_id, arg_enabled) = (command_id, enabled);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_command_id, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_enabled_at(
        &self,
        index: usize,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_enabled_at
                .map(|f| {
                    let (arg_index, arg_enabled) = (index, enabled);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_index, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_checked(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_checked
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_checked_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_checked_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_checked(
        &self,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_checked
                .map(|f| {
                    let (arg_command_id, arg_checked) = (command_id, checked);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_checked = arg_checked;
                    let result = f(arg_self_, arg_command_id, arg_checked);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_checked_at(
        &self,
        index: usize,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_checked_at
                .map(|f| {
                    let (arg_index, arg_checked) = (index, checked);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_checked = arg_checked;
                    let result = f(arg_self_, arg_index, arg_checked);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_accelerator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_key_code = arg_key_code;
                    let arg_shift_pressed = arg_shift_pressed;
                    let arg_ctrl_pressed = arg_ctrl_pressed;
                    let arg_alt_pressed = arg_alt_pressed;
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_accelerator_at(
        &self,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_accelerator_at
                .map(|f| {
                    let (
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (index, key_code, shift_pressed, ctrl_pressed, alt_pressed);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_key_code = arg_key_code;
                    let arg_shift_pressed = arg_shift_pressed;
                    let arg_ctrl_pressed = arg_ctrl_pressed;
                    let arg_alt_pressed = arg_alt_pressed;
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn remove_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_accelerator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_key_code = arg_key_code
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_shift_pressed = arg_shift_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_ctrl_pressed = arg_ctrl_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_alt_pressed = arg_alt_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_accelerator_at(
        &self,
        index: usize,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_accelerator_at
                .map(|f| {
                    let (
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (index, key_code, shift_pressed, ctrl_pressed, alt_pressed);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_key_code = arg_key_code
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_shift_pressed = arg_shift_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_ctrl_pressed = arg_ctrl_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_alt_pressed = arg_alt_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_color
                .map(|f| {
                    let (arg_command_id, arg_color_type, arg_color) =
                        (command_id, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_command_id, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_color_at
                .map(|f| {
                    let (arg_index, arg_color_type, arg_color) = (index, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_index, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_color
                .map(|f| {
                    let (arg_command_id, arg_color_type, arg_color) =
                        (command_id, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_command_id, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_color_at
                .map(|f| {
                    let (arg_index, arg_color_type, arg_color) = (index, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_font_list(
        &self,
        command_id: ::std::os::raw::c_int,
        font_list: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_font_list
                .map(|f| {
                    let (arg_command_id, arg_font_list) = (command_id, font_list);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_font_list = arg_font_list
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_font_list_at(
        &self,
        index: ::std::os::raw::c_int,
        font_list: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_font_list_at
                .map(|f| {
                    let (arg_index, arg_font_list) = (index, font_list);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_font_list = arg_font_list
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_model_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_menu_model_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuModel {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_model_t> for &MenuModel {
    fn as_raw(self) -> *mut _cef_menu_model_t {
        ImplMenuModel::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_model_t> for &mut MenuModel {
    fn as_raw(self) -> *mut _cef_menu_model_t {
        ImplMenuModel::get_raw(self)
    }
}
impl ConvertReturnValue<MenuModel> for *mut _cef_menu_model_t {
    fn as_wrapper(self) -> MenuModel {
        MenuModel(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_model_t> for MenuModel {
    fn into(self) -> *mut _cef_menu_model_t {
        let object = ImplMenuModel::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MenuModel {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_run_context_menu_callback_t] for more documentation.
#[derive(Clone)]
pub struct RunContextMenuCallback(RefGuard<_cef_run_context_menu_callback_t>);
impl RunContextMenuCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRunContextMenuCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRunContextMenuCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRunContextMenuCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_run_context_menu_callback_t).as_wrapper()
        }
    }
}
pub trait WrapRunContextMenuCallback: ImplRunContextMenuCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_run_context_menu_callback_t, Self>);
}
pub trait ImplRunContextMenuCallback: Clone + Sized + Rc {
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {}
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_run_context_menu_callback_t) {
        impl_cef_run_context_menu_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_run_context_menu_callback_t;
}
mod impl_cef_run_context_menu_callback_t {
    use super::*;
    pub fn init_methods<I: ImplRunContextMenuCallback>(
        object: &mut _cef_run_context_menu_callback_t,
    ) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplRunContextMenuCallback>(
        self_: *mut _cef_run_context_menu_callback_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) {
        let (arg_self_, arg_command_id, arg_event_flags) = (self_, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        let result =
            ImplRunContextMenuCallback::cont(&arg_self_.interface, arg_command_id, arg_event_flags);
    }
    extern "C" fn cancel<I: ImplRunContextMenuCallback>(
        self_: *mut _cef_run_context_menu_callback_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRunContextMenuCallback::cancel(&arg_self_.interface);
    }
}
impl ImplRunContextMenuCallback for RunContextMenuCallback {
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_command_id, arg_event_flags) = (command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_run_context_menu_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_run_context_menu_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunContextMenuCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_context_menu_callback_t> for &RunContextMenuCallback {
    fn as_raw(self) -> *mut _cef_run_context_menu_callback_t {
        ImplRunContextMenuCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_run_context_menu_callback_t> for &mut RunContextMenuCallback {
    fn as_raw(self) -> *mut _cef_run_context_menu_callback_t {
        ImplRunContextMenuCallback::get_raw(self)
    }
}
impl ConvertReturnValue<RunContextMenuCallback> for *mut _cef_run_context_menu_callback_t {
    fn as_wrapper(self) -> RunContextMenuCallback {
        RunContextMenuCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_run_context_menu_callback_t> for RunContextMenuCallback {
    fn into(self) -> *mut _cef_run_context_menu_callback_t {
        let object = ImplRunContextMenuCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RunContextMenuCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_run_quick_menu_callback_t] for more documentation.
#[derive(Clone)]
pub struct RunQuickMenuCallback(RefGuard<_cef_run_quick_menu_callback_t>);
impl RunQuickMenuCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRunQuickMenuCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRunQuickMenuCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRunQuickMenuCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_run_quick_menu_callback_t).as_wrapper()
        }
    }
}
pub trait WrapRunQuickMenuCallback: ImplRunQuickMenuCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_run_quick_menu_callback_t, Self>);
}
pub trait ImplRunQuickMenuCallback: Clone + Sized + Rc {
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {}
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_run_quick_menu_callback_t) {
        impl_cef_run_quick_menu_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_run_quick_menu_callback_t;
}
mod impl_cef_run_quick_menu_callback_t {
    use super::*;
    pub fn init_methods<I: ImplRunQuickMenuCallback>(object: &mut _cef_run_quick_menu_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplRunQuickMenuCallback>(
        self_: *mut _cef_run_quick_menu_callback_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) {
        let (arg_self_, arg_command_id, arg_event_flags) = (self_, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        let result =
            ImplRunQuickMenuCallback::cont(&arg_self_.interface, arg_command_id, arg_event_flags);
    }
    extern "C" fn cancel<I: ImplRunQuickMenuCallback>(self_: *mut _cef_run_quick_menu_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRunQuickMenuCallback::cancel(&arg_self_.interface);
    }
}
impl ImplRunQuickMenuCallback for RunQuickMenuCallback {
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_command_id, arg_event_flags) = (command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_run_quick_menu_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_run_quick_menu_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunQuickMenuCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_quick_menu_callback_t> for &RunQuickMenuCallback {
    fn as_raw(self) -> *mut _cef_run_quick_menu_callback_t {
        ImplRunQuickMenuCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_run_quick_menu_callback_t> for &mut RunQuickMenuCallback {
    fn as_raw(self) -> *mut _cef_run_quick_menu_callback_t {
        ImplRunQuickMenuCallback::get_raw(self)
    }
}
impl ConvertReturnValue<RunQuickMenuCallback> for *mut _cef_run_quick_menu_callback_t {
    fn as_wrapper(self) -> RunQuickMenuCallback {
        RunQuickMenuCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_run_quick_menu_callback_t> for RunQuickMenuCallback {
    fn into(self) -> *mut _cef_run_quick_menu_callback_t {
        let object = ImplRunQuickMenuCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RunQuickMenuCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_context_menu_handler_t] for more documentation.
#[derive(Clone)]
pub struct ContextMenuHandler(RefGuard<_cef_context_menu_handler_t>);
impl ContextMenuHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapContextMenuHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplContextMenuHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapContextMenuHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_context_menu_handler_t).as_wrapper()
        }
    }
}
pub trait WrapContextMenuHandler: ImplContextMenuHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_context_menu_handler_t, Self>);
}
pub trait ImplContextMenuHandler: Clone + Sized + Rc {
    fn on_before_context_menu(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        params: Option<&mut impl ImplContextMenuParams>,
        model: Option<&mut impl ImplMenuModel>,
    ) {
    }
    fn run_context_menu(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        params: Option<&mut impl ImplContextMenuParams>,
        model: Option<&mut impl ImplMenuModel>,
        callback: Option<&mut impl ImplRunContextMenuCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_context_menu_command(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        params: Option<&mut impl ImplContextMenuParams>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_context_menu_dismissed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
    }
    fn run_quick_menu(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        location: Option<&Point>,
        size: Option<&Size>,
        edit_state_flags: QuickMenuEditStateFlags,
        callback: Option<&mut impl ImplRunQuickMenuCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_quick_menu_command(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_quick_menu_dismissed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
    }
    fn init_methods(object: &mut _cef_context_menu_handler_t) {
        impl_cef_context_menu_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_context_menu_handler_t;
}
mod impl_cef_context_menu_handler_t {
    use super::*;
    pub fn init_methods<I: ImplContextMenuHandler>(object: &mut _cef_context_menu_handler_t) {
        object.on_before_context_menu = Some(on_before_context_menu::<I>);
        object.run_context_menu = Some(run_context_menu::<I>);
        object.on_context_menu_command = Some(on_context_menu_command::<I>);
        object.on_context_menu_dismissed = Some(on_context_menu_dismissed::<I>);
        object.run_quick_menu = Some(run_quick_menu::<I>);
        object.on_quick_menu_command = Some(on_quick_menu_command::<I>);
        object.on_quick_menu_dismissed = Some(on_quick_menu_dismissed::<I>);
    }
    extern "C" fn on_before_context_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_model) =
            (self_, browser, frame, params, model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_params = unsafe { arg_params.as_mut() }
            .map(|arg| ContextMenuParams(unsafe { RefGuard::from_raw(arg) }));
        let arg_params = arg_params.as_mut();
        let mut arg_model =
            unsafe { arg_model.as_mut() }.map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_model = arg_model.as_mut();
        let result = ImplContextMenuHandler::on_before_context_menu(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_params,
            arg_model,
        );
    }
    extern "C" fn run_context_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        model: *mut _cef_menu_model_t,
        callback: *mut _cef_run_context_menu_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_model, arg_callback) =
            (self_, browser, frame, params, model, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_params = unsafe { arg_params.as_mut() }
            .map(|arg| ContextMenuParams(unsafe { RefGuard::from_raw(arg) }));
        let arg_params = arg_params.as_mut();
        let mut arg_model =
            unsafe { arg_model.as_mut() }.map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_model = arg_model.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| RunContextMenuCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplContextMenuHandler::run_context_menu(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_params,
            arg_model,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_context_menu_command<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_command_id, arg_event_flags) =
            (self_, browser, frame, params, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_params = unsafe { arg_params.as_mut() }
            .map(|arg| ContextMenuParams(unsafe { RefGuard::from_raw(arg) }));
        let arg_params = arg_params.as_mut();
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        let result = ImplContextMenuHandler::on_context_menu_command(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_params,
            arg_command_id,
            arg_event_flags,
        );
        result.into()
    }
    extern "C" fn on_context_menu_dismissed<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let result = ImplContextMenuHandler::on_context_menu_dismissed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
        );
    }
    extern "C" fn run_quick_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        location: *const _cef_point_t,
        size: *const _cef_size_t,
        edit_state_flags: cef_quick_menu_edit_state_flags_t,
        callback: *mut _cef_run_quick_menu_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_location,
            arg_size,
            arg_edit_state_flags,
            arg_callback,
        ) = (
            self_,
            browser,
            frame,
            location,
            size,
            edit_state_flags,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_location = if arg_location.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_location))
        };
        let arg_location = arg_location.as_ref().map(|arg| arg.as_ref());
        let arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_size))
        };
        let arg_size = arg_size.as_ref().map(|arg| arg.as_ref());
        let arg_edit_state_flags = arg_edit_state_flags.as_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| RunQuickMenuCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplContextMenuHandler::run_quick_menu(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_location,
            arg_size,
            arg_edit_state_flags,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_quick_menu_command<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_command_id, arg_event_flags) =
            (self_, browser, frame, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        let result = ImplContextMenuHandler::on_quick_menu_command(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_command_id,
            arg_event_flags,
        );
        result.into()
    }
    extern "C" fn on_quick_menu_dismissed<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let result = ImplContextMenuHandler::on_quick_menu_dismissed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
        );
    }
}
impl ImplContextMenuHandler for ContextMenuHandler {
    fn on_before_context_menu(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        params: Option<&mut impl ImplContextMenuParams>,
        model: Option<&mut impl ImplMenuModel>,
    ) {
        unsafe {
            self.0
                .on_before_context_menu
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_model) =
                        (browser, frame, params, model);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_params = arg_params
                        .map(|arg| {
                            arg.add_ref();
                            ImplContextMenuParams::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_model = arg_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_params, arg_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn run_context_menu(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        params: Option<&mut impl ImplContextMenuParams>,
        model: Option<&mut impl ImplMenuModel>,
        callback: Option<&mut impl ImplRunContextMenuCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .run_context_menu
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_model, arg_callback) =
                        (browser, frame, params, model, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_params = arg_params
                        .map(|arg| {
                            arg.add_ref();
                            ImplContextMenuParams::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_model = arg_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplRunContextMenuCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_params,
                        arg_model,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_context_menu_command(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        params: Option<&mut impl ImplContextMenuParams>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_context_menu_command
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_command_id, arg_event_flags) =
                        (browser, frame, params, command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_params = arg_params
                        .map(|arg| {
                            arg.add_ref();
                            ImplContextMenuParams::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_params,
                        arg_command_id,
                        arg_event_flags,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_context_menu_dismissed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
        unsafe {
            self.0
                .on_context_menu_dismissed
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn run_quick_menu(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        location: Option<&Point>,
        size: Option<&Size>,
        edit_state_flags: QuickMenuEditStateFlags,
        callback: Option<&mut impl ImplRunQuickMenuCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .run_quick_menu
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_location,
                        arg_size,
                        arg_edit_state_flags,
                        arg_callback,
                    ) = (browser, frame, location, size, edit_state_flags, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_location = arg_location.cloned().map(|arg| arg.into());
                    let arg_location = arg_location
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_edit_state_flags = arg_edit_state_flags.as_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplRunQuickMenuCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_location,
                        arg_size,
                        arg_edit_state_flags,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_quick_menu_command(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_quick_menu_command
                .map(|f| {
                    let (arg_browser, arg_frame, arg_command_id, arg_event_flags) =
                        (browser, frame, command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_command_id,
                        arg_event_flags,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_quick_menu_dismissed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
        unsafe {
            self.0
                .on_quick_menu_dismissed
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_context_menu_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_context_menu_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ContextMenuHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_context_menu_handler_t> for &ContextMenuHandler {
    fn as_raw(self) -> *mut _cef_context_menu_handler_t {
        ImplContextMenuHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_context_menu_handler_t> for &mut ContextMenuHandler {
    fn as_raw(self) -> *mut _cef_context_menu_handler_t {
        ImplContextMenuHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ContextMenuHandler> for *mut _cef_context_menu_handler_t {
    fn as_wrapper(self) -> ContextMenuHandler {
        ContextMenuHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_context_menu_handler_t> for ContextMenuHandler {
    fn into(self) -> *mut _cef_context_menu_handler_t {
        let object = ImplContextMenuHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ContextMenuHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_context_menu_params_t] for more documentation.
#[derive(Clone)]
pub struct ContextMenuParams(RefGuard<_cef_context_menu_params_t>);
impl ContextMenuParams {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapContextMenuParams,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplContextMenuParams>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapContextMenuParams>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_context_menu_params_t).as_wrapper()
        }
    }
}
pub trait WrapContextMenuParams: ImplContextMenuParams {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_context_menu_params_t, Self>);
}
pub trait ImplContextMenuParams: Clone + Sized + Rc {
    fn get_xcoord(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_ycoord(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_type_flags(&self) -> ContextMenuTypeFlags {
        Default::default()
    }
    fn get_link_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_unfiltered_link_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_source_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn has_image_contents(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_title_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_page_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_frame_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_frame_charset(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_media_type(&self) -> ContextMenuMediaType {
        Default::default()
    }
    fn get_media_state_flags(&self) -> ContextMenuMediaStateFlags {
        Default::default()
    }
    fn get_selection_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_misspelled_word(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_dictionary_suggestions(
        &self,
        suggestions: Option<&mut CefStringList>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_editable(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_spell_check_enabled(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_edit_state_flags(&self) -> ContextMenuEditStateFlags {
        Default::default()
    }
    fn is_custom_menu(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_context_menu_params_t) {
        impl_cef_context_menu_params_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_context_menu_params_t;
}
mod impl_cef_context_menu_params_t {
    use super::*;
    pub fn init_methods<I: ImplContextMenuParams>(object: &mut _cef_context_menu_params_t) {
        object.get_xcoord = Some(get_xcoord::<I>);
        object.get_ycoord = Some(get_ycoord::<I>);
        object.get_type_flags = Some(get_type_flags::<I>);
        object.get_link_url = Some(get_link_url::<I>);
        object.get_unfiltered_link_url = Some(get_unfiltered_link_url::<I>);
        object.get_source_url = Some(get_source_url::<I>);
        object.has_image_contents = Some(has_image_contents::<I>);
        object.get_title_text = Some(get_title_text::<I>);
        object.get_page_url = Some(get_page_url::<I>);
        object.get_frame_url = Some(get_frame_url::<I>);
        object.get_frame_charset = Some(get_frame_charset::<I>);
        object.get_media_type = Some(get_media_type::<I>);
        object.get_media_state_flags = Some(get_media_state_flags::<I>);
        object.get_selection_text = Some(get_selection_text::<I>);
        object.get_misspelled_word = Some(get_misspelled_word::<I>);
        object.get_dictionary_suggestions = Some(get_dictionary_suggestions::<I>);
        object.is_editable = Some(is_editable::<I>);
        object.is_spell_check_enabled = Some(is_spell_check_enabled::<I>);
        object.get_edit_state_flags = Some(get_edit_state_flags::<I>);
        object.is_custom_menu = Some(is_custom_menu::<I>);
    }
    extern "C" fn get_xcoord<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_xcoord(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_ycoord<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_ycoord(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_type_flags<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_type_flags_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_type_flags(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_link_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_link_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_unfiltered_link_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_unfiltered_link_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_source_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_source_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn has_image_contents<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::has_image_contents(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_title_text<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_title_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_page_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_page_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_frame_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame_charset<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_frame_charset(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_media_type<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_media_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_media_type(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_media_state_flags<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_media_state_flags_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_media_state_flags(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_selection_text<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_selection_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_misspelled_word<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_misspelled_word(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_dictionary_suggestions<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
        suggestions: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_suggestions) = (self_, suggestions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_suggestions = if arg_suggestions.is_null() {
            None
        } else {
            Some(arg_suggestions.into())
        };
        let arg_suggestions = arg_suggestions.as_mut();
        let result = ImplContextMenuParams::get_dictionary_suggestions(
            &arg_self_.interface,
            arg_suggestions,
        );
        result.into()
    }
    extern "C" fn is_editable<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::is_editable(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_spell_check_enabled<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::is_spell_check_enabled(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_edit_state_flags<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_edit_state_flags_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::get_edit_state_flags(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_custom_menu<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplContextMenuParams::is_custom_menu(&arg_self_.interface);
        result.into()
    }
}
impl ImplContextMenuParams for ContextMenuParams {
    fn get_xcoord(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_xcoord
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_ycoord(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_ycoord
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_type_flags(&self) -> ContextMenuTypeFlags {
        unsafe {
            self.0
                .get_type_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_link_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_link_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_unfiltered_link_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_unfiltered_link_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_source_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_source_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn has_image_contents(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_image_contents
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_title_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_title_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_page_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_page_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_frame_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_charset(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_frame_charset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_media_type(&self) -> ContextMenuMediaType {
        unsafe {
            self.0
                .get_media_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_media_state_flags(&self) -> ContextMenuMediaStateFlags {
        unsafe {
            self.0
                .get_media_state_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_selection_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_selection_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_misspelled_word(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_misspelled_word
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_dictionary_suggestions(
        &self,
        suggestions: Option<&mut CefStringList>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_dictionary_suggestions
                .map(|f| {
                    let arg_suggestions = suggestions;
                    let arg_self_ = self.as_raw();
                    let arg_suggestions = arg_suggestions
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_suggestions);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_editable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_editable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_spell_check_enabled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_spell_check_enabled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_edit_state_flags(&self) -> ContextMenuEditStateFlags {
        unsafe {
            self.0
                .get_edit_state_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_custom_menu(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_custom_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_context_menu_params_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_context_menu_params_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ContextMenuParams {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_context_menu_params_t> for &ContextMenuParams {
    fn as_raw(self) -> *mut _cef_context_menu_params_t {
        ImplContextMenuParams::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_context_menu_params_t> for &mut ContextMenuParams {
    fn as_raw(self) -> *mut _cef_context_menu_params_t {
        ImplContextMenuParams::get_raw(self)
    }
}
impl ConvertReturnValue<ContextMenuParams> for *mut _cef_context_menu_params_t {
    fn as_wrapper(self) -> ContextMenuParams {
        ContextMenuParams(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_context_menu_params_t> for ContextMenuParams {
    fn into(self) -> *mut _cef_context_menu_params_t {
        let object = ImplContextMenuParams::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ContextMenuParams {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_file_dialog_callback_t] for more documentation.
#[derive(Clone)]
pub struct FileDialogCallback(RefGuard<_cef_file_dialog_callback_t>);
impl FileDialogCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFileDialogCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFileDialogCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFileDialogCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_file_dialog_callback_t).as_wrapper()
        }
    }
}
pub trait WrapFileDialogCallback: ImplFileDialogCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_file_dialog_callback_t, Self>);
}
pub trait ImplFileDialogCallback: Clone + Sized + Rc {
    fn cont(&self, file_paths: Option<&mut CefStringList>) {}
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_file_dialog_callback_t) {
        impl_cef_file_dialog_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_file_dialog_callback_t;
}
mod impl_cef_file_dialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplFileDialogCallback>(object: &mut _cef_file_dialog_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplFileDialogCallback>(
        self_: *mut _cef_file_dialog_callback_t,
        file_paths: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_file_paths) = (self_, file_paths);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_file_paths = if arg_file_paths.is_null() {
            None
        } else {
            Some(arg_file_paths.into())
        };
        let arg_file_paths = arg_file_paths.as_mut();
        let result = ImplFileDialogCallback::cont(&arg_self_.interface, arg_file_paths);
    }
    extern "C" fn cancel<I: ImplFileDialogCallback>(self_: *mut _cef_file_dialog_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplFileDialogCallback::cancel(&arg_self_.interface);
    }
}
impl ImplFileDialogCallback for FileDialogCallback {
    fn cont(&self, file_paths: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_file_paths = file_paths;
                    let arg_self_ = self.as_raw();
                    let arg_file_paths = arg_file_paths
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_file_paths);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_file_dialog_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_file_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FileDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_file_dialog_callback_t> for &FileDialogCallback {
    fn as_raw(self) -> *mut _cef_file_dialog_callback_t {
        ImplFileDialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_file_dialog_callback_t> for &mut FileDialogCallback {
    fn as_raw(self) -> *mut _cef_file_dialog_callback_t {
        ImplFileDialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<FileDialogCallback> for *mut _cef_file_dialog_callback_t {
    fn as_wrapper(self) -> FileDialogCallback {
        FileDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_file_dialog_callback_t> for FileDialogCallback {
    fn into(self) -> *mut _cef_file_dialog_callback_t {
        let object = ImplFileDialogCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for FileDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_dialog_handler_t] for more documentation.
#[derive(Clone)]
pub struct DialogHandler(RefGuard<_cef_dialog_handler_t>);
impl DialogHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDialogHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDialogHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDialogHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_dialog_handler_t).as_wrapper()
        }
    }
}
pub trait WrapDialogHandler: ImplDialogHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_dialog_handler_t, Self>);
}
pub trait ImplDialogHandler: Clone + Sized + Rc {
    fn on_file_dialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        mode: FileDialogMode,
        title: Option<&CefStringUtf16>,
        default_file_path: Option<&CefStringUtf16>,
        accept_filters: Option<&mut CefStringList>,
        accept_extensions: Option<&mut CefStringList>,
        accept_descriptions: Option<&mut CefStringList>,
        callback: Option<&mut impl ImplFileDialogCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_dialog_handler_t) {
        impl_cef_dialog_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_dialog_handler_t;
}
mod impl_cef_dialog_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDialogHandler>(object: &mut _cef_dialog_handler_t) {
        object.on_file_dialog = Some(on_file_dialog::<I>);
    }
    extern "C" fn on_file_dialog<I: ImplDialogHandler>(
        self_: *mut _cef_dialog_handler_t,
        browser: *mut _cef_browser_t,
        mode: cef_file_dialog_mode_t,
        title: *const _cef_string_utf16_t,
        default_file_path: *const _cef_string_utf16_t,
        accept_filters: *mut _cef_string_list_t,
        accept_extensions: *mut _cef_string_list_t,
        accept_descriptions: *mut _cef_string_list_t,
        callback: *mut _cef_file_dialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_accept_extensions,
            arg_accept_descriptions,
            arg_callback,
        ) = (
            self_,
            browser,
            mode,
            title,
            default_file_path,
            accept_filters,
            accept_extensions,
            accept_descriptions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_mode = arg_mode.as_raw();
        let arg_title = if arg_title.is_null() {
            None
        } else {
            Some(arg_title.into())
        };
        let arg_title = arg_title.as_ref();
        let arg_default_file_path = if arg_default_file_path.is_null() {
            None
        } else {
            Some(arg_default_file_path.into())
        };
        let arg_default_file_path = arg_default_file_path.as_ref();
        let mut arg_accept_filters = if arg_accept_filters.is_null() {
            None
        } else {
            Some(arg_accept_filters.into())
        };
        let arg_accept_filters = arg_accept_filters.as_mut();
        let mut arg_accept_extensions = if arg_accept_extensions.is_null() {
            None
        } else {
            Some(arg_accept_extensions.into())
        };
        let arg_accept_extensions = arg_accept_extensions.as_mut();
        let mut arg_accept_descriptions = if arg_accept_descriptions.is_null() {
            None
        } else {
            Some(arg_accept_descriptions.into())
        };
        let arg_accept_descriptions = arg_accept_descriptions.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| FileDialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplDialogHandler::on_file_dialog(
            &arg_self_.interface,
            arg_browser,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_accept_extensions,
            arg_accept_descriptions,
            arg_callback,
        );
        result.into()
    }
}
impl ImplDialogHandler for DialogHandler {
    fn on_file_dialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        mode: FileDialogMode,
        title: Option<&CefStringUtf16>,
        default_file_path: Option<&CefStringUtf16>,
        accept_filters: Option<&mut CefStringList>,
        accept_extensions: Option<&mut CefStringList>,
        accept_descriptions: Option<&mut CefStringList>,
        callback: Option<&mut impl ImplFileDialogCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_file_dialog
                .map(|f| {
                    let (
                        arg_browser,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_accept_extensions,
                        arg_accept_descriptions,
                        arg_callback,
                    ) = (
                        browser,
                        mode,
                        title,
                        default_file_path,
                        accept_filters,
                        accept_extensions,
                        accept_descriptions,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_mode = arg_mode.as_raw();
                    let arg_title = arg_title
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_default_file_path = arg_default_file_path
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_accept_filters = arg_accept_filters
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let arg_accept_extensions = arg_accept_extensions
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let arg_accept_descriptions = arg_accept_descriptions
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplFileDialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_accept_extensions,
                        arg_accept_descriptions,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_dialog_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_dialog_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DialogHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dialog_handler_t> for &DialogHandler {
    fn as_raw(self) -> *mut _cef_dialog_handler_t {
        ImplDialogHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_dialog_handler_t> for &mut DialogHandler {
    fn as_raw(self) -> *mut _cef_dialog_handler_t {
        ImplDialogHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DialogHandler> for *mut _cef_dialog_handler_t {
    fn as_wrapper(self) -> DialogHandler {
        DialogHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_dialog_handler_t> for DialogHandler {
    fn into(self) -> *mut _cef_dialog_handler_t {
        let object = ImplDialogHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DialogHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_display_handler_t] for more documentation.
#[derive(Clone)]
pub struct DisplayHandler(RefGuard<_cef_display_handler_t>);
impl DisplayHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDisplayHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDisplayHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDisplayHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_display_handler_t).as_wrapper()
        }
    }
}
pub trait WrapDisplayHandler: ImplDisplayHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_display_handler_t, Self>);
}
pub trait ImplDisplayHandler: Clone + Sized + Rc {
    fn on_address_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        url: Option<&CefStringUtf16>,
    ) {
    }
    fn on_title_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        title: Option<&CefStringUtf16>,
    ) {
    }
    fn on_favicon_urlchange(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        icon_urls: Option<&mut CefStringList>,
    ) {
    }
    fn on_fullscreen_mode_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        fullscreen: ::std::os::raw::c_int,
    ) {
    }
    fn on_tooltip(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        text: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_status_message(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        value: Option<&CefStringUtf16>,
    ) {
    }
    fn on_console_message(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        level: LogSeverity,
        message: Option<&CefStringUtf16>,
        source: Option<&CefStringUtf16>,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_auto_resize(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        new_size: Option<&Size>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_loading_progress_change(&self, browser: Option<&mut impl ImplBrowser>, progress: f64) {}
    fn on_cursor_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        cursor: ::std::os::raw::c_ulong,
        type_: CursorType,
        custom_cursor_info: Option<&CursorInfo>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_media_access_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
    }
    fn init_methods(object: &mut _cef_display_handler_t) {
        impl_cef_display_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_display_handler_t;
}
mod impl_cef_display_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDisplayHandler>(object: &mut _cef_display_handler_t) {
        object.on_address_change = Some(on_address_change::<I>);
        object.on_title_change = Some(on_title_change::<I>);
        object.on_favicon_urlchange = Some(on_favicon_urlchange::<I>);
        object.on_fullscreen_mode_change = Some(on_fullscreen_mode_change::<I>);
        object.on_tooltip = Some(on_tooltip::<I>);
        object.on_status_message = Some(on_status_message::<I>);
        object.on_console_message = Some(on_console_message::<I>);
        object.on_auto_resize = Some(on_auto_resize::<I>);
        object.on_loading_progress_change = Some(on_loading_progress_change::<I>);
        object.on_cursor_change = Some(on_cursor_change::<I>);
        object.on_media_access_change = Some(on_media_access_change::<I>);
    }
    extern "C" fn on_address_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_url) = (self_, browser, frame, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let result = ImplDisplayHandler::on_address_change(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_url,
        );
    }
    extern "C" fn on_title_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        title: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_title) = (self_, browser, title);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_title = if arg_title.is_null() {
            None
        } else {
            Some(arg_title.into())
        };
        let arg_title = arg_title.as_ref();
        let result =
            ImplDisplayHandler::on_title_change(&arg_self_.interface, arg_browser, arg_title);
    }
    extern "C" fn on_favicon_urlchange<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        icon_urls: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_browser, arg_icon_urls) = (self_, browser, icon_urls);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_icon_urls = if arg_icon_urls.is_null() {
            None
        } else {
            Some(arg_icon_urls.into())
        };
        let arg_icon_urls = arg_icon_urls.as_mut();
        let result = ImplDisplayHandler::on_favicon_urlchange(
            &arg_self_.interface,
            arg_browser,
            arg_icon_urls,
        );
    }
    extern "C" fn on_fullscreen_mode_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        fullscreen: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_fullscreen) = (self_, browser, fullscreen);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_fullscreen = arg_fullscreen.as_raw();
        let result = ImplDisplayHandler::on_fullscreen_mode_change(
            &arg_self_.interface,
            arg_browser,
            arg_fullscreen,
        );
    }
    extern "C" fn on_tooltip<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        text: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_text) = (self_, browser, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_mut();
        let result = ImplDisplayHandler::on_tooltip(&arg_self_.interface, arg_browser, arg_text);
        result.into()
    }
    extern "C" fn on_status_message<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        value: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_value) = (self_, browser, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let result =
            ImplDisplayHandler::on_status_message(&arg_self_.interface, arg_browser, arg_value);
    }
    extern "C" fn on_console_message<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        level: cef_log_severity_t,
        message: *const _cef_string_utf16_t,
        source: *const _cef_string_utf16_t,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_level, arg_message, arg_source, arg_line) =
            (self_, browser, level, message, source, line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_level = arg_level.as_raw();
        let arg_message = if arg_message.is_null() {
            None
        } else {
            Some(arg_message.into())
        };
        let arg_message = arg_message.as_ref();
        let arg_source = if arg_source.is_null() {
            None
        } else {
            Some(arg_source.into())
        };
        let arg_source = arg_source.as_ref();
        let arg_line = arg_line.as_raw();
        let result = ImplDisplayHandler::on_console_message(
            &arg_self_.interface,
            arg_browser,
            arg_level,
            arg_message,
            arg_source,
            arg_line,
        );
        result.into()
    }
    extern "C" fn on_auto_resize<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        new_size: *const _cef_size_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_new_size) = (self_, browser, new_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_new_size = if arg_new_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_new_size))
        };
        let arg_new_size = arg_new_size.as_ref().map(|arg| arg.as_ref());
        let result =
            ImplDisplayHandler::on_auto_resize(&arg_self_.interface, arg_browser, arg_new_size);
        result.into()
    }
    extern "C" fn on_loading_progress_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        progress: f64,
    ) {
        let (arg_self_, arg_browser, arg_progress) = (self_, browser, progress);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_progress = arg_progress.as_raw();
        let result = ImplDisplayHandler::on_loading_progress_change(
            &arg_self_.interface,
            arg_browser,
            arg_progress,
        );
    }
    extern "C" fn on_cursor_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        cursor: ::std::os::raw::c_ulong,
        type_: cef_cursor_type_t,
        custom_cursor_info: *const _cef_cursor_info_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_cursor, arg_type_, arg_custom_cursor_info) =
            (self_, browser, cursor, type_, custom_cursor_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_cursor = arg_cursor.as_raw();
        let arg_type_ = arg_type_.as_raw();
        let arg_custom_cursor_info = if arg_custom_cursor_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<CursorInfo>::from(arg_custom_cursor_info))
        };
        let arg_custom_cursor_info = arg_custom_cursor_info.as_ref().map(|arg| arg.as_ref());
        let result = ImplDisplayHandler::on_cursor_change(
            &arg_self_.interface,
            arg_browser,
            arg_cursor,
            arg_type_,
            arg_custom_cursor_info,
        );
        result.into()
    }
    extern "C" fn on_media_access_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_has_video_access, arg_has_audio_access) =
            (self_, browser, has_video_access, has_audio_access);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_has_video_access = arg_has_video_access.as_raw();
        let arg_has_audio_access = arg_has_audio_access.as_raw();
        let result = ImplDisplayHandler::on_media_access_change(
            &arg_self_.interface,
            arg_browser,
            arg_has_video_access,
            arg_has_audio_access,
        );
    }
}
impl ImplDisplayHandler for DisplayHandler {
    fn on_address_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        url: Option<&CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .on_address_change
                .map(|f| {
                    let (arg_browser, arg_frame, arg_url) = (browser, frame, url);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_title_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        title: Option<&CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .on_title_change
                .map(|f| {
                    let (arg_browser, arg_title) = (browser, title);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_title = arg_title
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_title);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_favicon_urlchange(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        icon_urls: Option<&mut CefStringList>,
    ) {
        unsafe {
            self.0
                .on_favicon_urlchange
                .map(|f| {
                    let (arg_browser, arg_icon_urls) = (browser, icon_urls);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_icon_urls = arg_icon_urls
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_icon_urls);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_fullscreen_mode_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        fullscreen: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_fullscreen_mode_change
                .map(|f| {
                    let (arg_browser, arg_fullscreen) = (browser, fullscreen);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_fullscreen = arg_fullscreen;
                    let result = f(arg_self_, arg_browser, arg_fullscreen);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_tooltip(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        text: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_tooltip
                .map(|f| {
                    let (arg_browser, arg_text) = (browser, text);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_text = arg_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_status_message(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        value: Option<&CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .on_status_message
                .map(|f| {
                    let (arg_browser, arg_value) = (browser, value);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_console_message(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        level: LogSeverity,
        message: Option<&CefStringUtf16>,
        source: Option<&CefStringUtf16>,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_console_message
                .map(|f| {
                    let (arg_browser, arg_level, arg_message, arg_source, arg_line) =
                        (browser, level, message, source, line);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_level = arg_level.as_raw();
                    let arg_message = arg_message
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_source = arg_source
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_line = arg_line;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_level,
                        arg_message,
                        arg_source,
                        arg_line,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_auto_resize(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        new_size: Option<&Size>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_auto_resize
                .map(|f| {
                    let (arg_browser, arg_new_size) = (browser, new_size);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_new_size = arg_new_size.cloned().map(|arg| arg.into());
                    let arg_new_size = arg_new_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_new_size);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_loading_progress_change(&self, browser: Option<&mut impl ImplBrowser>, progress: f64) {
        unsafe {
            self.0
                .on_loading_progress_change
                .map(|f| {
                    let (arg_browser, arg_progress) = (browser, progress);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_progress = arg_progress;
                    let result = f(arg_self_, arg_browser, arg_progress);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_cursor_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        cursor: ::std::os::raw::c_ulong,
        type_: CursorType,
        custom_cursor_info: Option<&CursorInfo>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_cursor_change
                .map(|f| {
                    let (arg_browser, arg_cursor, arg_type_, arg_custom_cursor_info) =
                        (browser, cursor, type_, custom_cursor_info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cursor = arg_cursor;
                    let arg_type_ = arg_type_.as_raw();
                    let arg_custom_cursor_info =
                        arg_custom_cursor_info.cloned().map(|arg| arg.into());
                    let arg_custom_cursor_info = arg_custom_cursor_info
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_cursor,
                        arg_type_,
                        arg_custom_cursor_info,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_media_access_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_media_access_change
                .map(|f| {
                    let (arg_browser, arg_has_video_access, arg_has_audio_access) =
                        (browser, has_video_access, has_audio_access);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_has_video_access = arg_has_video_access;
                    let arg_has_audio_access = arg_has_audio_access;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_has_video_access,
                        arg_has_audio_access,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_display_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_display_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DisplayHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_display_handler_t> for &DisplayHandler {
    fn as_raw(self) -> *mut _cef_display_handler_t {
        ImplDisplayHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_display_handler_t> for &mut DisplayHandler {
    fn as_raw(self) -> *mut _cef_display_handler_t {
        ImplDisplayHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DisplayHandler> for *mut _cef_display_handler_t {
    fn as_wrapper(self) -> DisplayHandler {
        DisplayHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_display_handler_t> for DisplayHandler {
    fn into(self) -> *mut _cef_display_handler_t {
        let object = ImplDisplayHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DisplayHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_download_item_t] for more documentation.
#[derive(Clone)]
pub struct DownloadItem(RefGuard<_cef_download_item_t>);
impl DownloadItem {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDownloadItem,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDownloadItem>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDownloadItem>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_download_item_t).as_wrapper()
        }
    }
}
pub trait WrapDownloadItem: ImplDownloadItem {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_download_item_t, Self>);
}
pub trait ImplDownloadItem: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_in_progress(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_complete(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_canceled(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_interrupted(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_interrupt_reason(&self) -> DownloadInterruptReason {
        Default::default()
    }
    fn get_current_speed(&self) -> i64 {
        Default::default()
    }
    fn get_percent_complete(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_total_bytes(&self) -> i64 {
        Default::default()
    }
    fn get_received_bytes(&self) -> i64 {
        Default::default()
    }
    fn get_start_time(&self) -> Basetime {
        Default::default()
    }
    fn get_end_time(&self) -> Basetime {
        Default::default()
    }
    fn get_full_path(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_id(&self) -> u32 {
        Default::default()
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_original_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_suggested_file_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_content_disposition(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_mime_type(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_download_item_t) {
        impl_cef_download_item_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_download_item_t;
}
mod impl_cef_download_item_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadItem>(object: &mut _cef_download_item_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_in_progress = Some(is_in_progress::<I>);
        object.is_complete = Some(is_complete::<I>);
        object.is_canceled = Some(is_canceled::<I>);
        object.is_interrupted = Some(is_interrupted::<I>);
        object.get_interrupt_reason = Some(get_interrupt_reason::<I>);
        object.get_current_speed = Some(get_current_speed::<I>);
        object.get_percent_complete = Some(get_percent_complete::<I>);
        object.get_total_bytes = Some(get_total_bytes::<I>);
        object.get_received_bytes = Some(get_received_bytes::<I>);
        object.get_start_time = Some(get_start_time::<I>);
        object.get_end_time = Some(get_end_time::<I>);
        object.get_full_path = Some(get_full_path::<I>);
        object.get_id = Some(get_id::<I>);
        object.get_url = Some(get_url::<I>);
        object.get_original_url = Some(get_original_url::<I>);
        object.get_suggested_file_name = Some(get_suggested_file_name::<I>);
        object.get_content_disposition = Some(get_content_disposition::<I>);
        object.get_mime_type = Some(get_mime_type::<I>);
    }
    extern "C" fn is_valid<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_in_progress<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::is_in_progress(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_complete<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::is_complete(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_canceled<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::is_canceled(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_interrupted<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::is_interrupted(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_interrupt_reason<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> cef_download_interrupt_reason_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_interrupt_reason(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_current_speed<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_current_speed(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_percent_complete<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_percent_complete(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_total_bytes<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_total_bytes(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_received_bytes<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_received_bytes(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_start_time<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_start_time(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_end_time<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_end_time(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_full_path<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_full_path(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_id<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_id(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_url<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_original_url<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_original_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_suggested_file_name<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_suggested_file_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_content_disposition<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_content_disposition(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_mime_type<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItem::get_mime_type(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplDownloadItem for DownloadItem {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_in_progress(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_in_progress
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_complete(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_complete
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_canceled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_canceled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_interrupted(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_interrupted
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_interrupt_reason(&self) -> DownloadInterruptReason {
        unsafe {
            self.0
                .get_interrupt_reason
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_current_speed(&self) -> i64 {
        unsafe {
            self.0
                .get_current_speed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_percent_complete(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_percent_complete
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_total_bytes(&self) -> i64 {
        unsafe {
            self.0
                .get_total_bytes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_received_bytes(&self) -> i64 {
        unsafe {
            self.0
                .get_received_bytes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_start_time(&self) -> Basetime {
        unsafe {
            self.0
                .get_start_time
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_end_time(&self) -> Basetime {
        unsafe {
            self.0
                .get_end_time
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_full_path(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_full_path
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_id(&self) -> u32 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_original_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_original_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_suggested_file_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_suggested_file_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_content_disposition(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_content_disposition
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_mime_type(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_mime_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_download_item_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_download_item_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadItem {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_item_t> for &DownloadItem {
    fn as_raw(self) -> *mut _cef_download_item_t {
        ImplDownloadItem::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_item_t> for &mut DownloadItem {
    fn as_raw(self) -> *mut _cef_download_item_t {
        ImplDownloadItem::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadItem> for *mut _cef_download_item_t {
    fn as_wrapper(self) -> DownloadItem {
        DownloadItem(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_item_t> for DownloadItem {
    fn into(self) -> *mut _cef_download_item_t {
        let object = ImplDownloadItem::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DownloadItem {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_before_download_callback_t] for more documentation.
#[derive(Clone)]
pub struct BeforeDownloadCallback(RefGuard<_cef_before_download_callback_t>);
impl BeforeDownloadCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBeforeDownloadCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBeforeDownloadCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBeforeDownloadCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_before_download_callback_t).as_wrapper()
        }
    }
}
pub trait WrapBeforeDownloadCallback: ImplBeforeDownloadCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_before_download_callback_t, Self>);
}
pub trait ImplBeforeDownloadCallback: Clone + Sized + Rc {
    fn cont(&self, download_path: Option<&CefStringUtf16>, show_dialog: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_before_download_callback_t) {
        impl_cef_before_download_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_before_download_callback_t;
}
mod impl_cef_before_download_callback_t {
    use super::*;
    pub fn init_methods<I: ImplBeforeDownloadCallback>(
        object: &mut _cef_before_download_callback_t,
    ) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplBeforeDownloadCallback>(
        self_: *mut _cef_before_download_callback_t,
        download_path: *const _cef_string_utf16_t,
        show_dialog: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_download_path, arg_show_dialog) = (self_, download_path, show_dialog);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_download_path = if arg_download_path.is_null() {
            None
        } else {
            Some(arg_download_path.into())
        };
        let arg_download_path = arg_download_path.as_ref();
        let arg_show_dialog = arg_show_dialog.as_raw();
        let result = ImplBeforeDownloadCallback::cont(
            &arg_self_.interface,
            arg_download_path,
            arg_show_dialog,
        );
    }
}
impl ImplBeforeDownloadCallback for BeforeDownloadCallback {
    fn cont(&self, download_path: Option<&CefStringUtf16>, show_dialog: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_download_path, arg_show_dialog) = (download_path, show_dialog);
                    let arg_self_ = self.as_raw();
                    let arg_download_path = arg_download_path
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_show_dialog = arg_show_dialog;
                    let result = f(arg_self_, arg_download_path, arg_show_dialog);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_before_download_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_before_download_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BeforeDownloadCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_before_download_callback_t> for &BeforeDownloadCallback {
    fn as_raw(self) -> *mut _cef_before_download_callback_t {
        ImplBeforeDownloadCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_before_download_callback_t> for &mut BeforeDownloadCallback {
    fn as_raw(self) -> *mut _cef_before_download_callback_t {
        ImplBeforeDownloadCallback::get_raw(self)
    }
}
impl ConvertReturnValue<BeforeDownloadCallback> for *mut _cef_before_download_callback_t {
    fn as_wrapper(self) -> BeforeDownloadCallback {
        BeforeDownloadCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_before_download_callback_t> for BeforeDownloadCallback {
    fn into(self) -> *mut _cef_before_download_callback_t {
        let object = ImplBeforeDownloadCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for BeforeDownloadCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_download_item_callback_t] for more documentation.
#[derive(Clone)]
pub struct DownloadItemCallback(RefGuard<_cef_download_item_callback_t>);
impl DownloadItemCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDownloadItemCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDownloadItemCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDownloadItemCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_download_item_callback_t).as_wrapper()
        }
    }
}
pub trait WrapDownloadItemCallback: ImplDownloadItemCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_download_item_callback_t, Self>);
}
pub trait ImplDownloadItemCallback: Clone + Sized + Rc {
    fn cancel(&self) {}
    fn pause(&self) {}
    fn resume(&self) {}
    fn init_methods(object: &mut _cef_download_item_callback_t) {
        impl_cef_download_item_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_download_item_callback_t;
}
mod impl_cef_download_item_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadItemCallback>(object: &mut _cef_download_item_callback_t) {
        object.cancel = Some(cancel::<I>);
        object.pause = Some(pause::<I>);
        object.resume = Some(resume::<I>);
    }
    extern "C" fn cancel<I: ImplDownloadItemCallback>(self_: *mut _cef_download_item_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItemCallback::cancel(&arg_self_.interface);
    }
    extern "C" fn pause<I: ImplDownloadItemCallback>(self_: *mut _cef_download_item_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItemCallback::pause(&arg_self_.interface);
    }
    extern "C" fn resume<I: ImplDownloadItemCallback>(self_: *mut _cef_download_item_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDownloadItemCallback::resume(&arg_self_.interface);
    }
}
impl ImplDownloadItemCallback for DownloadItemCallback {
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn pause(&self) {
        unsafe {
            self.0
                .pause
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn resume(&self) {
        unsafe {
            self.0
                .resume
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_download_item_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_download_item_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadItemCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_item_callback_t> for &DownloadItemCallback {
    fn as_raw(self) -> *mut _cef_download_item_callback_t {
        ImplDownloadItemCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_item_callback_t> for &mut DownloadItemCallback {
    fn as_raw(self) -> *mut _cef_download_item_callback_t {
        ImplDownloadItemCallback::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadItemCallback> for *mut _cef_download_item_callback_t {
    fn as_wrapper(self) -> DownloadItemCallback {
        DownloadItemCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_item_callback_t> for DownloadItemCallback {
    fn into(self) -> *mut _cef_download_item_callback_t {
        let object = ImplDownloadItemCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DownloadItemCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_download_handler_t] for more documentation.
#[derive(Clone)]
pub struct DownloadHandler(RefGuard<_cef_download_handler_t>);
impl DownloadHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDownloadHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDownloadHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDownloadHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_download_handler_t).as_wrapper()
        }
    }
}
pub trait WrapDownloadHandler: ImplDownloadHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_download_handler_t, Self>);
}
pub trait ImplDownloadHandler: Clone + Sized + Rc {
    fn can_download(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        url: Option<&CefStringUtf16>,
        request_method: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_before_download(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        download_item: Option<&mut impl ImplDownloadItem>,
        suggested_name: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplBeforeDownloadCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_download_updated(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        download_item: Option<&mut impl ImplDownloadItem>,
        callback: Option<&mut impl ImplDownloadItemCallback>,
    ) {
    }
    fn init_methods(object: &mut _cef_download_handler_t) {
        impl_cef_download_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_download_handler_t;
}
mod impl_cef_download_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadHandler>(object: &mut _cef_download_handler_t) {
        object.can_download = Some(can_download::<I>);
        object.on_before_download = Some(on_before_download::<I>);
        object.on_download_updated = Some(on_download_updated::<I>);
    }
    extern "C" fn can_download<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        url: *const _cef_string_utf16_t,
        request_method: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_url, arg_request_method) =
            (self_, browser, url, request_method);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let arg_request_method = if arg_request_method.is_null() {
            None
        } else {
            Some(arg_request_method.into())
        };
        let arg_request_method = arg_request_method.as_ref();
        let result = ImplDownloadHandler::can_download(
            &arg_self_.interface,
            arg_browser,
            arg_url,
            arg_request_method,
        );
        result.into()
    }
    extern "C" fn on_before_download<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        download_item: *mut _cef_download_item_t,
        suggested_name: *const _cef_string_utf16_t,
        callback: *mut _cef_before_download_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_download_item, arg_suggested_name, arg_callback) =
            (self_, browser, download_item, suggested_name, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_download_item = unsafe { arg_download_item.as_mut() }
            .map(|arg| DownloadItem(unsafe { RefGuard::from_raw(arg) }));
        let arg_download_item = arg_download_item.as_mut();
        let arg_suggested_name = if arg_suggested_name.is_null() {
            None
        } else {
            Some(arg_suggested_name.into())
        };
        let arg_suggested_name = arg_suggested_name.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| BeforeDownloadCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplDownloadHandler::on_before_download(
            &arg_self_.interface,
            arg_browser,
            arg_download_item,
            arg_suggested_name,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_download_updated<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        download_item: *mut _cef_download_item_t,
        callback: *mut _cef_download_item_callback_t,
    ) {
        let (arg_self_, arg_browser, arg_download_item, arg_callback) =
            (self_, browser, download_item, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_download_item = unsafe { arg_download_item.as_mut() }
            .map(|arg| DownloadItem(unsafe { RefGuard::from_raw(arg) }));
        let arg_download_item = arg_download_item.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| DownloadItemCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplDownloadHandler::on_download_updated(
            &arg_self_.interface,
            arg_browser,
            arg_download_item,
            arg_callback,
        );
    }
}
impl ImplDownloadHandler for DownloadHandler {
    fn can_download(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        url: Option<&CefStringUtf16>,
        request_method: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_download
                .map(|f| {
                    let (arg_browser, arg_url, arg_request_method) = (browser, url, request_method);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_request_method = arg_request_method
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_url, arg_request_method);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_download(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        download_item: Option<&mut impl ImplDownloadItem>,
        suggested_name: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplBeforeDownloadCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_download
                .map(|f| {
                    let (arg_browser, arg_download_item, arg_suggested_name, arg_callback) =
                        (browser, download_item, suggested_name, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_download_item = arg_download_item
                        .map(|arg| {
                            arg.add_ref();
                            ImplDownloadItem::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_suggested_name = arg_suggested_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplBeforeDownloadCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_download_item,
                        arg_suggested_name,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_download_updated(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        download_item: Option<&mut impl ImplDownloadItem>,
        callback: Option<&mut impl ImplDownloadItemCallback>,
    ) {
        unsafe {
            self.0
                .on_download_updated
                .map(|f| {
                    let (arg_browser, arg_download_item, arg_callback) =
                        (browser, download_item, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_download_item = arg_download_item
                        .map(|arg| {
                            arg.add_ref();
                            ImplDownloadItem::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplDownloadItemCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_download_item, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_download_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_download_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_handler_t> for &DownloadHandler {
    fn as_raw(self) -> *mut _cef_download_handler_t {
        ImplDownloadHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_handler_t> for &mut DownloadHandler {
    fn as_raw(self) -> *mut _cef_download_handler_t {
        ImplDownloadHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadHandler> for *mut _cef_download_handler_t {
    fn as_wrapper(self) -> DownloadHandler {
        DownloadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_handler_t> for DownloadHandler {
    fn into(self) -> *mut _cef_download_handler_t {
        let object = ImplDownloadHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DownloadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_drag_handler_t] for more documentation.
#[derive(Clone)]
pub struct DragHandler(RefGuard<_cef_drag_handler_t>);
impl DragHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDragHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDragHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDragHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_drag_handler_t).as_wrapper()
        }
    }
}
pub trait WrapDragHandler: ImplDragHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_drag_handler_t, Self>);
}
pub trait ImplDragHandler: Clone + Sized + Rc {
    fn on_drag_enter(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        drag_data: Option<&mut impl ImplDragData>,
        mask: DragOperationsMask,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_draggable_regions_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        regions_count: usize,
        regions: Option<&DraggableRegion>,
    ) {
    }
    fn init_methods(object: &mut _cef_drag_handler_t) {
        impl_cef_drag_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_drag_handler_t;
}
mod impl_cef_drag_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDragHandler>(object: &mut _cef_drag_handler_t) {
        object.on_drag_enter = Some(on_drag_enter::<I>);
        object.on_draggable_regions_changed = Some(on_draggable_regions_changed::<I>);
    }
    extern "C" fn on_drag_enter<I: ImplDragHandler>(
        self_: *mut _cef_drag_handler_t,
        browser: *mut _cef_browser_t,
        drag_data: *mut _cef_drag_data_t,
        mask: cef_drag_operations_mask_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_drag_data, arg_mask) = (self_, browser, drag_data, mask);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_drag_data = unsafe { arg_drag_data.as_mut() }
            .map(|arg| DragData(unsafe { RefGuard::from_raw(arg) }));
        let arg_drag_data = arg_drag_data.as_mut();
        let arg_mask = arg_mask.as_raw();
        let result = ImplDragHandler::on_drag_enter(
            &arg_self_.interface,
            arg_browser,
            arg_drag_data,
            arg_mask,
        );
        result.into()
    }
    extern "C" fn on_draggable_regions_changed<I: ImplDragHandler>(
        self_: *mut _cef_drag_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        regions_count: usize,
        regions: *const _cef_draggable_region_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_regions_count, arg_regions) =
            (self_, browser, frame, regions_count, regions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_regions_count = arg_regions_count.as_raw();
        let arg_regions = if arg_regions.is_null() {
            None
        } else {
            Some(WrapParamRef::<DraggableRegion>::from(arg_regions))
        };
        let arg_regions = arg_regions.as_ref().map(|arg| arg.as_ref());
        let result = ImplDragHandler::on_draggable_regions_changed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_regions_count,
            arg_regions,
        );
    }
}
impl ImplDragHandler for DragHandler {
    fn on_drag_enter(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        drag_data: Option<&mut impl ImplDragData>,
        mask: DragOperationsMask,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_drag_enter
                .map(|f| {
                    let (arg_browser, arg_drag_data, arg_mask) = (browser, drag_data, mask);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_drag_data = arg_drag_data
                        .map(|arg| {
                            arg.add_ref();
                            ImplDragData::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_mask = arg_mask.as_raw();
                    let result = f(arg_self_, arg_browser, arg_drag_data, arg_mask);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_draggable_regions_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        regions_count: usize,
        regions: Option<&DraggableRegion>,
    ) {
        unsafe {
            self.0
                .on_draggable_regions_changed
                .map(|f| {
                    let (arg_browser, arg_frame, arg_regions_count, arg_regions) =
                        (browser, frame, regions_count, regions);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_regions_count = arg_regions_count;
                    let arg_regions = arg_regions.cloned().map(|arg| arg.into());
                    let arg_regions = arg_regions
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_regions_count,
                        arg_regions,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_drag_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_drag_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DragHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_drag_handler_t> for &DragHandler {
    fn as_raw(self) -> *mut _cef_drag_handler_t {
        ImplDragHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_drag_handler_t> for &mut DragHandler {
    fn as_raw(self) -> *mut _cef_drag_handler_t {
        ImplDragHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DragHandler> for *mut _cef_drag_handler_t {
    fn as_wrapper(self) -> DragHandler {
        DragHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_drag_handler_t> for DragHandler {
    fn into(self) -> *mut _cef_drag_handler_t {
        let object = ImplDragHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for DragHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_find_handler_t] for more documentation.
#[derive(Clone)]
pub struct FindHandler(RefGuard<_cef_find_handler_t>);
impl FindHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFindHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFindHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFindHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_find_handler_t).as_wrapper()
        }
    }
}
pub trait WrapFindHandler: ImplFindHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_find_handler_t, Self>);
}
pub trait ImplFindHandler: Clone + Sized + Rc {
    fn on_find_result(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: Option<&Rect>,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
    }
    fn init_methods(object: &mut _cef_find_handler_t) {
        impl_cef_find_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_find_handler_t;
}
mod impl_cef_find_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFindHandler>(object: &mut _cef_find_handler_t) {
        object.on_find_result = Some(on_find_result::<I>);
    }
    extern "C" fn on_find_result<I: ImplFindHandler>(
        self_: *mut _cef_find_handler_t,
        browser: *mut _cef_browser_t,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: *const _cef_rect_t,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_identifier,
            arg_count,
            arg_selection_rect,
            arg_active_match_ordinal,
            arg_final_update,
        ) = (
            self_,
            browser,
            identifier,
            count,
            selection_rect,
            active_match_ordinal,
            final_update,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_identifier = arg_identifier.as_raw();
        let arg_count = arg_count.as_raw();
        let arg_selection_rect = if arg_selection_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_selection_rect))
        };
        let arg_selection_rect = arg_selection_rect.as_ref().map(|arg| arg.as_ref());
        let arg_active_match_ordinal = arg_active_match_ordinal.as_raw();
        let arg_final_update = arg_final_update.as_raw();
        let result = ImplFindHandler::on_find_result(
            &arg_self_.interface,
            arg_browser,
            arg_identifier,
            arg_count,
            arg_selection_rect,
            arg_active_match_ordinal,
            arg_final_update,
        );
    }
}
impl ImplFindHandler for FindHandler {
    fn on_find_result(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: Option<&Rect>,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_find_result
                .map(|f| {
                    let (
                        arg_browser,
                        arg_identifier,
                        arg_count,
                        arg_selection_rect,
                        arg_active_match_ordinal,
                        arg_final_update,
                    ) = (
                        browser,
                        identifier,
                        count,
                        selection_rect,
                        active_match_ordinal,
                        final_update,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_identifier = arg_identifier;
                    let arg_count = arg_count;
                    let arg_selection_rect = arg_selection_rect.cloned().map(|arg| arg.into());
                    let arg_selection_rect = arg_selection_rect
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_active_match_ordinal = arg_active_match_ordinal;
                    let arg_final_update = arg_final_update;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_identifier,
                        arg_count,
                        arg_selection_rect,
                        arg_active_match_ordinal,
                        arg_final_update,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_find_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_find_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FindHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_find_handler_t> for &FindHandler {
    fn as_raw(self) -> *mut _cef_find_handler_t {
        ImplFindHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_find_handler_t> for &mut FindHandler {
    fn as_raw(self) -> *mut _cef_find_handler_t {
        ImplFindHandler::get_raw(self)
    }
}
impl ConvertReturnValue<FindHandler> for *mut _cef_find_handler_t {
    fn as_wrapper(self) -> FindHandler {
        FindHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_find_handler_t> for FindHandler {
    fn into(self) -> *mut _cef_find_handler_t {
        let object = ImplFindHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for FindHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_focus_handler_t] for more documentation.
#[derive(Clone)]
pub struct FocusHandler(RefGuard<_cef_focus_handler_t>);
impl FocusHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFocusHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFocusHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFocusHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_focus_handler_t).as_wrapper()
        }
    }
}
pub trait WrapFocusHandler: ImplFocusHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_focus_handler_t, Self>);
}
pub trait ImplFocusHandler: Clone + Sized + Rc {
    fn on_take_focus(&self, browser: Option<&mut impl ImplBrowser>, next: ::std::os::raw::c_int) {}
    fn on_set_focus(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        source: FocusSource,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_got_focus(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn init_methods(object: &mut _cef_focus_handler_t) {
        impl_cef_focus_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_focus_handler_t;
}
mod impl_cef_focus_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFocusHandler>(object: &mut _cef_focus_handler_t) {
        object.on_take_focus = Some(on_take_focus::<I>);
        object.on_set_focus = Some(on_set_focus::<I>);
        object.on_got_focus = Some(on_got_focus::<I>);
    }
    extern "C" fn on_take_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
        next: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_next) = (self_, browser, next);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_next = arg_next.as_raw();
        let result = ImplFocusHandler::on_take_focus(&arg_self_.interface, arg_browser, arg_next);
    }
    extern "C" fn on_set_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
        source: cef_focus_source_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_source) = (self_, browser, source);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_source = arg_source.as_raw();
        let result = ImplFocusHandler::on_set_focus(&arg_self_.interface, arg_browser, arg_source);
        result.into()
    }
    extern "C" fn on_got_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplFocusHandler::on_got_focus(&arg_self_.interface, arg_browser);
    }
}
impl ImplFocusHandler for FocusHandler {
    fn on_take_focus(&self, browser: Option<&mut impl ImplBrowser>, next: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_take_focus
                .map(|f| {
                    let (arg_browser, arg_next) = (browser, next);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_next = arg_next;
                    let result = f(arg_self_, arg_browser, arg_next);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_set_focus(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        source: FocusSource,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_set_focus
                .map(|f| {
                    let (arg_browser, arg_source) = (browser, source);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_source = arg_source.as_raw();
                    let result = f(arg_self_, arg_browser, arg_source);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_got_focus(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_got_focus
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_focus_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_focus_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FocusHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_focus_handler_t> for &FocusHandler {
    fn as_raw(self) -> *mut _cef_focus_handler_t {
        ImplFocusHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_focus_handler_t> for &mut FocusHandler {
    fn as_raw(self) -> *mut _cef_focus_handler_t {
        ImplFocusHandler::get_raw(self)
    }
}
impl ConvertReturnValue<FocusHandler> for *mut _cef_focus_handler_t {
    fn as_wrapper(self) -> FocusHandler {
        FocusHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_focus_handler_t> for FocusHandler {
    fn into(self) -> *mut _cef_focus_handler_t {
        let object = ImplFocusHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for FocusHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_frame_handler_t] for more documentation.
#[derive(Clone)]
pub struct FrameHandler(RefGuard<_cef_frame_handler_t>);
impl FrameHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFrameHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFrameHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFrameHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_frame_handler_t).as_wrapper()
        }
    }
}
pub trait WrapFrameHandler: ImplFrameHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_frame_handler_t, Self>);
}
pub trait ImplFrameHandler: Clone + Sized + Rc {
    fn on_frame_created(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
    }
    fn on_frame_destroyed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
    }
    fn on_frame_attached(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        reattached: ::std::os::raw::c_int,
    ) {
    }
    fn on_frame_detached(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
    }
    fn on_main_frame_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        old_frame: Option<&mut impl ImplFrame>,
        new_frame: Option<&mut impl ImplFrame>,
    ) {
    }
    fn init_methods(object: &mut _cef_frame_handler_t) {
        impl_cef_frame_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_frame_handler_t;
}
mod impl_cef_frame_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFrameHandler>(object: &mut _cef_frame_handler_t) {
        object.on_frame_created = Some(on_frame_created::<I>);
        object.on_frame_destroyed = Some(on_frame_destroyed::<I>);
        object.on_frame_attached = Some(on_frame_attached::<I>);
        object.on_frame_detached = Some(on_frame_detached::<I>);
        object.on_main_frame_changed = Some(on_main_frame_changed::<I>);
    }
    extern "C" fn on_frame_created<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let result =
            ImplFrameHandler::on_frame_created(&arg_self_.interface, arg_browser, arg_frame);
    }
    extern "C" fn on_frame_destroyed<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let result =
            ImplFrameHandler::on_frame_destroyed(&arg_self_.interface, arg_browser, arg_frame);
    }
    extern "C" fn on_frame_attached<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        reattached: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_reattached) =
            (self_, browser, frame, reattached);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_reattached = arg_reattached.as_raw();
        let result = ImplFrameHandler::on_frame_attached(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_reattached,
        );
    }
    extern "C" fn on_frame_detached<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let result =
            ImplFrameHandler::on_frame_detached(&arg_self_.interface, arg_browser, arg_frame);
    }
    extern "C" fn on_main_frame_changed<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        old_frame: *mut _cef_frame_t,
        new_frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_old_frame, arg_new_frame) =
            (self_, browser, old_frame, new_frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_old_frame =
            unsafe { arg_old_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_old_frame = arg_old_frame.as_mut();
        let mut arg_new_frame =
            unsafe { arg_new_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_new_frame = arg_new_frame.as_mut();
        let result = ImplFrameHandler::on_main_frame_changed(
            &arg_self_.interface,
            arg_browser,
            arg_old_frame,
            arg_new_frame,
        );
    }
}
impl ImplFrameHandler for FrameHandler {
    fn on_frame_created(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
        unsafe {
            self.0
                .on_frame_created
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_frame_destroyed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
        unsafe {
            self.0
                .on_frame_destroyed
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_frame_attached(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        reattached: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_frame_attached
                .map(|f| {
                    let (arg_browser, arg_frame, arg_reattached) = (browser, frame, reattached);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_reattached = arg_reattached;
                    let result = f(arg_self_, arg_browser, arg_frame, arg_reattached);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_frame_detached(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
    ) {
        unsafe {
            self.0
                .on_frame_detached
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_main_frame_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        old_frame: Option<&mut impl ImplFrame>,
        new_frame: Option<&mut impl ImplFrame>,
    ) {
        unsafe {
            self.0
                .on_main_frame_changed
                .map(|f| {
                    let (arg_browser, arg_old_frame, arg_new_frame) =
                        (browser, old_frame, new_frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_old_frame = arg_old_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_new_frame = arg_new_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_old_frame, arg_new_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_frame_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_frame_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FrameHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_frame_handler_t> for &FrameHandler {
    fn as_raw(self) -> *mut _cef_frame_handler_t {
        ImplFrameHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_frame_handler_t> for &mut FrameHandler {
    fn as_raw(self) -> *mut _cef_frame_handler_t {
        ImplFrameHandler::get_raw(self)
    }
}
impl ConvertReturnValue<FrameHandler> for *mut _cef_frame_handler_t {
    fn as_wrapper(self) -> FrameHandler {
        FrameHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_frame_handler_t> for FrameHandler {
    fn into(self) -> *mut _cef_frame_handler_t {
        let object = ImplFrameHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for FrameHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_jsdialog_callback_t] for more documentation.
#[derive(Clone)]
pub struct JsdialogCallback(RefGuard<_cef_jsdialog_callback_t>);
impl JsdialogCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapJsdialogCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplJsdialogCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapJsdialogCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_jsdialog_callback_t).as_wrapper()
        }
    }
}
pub trait WrapJsdialogCallback: ImplJsdialogCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_jsdialog_callback_t, Self>);
}
pub trait ImplJsdialogCallback: Clone + Sized + Rc {
    fn cont(&self, success: ::std::os::raw::c_int, user_input: Option<&CefStringUtf16>) {}
    fn init_methods(object: &mut _cef_jsdialog_callback_t) {
        impl_cef_jsdialog_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_jsdialog_callback_t;
}
mod impl_cef_jsdialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplJsdialogCallback>(object: &mut _cef_jsdialog_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplJsdialogCallback>(
        self_: *mut _cef_jsdialog_callback_t,
        success: ::std::os::raw::c_int,
        user_input: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_success, arg_user_input) = (self_, success, user_input);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_success = arg_success.as_raw();
        let arg_user_input = if arg_user_input.is_null() {
            None
        } else {
            Some(arg_user_input.into())
        };
        let arg_user_input = arg_user_input.as_ref();
        let result = ImplJsdialogCallback::cont(&arg_self_.interface, arg_success, arg_user_input);
    }
}
impl ImplJsdialogCallback for JsdialogCallback {
    fn cont(&self, success: ::std::os::raw::c_int, user_input: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_success, arg_user_input) = (success, user_input);
                    let arg_self_ = self.as_raw();
                    let arg_success = arg_success;
                    let arg_user_input = arg_user_input
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_success, arg_user_input);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_jsdialog_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_jsdialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for JsdialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_jsdialog_callback_t> for &JsdialogCallback {
    fn as_raw(self) -> *mut _cef_jsdialog_callback_t {
        ImplJsdialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_jsdialog_callback_t> for &mut JsdialogCallback {
    fn as_raw(self) -> *mut _cef_jsdialog_callback_t {
        ImplJsdialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<JsdialogCallback> for *mut _cef_jsdialog_callback_t {
    fn as_wrapper(self) -> JsdialogCallback {
        JsdialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_jsdialog_callback_t> for JsdialogCallback {
    fn into(self) -> *mut _cef_jsdialog_callback_t {
        let object = ImplJsdialogCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for JsdialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_jsdialog_handler_t] for more documentation.
#[derive(Clone)]
pub struct JsdialogHandler(RefGuard<_cef_jsdialog_handler_t>);
impl JsdialogHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapJsdialogHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplJsdialogHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapJsdialogHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_jsdialog_handler_t).as_wrapper()
        }
    }
}
pub trait WrapJsdialogHandler: ImplJsdialogHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_jsdialog_handler_t, Self>);
}
pub trait ImplJsdialogHandler: Clone + Sized + Rc {
    fn on_jsdialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        origin_url: Option<&CefStringUtf16>,
        dialog_type: JsdialogType,
        message_text: Option<&CefStringUtf16>,
        default_prompt_text: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplJsdialogCallback>,
        suppress_message: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_before_unload_dialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message_text: Option<&CefStringUtf16>,
        is_reload: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplJsdialogCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_reset_dialog_state(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn on_dialog_closed(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn init_methods(object: &mut _cef_jsdialog_handler_t) {
        impl_cef_jsdialog_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_jsdialog_handler_t;
}
mod impl_cef_jsdialog_handler_t {
    use super::*;
    pub fn init_methods<I: ImplJsdialogHandler>(object: &mut _cef_jsdialog_handler_t) {
        object.on_jsdialog = Some(on_jsdialog::<I>);
        object.on_before_unload_dialog = Some(on_before_unload_dialog::<I>);
        object.on_reset_dialog_state = Some(on_reset_dialog_state::<I>);
        object.on_dialog_closed = Some(on_dialog_closed::<I>);
    }
    extern "C" fn on_jsdialog<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
        origin_url: *const _cef_string_utf16_t,
        dialog_type: cef_jsdialog_type_t,
        message_text: *const _cef_string_utf16_t,
        default_prompt_text: *const _cef_string_utf16_t,
        callback: *mut _cef_jsdialog_callback_t,
        suppress_message: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_origin_url,
            arg_dialog_type,
            arg_message_text,
            arg_default_prompt_text,
            arg_callback,
            arg_suppress_message,
        ) = (
            self_,
            browser,
            origin_url,
            dialog_type,
            message_text,
            default_prompt_text,
            callback,
            suppress_message,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_origin_url = if arg_origin_url.is_null() {
            None
        } else {
            Some(arg_origin_url.into())
        };
        let arg_origin_url = arg_origin_url.as_ref();
        let arg_dialog_type = arg_dialog_type.as_raw();
        let arg_message_text = if arg_message_text.is_null() {
            None
        } else {
            Some(arg_message_text.into())
        };
        let arg_message_text = arg_message_text.as_ref();
        let arg_default_prompt_text = if arg_default_prompt_text.is_null() {
            None
        } else {
            Some(arg_default_prompt_text.into())
        };
        let arg_default_prompt_text = arg_default_prompt_text.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| JsdialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let mut arg_suppress_message = if arg_suppress_message.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_suppress_message,
            ))
        };
        let arg_suppress_message = arg_suppress_message.as_mut().map(|arg| arg.as_mut());
        let result = ImplJsdialogHandler::on_jsdialog(
            &arg_self_.interface,
            arg_browser,
            arg_origin_url,
            arg_dialog_type,
            arg_message_text,
            arg_default_prompt_text,
            arg_callback,
            arg_suppress_message,
        );
        result.into()
    }
    extern "C" fn on_before_unload_dialog<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
        message_text: *const _cef_string_utf16_t,
        is_reload: ::std::os::raw::c_int,
        callback: *mut _cef_jsdialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_message_text, arg_is_reload, arg_callback) =
            (self_, browser, message_text, is_reload, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message_text = if arg_message_text.is_null() {
            None
        } else {
            Some(arg_message_text.into())
        };
        let arg_message_text = arg_message_text.as_ref();
        let arg_is_reload = arg_is_reload.as_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| JsdialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplJsdialogHandler::on_before_unload_dialog(
            &arg_self_.interface,
            arg_browser,
            arg_message_text,
            arg_is_reload,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_reset_dialog_state<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplJsdialogHandler::on_reset_dialog_state(&arg_self_.interface, arg_browser);
    }
    extern "C" fn on_dialog_closed<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplJsdialogHandler::on_dialog_closed(&arg_self_.interface, arg_browser);
    }
}
impl ImplJsdialogHandler for JsdialogHandler {
    fn on_jsdialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        origin_url: Option<&CefStringUtf16>,
        dialog_type: JsdialogType,
        message_text: Option<&CefStringUtf16>,
        default_prompt_text: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplJsdialogCallback>,
        suppress_message: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_jsdialog
                .map(|f| {
                    let (
                        arg_browser,
                        arg_origin_url,
                        arg_dialog_type,
                        arg_message_text,
                        arg_default_prompt_text,
                        arg_callback,
                        arg_suppress_message,
                    ) = (
                        browser,
                        origin_url,
                        dialog_type,
                        message_text,
                        default_prompt_text,
                        callback,
                        suppress_message,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_origin_url = arg_origin_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_dialog_type = arg_dialog_type.as_raw();
                    let arg_message_text = arg_message_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_default_prompt_text = arg_default_prompt_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplJsdialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_suppress_message = arg_suppress_message
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_origin_url,
                        arg_dialog_type,
                        arg_message_text,
                        arg_default_prompt_text,
                        arg_callback,
                        arg_suppress_message,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_unload_dialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        message_text: Option<&CefStringUtf16>,
        is_reload: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplJsdialogCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_unload_dialog
                .map(|f| {
                    let (arg_browser, arg_message_text, arg_is_reload, arg_callback) =
                        (browser, message_text, is_reload, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_message_text = arg_message_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_is_reload = arg_is_reload;
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplJsdialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_message_text,
                        arg_is_reload,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_reset_dialog_state(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_reset_dialog_state
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dialog_closed(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_dialog_closed
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_jsdialog_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_jsdialog_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for JsdialogHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_jsdialog_handler_t> for &JsdialogHandler {
    fn as_raw(self) -> *mut _cef_jsdialog_handler_t {
        ImplJsdialogHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_jsdialog_handler_t> for &mut JsdialogHandler {
    fn as_raw(self) -> *mut _cef_jsdialog_handler_t {
        ImplJsdialogHandler::get_raw(self)
    }
}
impl ConvertReturnValue<JsdialogHandler> for *mut _cef_jsdialog_handler_t {
    fn as_wrapper(self) -> JsdialogHandler {
        JsdialogHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_jsdialog_handler_t> for JsdialogHandler {
    fn into(self) -> *mut _cef_jsdialog_handler_t {
        let object = ImplJsdialogHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for JsdialogHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_keyboard_handler_t] for more documentation.
#[derive(Clone)]
pub struct KeyboardHandler(RefGuard<_cef_keyboard_handler_t>);
impl KeyboardHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapKeyboardHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplKeyboardHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapKeyboardHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_keyboard_handler_t).as_wrapper()
        }
    }
}
pub trait WrapKeyboardHandler: ImplKeyboardHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_keyboard_handler_t, Self>);
}
pub trait ImplKeyboardHandler: Clone + Sized + Rc {
    fn on_pre_key_event(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        event: Option<&KeyEvent>,
        os_event: Option<&mut XEvent>,
        is_keyboard_shortcut: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_key_event(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        event: Option<&KeyEvent>,
        os_event: Option<&mut XEvent>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_keyboard_handler_t) {
        impl_cef_keyboard_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_keyboard_handler_t;
}
mod impl_cef_keyboard_handler_t {
    use super::*;
    pub fn init_methods<I: ImplKeyboardHandler>(object: &mut _cef_keyboard_handler_t) {
        object.on_pre_key_event = Some(on_pre_key_event::<I>);
        object.on_key_event = Some(on_key_event::<I>);
    }
    extern "C" fn on_pre_key_event<I: ImplKeyboardHandler>(
        self_: *mut _cef_keyboard_handler_t,
        browser: *mut _cef_browser_t,
        event: *const _cef_key_event_t,
        os_event: *mut XEvent,
        is_keyboard_shortcut: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_event, arg_os_event, arg_is_keyboard_shortcut) =
            (self_, browser, event, os_event, is_keyboard_shortcut);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let mut arg_os_event = if arg_os_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<XEvent>::from(arg_os_event))
        };
        let arg_os_event = arg_os_event.as_mut().map(|arg| arg.as_mut());
        let mut arg_is_keyboard_shortcut = if arg_is_keyboard_shortcut.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_is_keyboard_shortcut,
            ))
        };
        let arg_is_keyboard_shortcut = arg_is_keyboard_shortcut.as_mut().map(|arg| arg.as_mut());
        let result = ImplKeyboardHandler::on_pre_key_event(
            &arg_self_.interface,
            arg_browser,
            arg_event,
            arg_os_event,
            arg_is_keyboard_shortcut,
        );
        result.into()
    }
    extern "C" fn on_key_event<I: ImplKeyboardHandler>(
        self_: *mut _cef_keyboard_handler_t,
        browser: *mut _cef_browser_t,
        event: *const _cef_key_event_t,
        os_event: *mut XEvent,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_event, arg_os_event) = (self_, browser, event, os_event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let mut arg_os_event = if arg_os_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<XEvent>::from(arg_os_event))
        };
        let arg_os_event = arg_os_event.as_mut().map(|arg| arg.as_mut());
        let result = ImplKeyboardHandler::on_key_event(
            &arg_self_.interface,
            arg_browser,
            arg_event,
            arg_os_event,
        );
        result.into()
    }
}
impl ImplKeyboardHandler for KeyboardHandler {
    fn on_pre_key_event(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        event: Option<&KeyEvent>,
        os_event: Option<&mut XEvent>,
        is_keyboard_shortcut: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_pre_key_event
                .map(|f| {
                    let (arg_browser, arg_event, arg_os_event, arg_is_keyboard_shortcut) =
                        (browser, event, os_event, is_keyboard_shortcut);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_os_event = arg_os_event
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_keyboard_shortcut = arg_is_keyboard_shortcut
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_event,
                        arg_os_event,
                        arg_is_keyboard_shortcut,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_key_event(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        event: Option<&KeyEvent>,
        os_event: Option<&mut XEvent>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_browser, arg_event, arg_os_event) = (browser, event, os_event);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_os_event = arg_os_event
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_event, arg_os_event);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_keyboard_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_keyboard_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for KeyboardHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_keyboard_handler_t> for &KeyboardHandler {
    fn as_raw(self) -> *mut _cef_keyboard_handler_t {
        ImplKeyboardHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_keyboard_handler_t> for &mut KeyboardHandler {
    fn as_raw(self) -> *mut _cef_keyboard_handler_t {
        ImplKeyboardHandler::get_raw(self)
    }
}
impl ConvertReturnValue<KeyboardHandler> for *mut _cef_keyboard_handler_t {
    fn as_wrapper(self) -> KeyboardHandler {
        KeyboardHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_keyboard_handler_t> for KeyboardHandler {
    fn into(self) -> *mut _cef_keyboard_handler_t {
        let object = ImplKeyboardHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for KeyboardHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_life_span_handler_t] for more documentation.
#[derive(Clone)]
pub struct LifeSpanHandler(RefGuard<_cef_life_span_handler_t>);
impl LifeSpanHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapLifeSpanHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplLifeSpanHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapLifeSpanHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_life_span_handler_t).as_wrapper()
        }
    }
}
pub trait WrapLifeSpanHandler: ImplLifeSpanHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_life_span_handler_t, Self>);
}
pub trait ImplLifeSpanHandler: Clone + Sized + Rc {
    fn on_before_popup(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        popup_id: ::std::os::raw::c_int,
        target_url: Option<&CefStringUtf16>,
        target_frame_name: Option<&CefStringUtf16>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
        popup_features: Option<&PopupFeatures>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut impl ImplDictionaryValue>,
        no_javascript_access: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_before_popup_aborted(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        popup_id: ::std::os::raw::c_int,
    ) {
    }
    fn on_before_dev_tools_popup(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut impl ImplDictionaryValue>,
        use_default_window: Option<&mut ::std::os::raw::c_int>,
    ) {
    }
    fn on_after_created(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn do_close(&self, browser: Option<&mut impl ImplBrowser>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_before_close(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn init_methods(object: &mut _cef_life_span_handler_t) {
        impl_cef_life_span_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_life_span_handler_t;
}
mod impl_cef_life_span_handler_t {
    use super::*;
    pub fn init_methods<I: ImplLifeSpanHandler>(object: &mut _cef_life_span_handler_t) {
        object.on_before_popup = Some(on_before_popup::<I>);
        object.on_before_popup_aborted = Some(on_before_popup_aborted::<I>);
        object.on_before_dev_tools_popup = Some(on_before_dev_tools_popup::<I>);
        object.on_after_created = Some(on_after_created::<I>);
        object.do_close = Some(do_close::<I>);
        object.on_before_close = Some(on_before_close::<I>);
    }
    extern "C" fn on_before_popup<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        popup_id: ::std::os::raw::c_int,
        target_url: *const _cef_string_utf16_t,
        target_frame_name: *const _cef_string_utf16_t,
        target_disposition: cef_window_open_disposition_t,
        user_gesture: ::std::os::raw::c_int,
        popup_features: *const _cef_popup_features_t,
        window_info: *mut _cef_window_info_t,
        client: *mut *mut _cef_client_t,
        settings: *mut _cef_browser_settings_t,
        extra_info: *mut *mut _cef_dictionary_value_t,
        no_javascript_access: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_popup_id,
            arg_target_url,
            arg_target_frame_name,
            arg_target_disposition,
            arg_user_gesture,
            arg_popup_features,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_no_javascript_access,
        ) = (
            self_,
            browser,
            frame,
            popup_id,
            target_url,
            target_frame_name,
            target_disposition,
            user_gesture,
            popup_features,
            window_info,
            client,
            settings,
            extra_info,
            no_javascript_access,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_popup_id = arg_popup_id.as_raw();
        let arg_target_url = if arg_target_url.is_null() {
            None
        } else {
            Some(arg_target_url.into())
        };
        let arg_target_url = arg_target_url.as_ref();
        let arg_target_frame_name = if arg_target_frame_name.is_null() {
            None
        } else {
            Some(arg_target_frame_name.into())
        };
        let arg_target_frame_name = arg_target_frame_name.as_ref();
        let arg_target_disposition = arg_target_disposition.as_raw();
        let arg_user_gesture = arg_user_gesture.as_raw();
        let arg_popup_features = if arg_popup_features.is_null() {
            None
        } else {
            Some(WrapParamRef::<PopupFeatures>::from(arg_popup_features))
        };
        let arg_popup_features = arg_popup_features.as_ref().map(|arg| arg.as_ref());
        let mut arg_window_info = if arg_window_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<WindowInfo>::from(arg_window_info))
        };
        let arg_window_info = arg_window_info.as_mut().map(|arg| arg.as_mut());
        let mut arg_client = unsafe { arg_client.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(Client(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_client = arg_client.as_mut();
        let mut arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BrowserSettings>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_mut().map(|arg| arg.as_mut());
        let mut arg_extra_info = unsafe { arg_extra_info.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(DictionaryValue(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_extra_info = arg_extra_info.as_mut();
        let mut arg_no_javascript_access = if arg_no_javascript_access.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_no_javascript_access,
            ))
        };
        let arg_no_javascript_access = arg_no_javascript_access.as_mut().map(|arg| arg.as_mut());
        let result = ImplLifeSpanHandler::on_before_popup(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_popup_id,
            arg_target_url,
            arg_target_frame_name,
            arg_target_disposition,
            arg_user_gesture,
            arg_popup_features,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_no_javascript_access,
        );
        result.into()
    }
    extern "C" fn on_before_popup_aborted<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        popup_id: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_popup_id) = (self_, browser, popup_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_popup_id = arg_popup_id.as_raw();
        let result = ImplLifeSpanHandler::on_before_popup_aborted(
            &arg_self_.interface,
            arg_browser,
            arg_popup_id,
        );
    }
    extern "C" fn on_before_dev_tools_popup<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        window_info: *mut _cef_window_info_t,
        client: *mut *mut _cef_client_t,
        settings: *mut _cef_browser_settings_t,
        extra_info: *mut *mut _cef_dictionary_value_t,
        use_default_window: *mut ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_use_default_window,
        ) = (
            self_,
            browser,
            window_info,
            client,
            settings,
            extra_info,
            use_default_window,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_window_info = if arg_window_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<WindowInfo>::from(arg_window_info))
        };
        let arg_window_info = arg_window_info.as_mut().map(|arg| arg.as_mut());
        let mut arg_client = unsafe { arg_client.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(Client(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_client = arg_client.as_mut();
        let mut arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BrowserSettings>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_mut().map(|arg| arg.as_mut());
        let mut arg_extra_info = unsafe { arg_extra_info.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(DictionaryValue(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_extra_info = arg_extra_info.as_mut();
        let mut arg_use_default_window = if arg_use_default_window.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_use_default_window,
            ))
        };
        let arg_use_default_window = arg_use_default_window.as_mut().map(|arg| arg.as_mut());
        let result = ImplLifeSpanHandler::on_before_dev_tools_popup(
            &arg_self_.interface,
            arg_browser,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_use_default_window,
        );
    }
    extern "C" fn on_after_created<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplLifeSpanHandler::on_after_created(&arg_self_.interface, arg_browser);
    }
    extern "C" fn do_close<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplLifeSpanHandler::do_close(&arg_self_.interface, arg_browser);
        result.into()
    }
    extern "C" fn on_before_close<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplLifeSpanHandler::on_before_close(&arg_self_.interface, arg_browser);
    }
}
impl ImplLifeSpanHandler for LifeSpanHandler {
    fn on_before_popup(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        popup_id: ::std::os::raw::c_int,
        target_url: Option<&CefStringUtf16>,
        target_frame_name: Option<&CefStringUtf16>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
        popup_features: Option<&PopupFeatures>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut impl ImplDictionaryValue>,
        no_javascript_access: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_popup
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_popup_id,
                        arg_target_url,
                        arg_target_frame_name,
                        arg_target_disposition,
                        arg_user_gesture,
                        arg_popup_features,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_no_javascript_access,
                    ) = (
                        browser,
                        frame,
                        popup_id,
                        target_url,
                        target_frame_name,
                        target_disposition,
                        user_gesture,
                        popup_features,
                        window_info,
                        client,
                        settings,
                        extra_info,
                        no_javascript_access,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_popup_id = arg_popup_id;
                    let arg_target_url = arg_target_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_target_frame_name = arg_target_frame_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_target_disposition = arg_target_disposition.as_raw();
                    let arg_user_gesture = arg_user_gesture;
                    let arg_popup_features = arg_popup_features.cloned().map(|arg| arg.into());
                    let arg_popup_features = arg_popup_features
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let mut arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
                    let arg_window_info = arg_window_info
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_client = arg_client.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_client = arg_client
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_extra_info = arg_extra_info.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_extra_info = arg_extra_info
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_no_javascript_access = arg_no_javascript_access
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_popup_id,
                        arg_target_url,
                        arg_target_frame_name,
                        arg_target_disposition,
                        arg_user_gesture,
                        arg_popup_features,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_no_javascript_access,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_popup_aborted(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        popup_id: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_before_popup_aborted
                .map(|f| {
                    let (arg_browser, arg_popup_id) = (browser, popup_id);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_popup_id = arg_popup_id;
                    let result = f(arg_self_, arg_browser, arg_popup_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_dev_tools_popup(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut impl ImplDictionaryValue>,
        use_default_window: Option<&mut ::std::os::raw::c_int>,
    ) {
        unsafe {
            self.0
                .on_before_dev_tools_popup
                .map(|f| {
                    let (
                        arg_browser,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_use_default_window,
                    ) = (
                        browser,
                        window_info,
                        client,
                        settings,
                        extra_info,
                        use_default_window,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
                    let arg_window_info = arg_window_info
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_client = arg_client.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_client = arg_client
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_extra_info = arg_extra_info.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_extra_info = arg_extra_info
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_use_default_window = arg_use_default_window
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_use_default_window,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_after_created(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_after_created
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn do_close(&self, browser: Option<&mut impl ImplBrowser>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .do_close
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_close(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_before_close
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_life_span_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_life_span_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LifeSpanHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_life_span_handler_t> for &LifeSpanHandler {
    fn as_raw(self) -> *mut _cef_life_span_handler_t {
        ImplLifeSpanHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_life_span_handler_t> for &mut LifeSpanHandler {
    fn as_raw(self) -> *mut _cef_life_span_handler_t {
        ImplLifeSpanHandler::get_raw(self)
    }
}
impl ConvertReturnValue<LifeSpanHandler> for *mut _cef_life_span_handler_t {
    fn as_wrapper(self) -> LifeSpanHandler {
        LifeSpanHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_life_span_handler_t> for LifeSpanHandler {
    fn into(self) -> *mut _cef_life_span_handler_t {
        let object = ImplLifeSpanHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for LifeSpanHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_load_handler_t] for more documentation.
#[derive(Clone)]
pub struct LoadHandler(RefGuard<_cef_load_handler_t>);
impl LoadHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapLoadHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplLoadHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapLoadHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_load_handler_t).as_wrapper()
        }
    }
}
pub trait WrapLoadHandler: ImplLoadHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_load_handler_t, Self>);
}
pub trait ImplLoadHandler: Clone + Sized + Rc {
    fn on_loading_state_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
    }
    fn on_load_start(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        transition_type: TransitionType,
    ) {
    }
    fn on_load_end(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        http_status_code: ::std::os::raw::c_int,
    ) {
    }
    fn on_load_error(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        error_code: Errorcode,
        error_text: Option<&CefStringUtf16>,
        failed_url: Option<&CefStringUtf16>,
    ) {
    }
    fn init_methods(object: &mut _cef_load_handler_t) {
        impl_cef_load_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_load_handler_t;
}
mod impl_cef_load_handler_t {
    use super::*;
    pub fn init_methods<I: ImplLoadHandler>(object: &mut _cef_load_handler_t) {
        object.on_loading_state_change = Some(on_loading_state_change::<I>);
        object.on_load_start = Some(on_load_start::<I>);
        object.on_load_end = Some(on_load_end::<I>);
        object.on_load_error = Some(on_load_error::<I>);
    }
    extern "C" fn on_loading_state_change<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_is_loading, arg_can_go_back, arg_can_go_forward) =
            (self_, browser, is_loading, can_go_back, can_go_forward);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_is_loading = arg_is_loading.as_raw();
        let arg_can_go_back = arg_can_go_back.as_raw();
        let arg_can_go_forward = arg_can_go_forward.as_raw();
        let result = ImplLoadHandler::on_loading_state_change(
            &arg_self_.interface,
            arg_browser,
            arg_is_loading,
            arg_can_go_back,
            arg_can_go_forward,
        );
    }
    extern "C" fn on_load_start<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        transition_type: cef_transition_type_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_transition_type) =
            (self_, browser, frame, transition_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_transition_type = arg_transition_type.as_raw();
        let result = ImplLoadHandler::on_load_start(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_transition_type,
        );
    }
    extern "C" fn on_load_end<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        http_status_code: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_http_status_code) =
            (self_, browser, frame, http_status_code);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_http_status_code = arg_http_status_code.as_raw();
        let result = ImplLoadHandler::on_load_end(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_http_status_code,
        );
    }
    extern "C" fn on_load_error<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        error_code: cef_errorcode_t,
        error_text: *const _cef_string_utf16_t,
        failed_url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_error_code, arg_error_text, arg_failed_url) =
            (self_, browser, frame, error_code, error_text, failed_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_error_code = arg_error_code.as_raw();
        let arg_error_text = if arg_error_text.is_null() {
            None
        } else {
            Some(arg_error_text.into())
        };
        let arg_error_text = arg_error_text.as_ref();
        let arg_failed_url = if arg_failed_url.is_null() {
            None
        } else {
            Some(arg_failed_url.into())
        };
        let arg_failed_url = arg_failed_url.as_ref();
        let result = ImplLoadHandler::on_load_error(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_error_code,
            arg_error_text,
            arg_failed_url,
        );
    }
}
impl ImplLoadHandler for LoadHandler {
    fn on_loading_state_change(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_loading_state_change
                .map(|f| {
                    let (arg_browser, arg_is_loading, arg_can_go_back, arg_can_go_forward) =
                        (browser, is_loading, can_go_back, can_go_forward);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_loading = arg_is_loading;
                    let arg_can_go_back = arg_can_go_back;
                    let arg_can_go_forward = arg_can_go_forward;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_is_loading,
                        arg_can_go_back,
                        arg_can_go_forward,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_load_start(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        transition_type: TransitionType,
    ) {
        unsafe {
            self.0
                .on_load_start
                .map(|f| {
                    let (arg_browser, arg_frame, arg_transition_type) =
                        (browser, frame, transition_type);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_transition_type = arg_transition_type.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_transition_type);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_load_end(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        http_status_code: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_load_end
                .map(|f| {
                    let (arg_browser, arg_frame, arg_http_status_code) =
                        (browser, frame, http_status_code);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_http_status_code = arg_http_status_code;
                    let result = f(arg_self_, arg_browser, arg_frame, arg_http_status_code);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_load_error(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        error_code: Errorcode,
        error_text: Option<&CefStringUtf16>,
        failed_url: Option<&CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .on_load_error
                .map(|f| {
                    let (arg_browser, arg_frame, arg_error_code, arg_error_text, arg_failed_url) =
                        (browser, frame, error_code, error_text, failed_url);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_error_code = arg_error_code.as_raw();
                    let arg_error_text = arg_error_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_failed_url = arg_failed_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_error_code,
                        arg_error_text,
                        arg_failed_url,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_load_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_load_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LoadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_load_handler_t> for &LoadHandler {
    fn as_raw(self) -> *mut _cef_load_handler_t {
        ImplLoadHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_load_handler_t> for &mut LoadHandler {
    fn as_raw(self) -> *mut _cef_load_handler_t {
        ImplLoadHandler::get_raw(self)
    }
}
impl ConvertReturnValue<LoadHandler> for *mut _cef_load_handler_t {
    fn as_wrapper(self) -> LoadHandler {
        LoadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_load_handler_t> for LoadHandler {
    fn into(self) -> *mut _cef_load_handler_t {
        let object = ImplLoadHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for LoadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_media_access_callback_t] for more documentation.
#[derive(Clone)]
pub struct MediaAccessCallback(RefGuard<_cef_media_access_callback_t>);
impl MediaAccessCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaAccessCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaAccessCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaAccessCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_media_access_callback_t).as_wrapper()
        }
    }
}
pub trait WrapMediaAccessCallback: ImplMediaAccessCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_access_callback_t, Self>);
}
pub trait ImplMediaAccessCallback: Clone + Sized + Rc {
    fn cont(&self, allowed_permissions: u32) {}
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_media_access_callback_t) {
        impl_cef_media_access_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_access_callback_t;
}
mod impl_cef_media_access_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaAccessCallback>(object: &mut _cef_media_access_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplMediaAccessCallback>(
        self_: *mut _cef_media_access_callback_t,
        allowed_permissions: u32,
    ) {
        let (arg_self_, arg_allowed_permissions) = (self_, allowed_permissions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_allowed_permissions = arg_allowed_permissions.as_raw();
        let result = ImplMediaAccessCallback::cont(&arg_self_.interface, arg_allowed_permissions);
    }
    extern "C" fn cancel<I: ImplMediaAccessCallback>(self_: *mut _cef_media_access_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMediaAccessCallback::cancel(&arg_self_.interface);
    }
}
impl ImplMediaAccessCallback for MediaAccessCallback {
    fn cont(&self, allowed_permissions: u32) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_allowed_permissions = allowed_permissions;
                    let arg_self_ = self.as_raw();
                    let arg_allowed_permissions = arg_allowed_permissions;
                    let result = f(arg_self_, arg_allowed_permissions);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_media_access_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_media_access_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaAccessCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_access_callback_t> for &MediaAccessCallback {
    fn as_raw(self) -> *mut _cef_media_access_callback_t {
        ImplMediaAccessCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_access_callback_t> for &mut MediaAccessCallback {
    fn as_raw(self) -> *mut _cef_media_access_callback_t {
        ImplMediaAccessCallback::get_raw(self)
    }
}
impl ConvertReturnValue<MediaAccessCallback> for *mut _cef_media_access_callback_t {
    fn as_wrapper(self) -> MediaAccessCallback {
        MediaAccessCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_access_callback_t> for MediaAccessCallback {
    fn into(self) -> *mut _cef_media_access_callback_t {
        let object = ImplMediaAccessCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MediaAccessCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_permission_prompt_callback_t] for more documentation.
#[derive(Clone)]
pub struct PermissionPromptCallback(RefGuard<_cef_permission_prompt_callback_t>);
impl PermissionPromptCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPermissionPromptCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPermissionPromptCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPermissionPromptCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_permission_prompt_callback_t).as_wrapper()
        }
    }
}
pub trait WrapPermissionPromptCallback: ImplPermissionPromptCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_permission_prompt_callback_t, Self>);
}
pub trait ImplPermissionPromptCallback: Clone + Sized + Rc {
    fn cont(&self, result: PermissionRequestResult) {}
    fn init_methods(object: &mut _cef_permission_prompt_callback_t) {
        impl_cef_permission_prompt_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_permission_prompt_callback_t;
}
mod impl_cef_permission_prompt_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPermissionPromptCallback>(
        object: &mut _cef_permission_prompt_callback_t,
    ) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplPermissionPromptCallback>(
        self_: *mut _cef_permission_prompt_callback_t,
        result: cef_permission_request_result_t,
    ) {
        let (arg_self_, arg_result) = (self_, result);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.as_raw();
        let result = ImplPermissionPromptCallback::cont(&arg_self_.interface, arg_result);
    }
}
impl ImplPermissionPromptCallback for PermissionPromptCallback {
    fn cont(&self, result: PermissionRequestResult) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_result = result;
                    let arg_self_ = self.as_raw();
                    let arg_result = arg_result.as_raw();
                    let result = f(arg_self_, arg_result);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_permission_prompt_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_permission_prompt_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PermissionPromptCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_permission_prompt_callback_t> for &PermissionPromptCallback {
    fn as_raw(self) -> *mut _cef_permission_prompt_callback_t {
        ImplPermissionPromptCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_permission_prompt_callback_t> for &mut PermissionPromptCallback {
    fn as_raw(self) -> *mut _cef_permission_prompt_callback_t {
        ImplPermissionPromptCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PermissionPromptCallback> for *mut _cef_permission_prompt_callback_t {
    fn as_wrapper(self) -> PermissionPromptCallback {
        PermissionPromptCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_permission_prompt_callback_t> for PermissionPromptCallback {
    fn into(self) -> *mut _cef_permission_prompt_callback_t {
        let object = ImplPermissionPromptCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PermissionPromptCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_permission_handler_t] for more documentation.
#[derive(Clone)]
pub struct PermissionHandler(RefGuard<_cef_permission_handler_t>);
impl PermissionHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPermissionHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPermissionHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPermissionHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_permission_handler_t).as_wrapper()
        }
    }
}
pub trait WrapPermissionHandler: ImplPermissionHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_permission_handler_t, Self>);
}
pub trait ImplPermissionHandler: Clone + Sized + Rc {
    fn on_request_media_access_permission(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        requesting_origin: Option<&CefStringUtf16>,
        requested_permissions: u32,
        callback: Option<&mut impl ImplMediaAccessCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_show_permission_prompt(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        prompt_id: u64,
        requesting_origin: Option<&CefStringUtf16>,
        requested_permissions: u32,
        callback: Option<&mut impl ImplPermissionPromptCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_dismiss_permission_prompt(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        prompt_id: u64,
        result: PermissionRequestResult,
    ) {
    }
    fn init_methods(object: &mut _cef_permission_handler_t) {
        impl_cef_permission_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_permission_handler_t;
}
mod impl_cef_permission_handler_t {
    use super::*;
    pub fn init_methods<I: ImplPermissionHandler>(object: &mut _cef_permission_handler_t) {
        object.on_request_media_access_permission = Some(on_request_media_access_permission::<I>);
        object.on_show_permission_prompt = Some(on_show_permission_prompt::<I>);
        object.on_dismiss_permission_prompt = Some(on_dismiss_permission_prompt::<I>);
    }
    extern "C" fn on_request_media_access_permission<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        requesting_origin: *const _cef_string_utf16_t,
        requested_permissions: u32,
        callback: *mut _cef_media_access_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        ) = (
            self_,
            browser,
            frame,
            requesting_origin,
            requested_permissions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_requesting_origin = if arg_requesting_origin.is_null() {
            None
        } else {
            Some(arg_requesting_origin.into())
        };
        let arg_requesting_origin = arg_requesting_origin.as_ref();
        let arg_requested_permissions = arg_requested_permissions.as_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| MediaAccessCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplPermissionHandler::on_request_media_access_permission(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_show_permission_prompt<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        prompt_id: u64,
        requesting_origin: *const _cef_string_utf16_t,
        requested_permissions: u32,
        callback: *mut _cef_permission_prompt_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_prompt_id,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        ) = (
            self_,
            browser,
            prompt_id,
            requesting_origin,
            requested_permissions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_prompt_id = arg_prompt_id.as_raw();
        let arg_requesting_origin = if arg_requesting_origin.is_null() {
            None
        } else {
            Some(arg_requesting_origin.into())
        };
        let arg_requesting_origin = arg_requesting_origin.as_ref();
        let arg_requested_permissions = arg_requested_permissions.as_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| PermissionPromptCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplPermissionHandler::on_show_permission_prompt(
            &arg_self_.interface,
            arg_browser,
            arg_prompt_id,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_dismiss_permission_prompt<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        prompt_id: u64,
        result: cef_permission_request_result_t,
    ) {
        let (arg_self_, arg_browser, arg_prompt_id, arg_result) =
            (self_, browser, prompt_id, result);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_prompt_id = arg_prompt_id.as_raw();
        let arg_result = arg_result.as_raw();
        let result = ImplPermissionHandler::on_dismiss_permission_prompt(
            &arg_self_.interface,
            arg_browser,
            arg_prompt_id,
            arg_result,
        );
    }
}
impl ImplPermissionHandler for PermissionHandler {
    fn on_request_media_access_permission(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        requesting_origin: Option<&CefStringUtf16>,
        requested_permissions: u32,
        callback: Option<&mut impl ImplMediaAccessCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_request_media_access_permission
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    ) = (
                        browser,
                        frame,
                        requesting_origin,
                        requested_permissions,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_requesting_origin = arg_requesting_origin
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_requested_permissions = arg_requested_permissions;
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaAccessCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_show_permission_prompt(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        prompt_id: u64,
        requesting_origin: Option<&CefStringUtf16>,
        requested_permissions: u32,
        callback: Option<&mut impl ImplPermissionPromptCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_show_permission_prompt
                .map(|f| {
                    let (
                        arg_browser,
                        arg_prompt_id,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    ) = (
                        browser,
                        prompt_id,
                        requesting_origin,
                        requested_permissions,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_prompt_id = arg_prompt_id;
                    let arg_requesting_origin = arg_requesting_origin
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_requested_permissions = arg_requested_permissions;
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplPermissionPromptCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_prompt_id,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_dismiss_permission_prompt(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        prompt_id: u64,
        result: PermissionRequestResult,
    ) {
        unsafe {
            self.0
                .on_dismiss_permission_prompt
                .map(|f| {
                    let (arg_browser, arg_prompt_id, arg_result) = (browser, prompt_id, result);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_prompt_id = arg_prompt_id;
                    let arg_result = arg_result.as_raw();
                    let result = f(arg_self_, arg_browser, arg_prompt_id, arg_result);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_permission_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_permission_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PermissionHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_permission_handler_t> for &PermissionHandler {
    fn as_raw(self) -> *mut _cef_permission_handler_t {
        ImplPermissionHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_permission_handler_t> for &mut PermissionHandler {
    fn as_raw(self) -> *mut _cef_permission_handler_t {
        ImplPermissionHandler::get_raw(self)
    }
}
impl ConvertReturnValue<PermissionHandler> for *mut _cef_permission_handler_t {
    fn as_wrapper(self) -> PermissionHandler {
        PermissionHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_permission_handler_t> for PermissionHandler {
    fn into(self) -> *mut _cef_permission_handler_t {
        let object = ImplPermissionHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PermissionHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_print_settings_t] for more documentation.
#[derive(Clone)]
pub struct PrintSettings(RefGuard<_cef_print_settings_t>);
impl PrintSettings {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPrintSettings,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPrintSettings>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPrintSettings>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_print_settings_t).as_wrapper()
        }
    }
}
pub trait WrapPrintSettings: ImplPrintSettings {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_print_settings_t, Self>);
}
pub trait ImplPrintSettings: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_orientation(&self, landscape: ::std::os::raw::c_int) {}
    fn is_landscape(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_printer_printable_area(
        &self,
        physical_size_device_units: Option<&Size>,
        printable_area_device_units: Option<&Rect>,
        landscape_needs_flip: ::std::os::raw::c_int,
    ) {
    }
    fn set_device_name(&self, name: Option<&CefStringUtf16>) {}
    fn get_device_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_dpi(&self, dpi: ::std::os::raw::c_int) {}
    fn get_dpi(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_page_ranges(&self, ranges_count: usize, ranges: Option<&Range>) {}
    fn get_page_ranges_count(&self) -> usize {
        Default::default()
    }
    fn get_page_ranges(&self, ranges_count: Option<&mut usize>, ranges: Option<&mut Range>) {}
    fn set_selection_only(&self, selection_only: ::std::os::raw::c_int) {}
    fn is_selection_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_collate(&self, collate: ::std::os::raw::c_int) {}
    fn will_collate(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_color_model(&self, model: ColorModel) {}
    fn get_color_model(&self) -> ColorModel {
        Default::default()
    }
    fn set_copies(&self, copies: ::std::os::raw::c_int) {}
    fn get_copies(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_duplex_mode(&self, mode: DuplexMode) {}
    fn get_duplex_mode(&self) -> DuplexMode {
        Default::default()
    }
    fn init_methods(object: &mut _cef_print_settings_t) {
        impl_cef_print_settings_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_print_settings_t;
}
mod impl_cef_print_settings_t {
    use super::*;
    pub fn init_methods<I: ImplPrintSettings>(object: &mut _cef_print_settings_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.set_orientation = Some(set_orientation::<I>);
        object.is_landscape = Some(is_landscape::<I>);
        object.set_printer_printable_area = Some(set_printer_printable_area::<I>);
        object.set_device_name = Some(set_device_name::<I>);
        object.get_device_name = Some(get_device_name::<I>);
        object.set_dpi = Some(set_dpi::<I>);
        object.get_dpi = Some(get_dpi::<I>);
        object.set_page_ranges = Some(set_page_ranges::<I>);
        object.get_page_ranges_count = Some(get_page_ranges_count::<I>);
        object.get_page_ranges = Some(get_page_ranges::<I>);
        object.set_selection_only = Some(set_selection_only::<I>);
        object.is_selection_only = Some(is_selection_only::<I>);
        object.set_collate = Some(set_collate::<I>);
        object.will_collate = Some(will_collate::<I>);
        object.set_color_model = Some(set_color_model::<I>);
        object.get_color_model = Some(get_color_model::<I>);
        object.set_copies = Some(set_copies::<I>);
        object.get_copies = Some(get_copies::<I>);
        object.set_duplex_mode = Some(set_duplex_mode::<I>);
        object.get_duplex_mode = Some(get_duplex_mode::<I>);
    }
    extern "C" fn is_valid<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_read_only<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_orientation<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        landscape: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_landscape) = (self_, landscape);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_landscape = arg_landscape.as_raw();
        let result = ImplPrintSettings::set_orientation(&arg_self_.interface, arg_landscape);
    }
    extern "C" fn is_landscape<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::is_landscape(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_printer_printable_area<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        physical_size_device_units: *const _cef_size_t,
        printable_area_device_units: *const _cef_rect_t,
        landscape_needs_flip: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_physical_size_device_units,
            arg_printable_area_device_units,
            arg_landscape_needs_flip,
        ) = (
            self_,
            physical_size_device_units,
            printable_area_device_units,
            landscape_needs_flip,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_physical_size_device_units = if arg_physical_size_device_units.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_physical_size_device_units))
        };
        let arg_physical_size_device_units = arg_physical_size_device_units
            .as_ref()
            .map(|arg| arg.as_ref());
        let arg_printable_area_device_units = if arg_printable_area_device_units.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_printable_area_device_units))
        };
        let arg_printable_area_device_units = arg_printable_area_device_units
            .as_ref()
            .map(|arg| arg.as_ref());
        let arg_landscape_needs_flip = arg_landscape_needs_flip.as_raw();
        let result = ImplPrintSettings::set_printer_printable_area(
            &arg_self_.interface,
            arg_physical_size_device_units,
            arg_printable_area_device_units,
            arg_landscape_needs_flip,
        );
    }
    extern "C" fn set_device_name<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplPrintSettings::set_device_name(&arg_self_.interface, arg_name);
    }
    extern "C" fn get_device_name<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::get_device_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_dpi<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        dpi: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_dpi) = (self_, dpi);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_dpi = arg_dpi.as_raw();
        let result = ImplPrintSettings::set_dpi(&arg_self_.interface, arg_dpi);
    }
    extern "C" fn get_dpi<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::get_dpi(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_page_ranges<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        ranges_count: usize,
        ranges: *const _cef_range_t,
    ) {
        let (arg_self_, arg_ranges_count, arg_ranges) = (self_, ranges_count, ranges);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ranges_count = arg_ranges_count.as_raw();
        let arg_ranges = if arg_ranges.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_ranges))
        };
        let arg_ranges = arg_ranges.as_ref().map(|arg| arg.as_ref());
        let result =
            ImplPrintSettings::set_page_ranges(&arg_self_.interface, arg_ranges_count, arg_ranges);
    }
    extern "C" fn get_page_ranges_count<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::get_page_ranges_count(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_page_ranges<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        ranges_count: *mut usize,
        ranges: *mut _cef_range_t,
    ) {
        let (arg_self_, arg_ranges_count, arg_ranges) = (self_, ranges_count, ranges);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_ranges_count = if arg_ranges_count.is_null() {
            None
        } else {
            Some(WrapParamRef::<usize>::from(arg_ranges_count))
        };
        let arg_ranges_count = arg_ranges_count.as_mut().map(|arg| arg.as_mut());
        let mut arg_ranges = if arg_ranges.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_ranges))
        };
        let arg_ranges = arg_ranges.as_mut().map(|arg| arg.as_mut());
        let result =
            ImplPrintSettings::get_page_ranges(&arg_self_.interface, arg_ranges_count, arg_ranges);
    }
    extern "C" fn set_selection_only<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        selection_only: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_selection_only) = (self_, selection_only);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_selection_only = arg_selection_only.as_raw();
        let result =
            ImplPrintSettings::set_selection_only(&arg_self_.interface, arg_selection_only);
    }
    extern "C" fn is_selection_only<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::is_selection_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_collate<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        collate: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_collate) = (self_, collate);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_collate = arg_collate.as_raw();
        let result = ImplPrintSettings::set_collate(&arg_self_.interface, arg_collate);
    }
    extern "C" fn will_collate<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::will_collate(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_color_model<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        model: cef_color_model_t,
    ) {
        let (arg_self_, arg_model) = (self_, model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_model = arg_model.as_raw();
        let result = ImplPrintSettings::set_color_model(&arg_self_.interface, arg_model);
    }
    extern "C" fn get_color_model<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> cef_color_model_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::get_color_model(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_copies<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        copies: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_copies) = (self_, copies);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_copies = arg_copies.as_raw();
        let result = ImplPrintSettings::set_copies(&arg_self_.interface, arg_copies);
    }
    extern "C" fn get_copies<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::get_copies(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_duplex_mode<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        mode: cef_duplex_mode_t,
    ) {
        let (arg_self_, arg_mode) = (self_, mode);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mode = arg_mode.as_raw();
        let result = ImplPrintSettings::set_duplex_mode(&arg_self_.interface, arg_mode);
    }
    extern "C" fn get_duplex_mode<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> cef_duplex_mode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintSettings::get_duplex_mode(&arg_self_.interface);
        result.into()
    }
}
impl ImplPrintSettings for PrintSettings {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_orientation(&self, landscape: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_orientation
                .map(|f| {
                    let arg_landscape = landscape;
                    let arg_self_ = self.as_raw();
                    let arg_landscape = arg_landscape;
                    let result = f(arg_self_, arg_landscape);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_landscape(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_landscape
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_printer_printable_area(
        &self,
        physical_size_device_units: Option<&Size>,
        printable_area_device_units: Option<&Rect>,
        landscape_needs_flip: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_printer_printable_area
                .map(|f| {
                    let (
                        arg_physical_size_device_units,
                        arg_printable_area_device_units,
                        arg_landscape_needs_flip,
                    ) = (
                        physical_size_device_units,
                        printable_area_device_units,
                        landscape_needs_flip,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_physical_size_device_units = arg_physical_size_device_units
                        .cloned()
                        .map(|arg| arg.into());
                    let arg_physical_size_device_units = arg_physical_size_device_units
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_printable_area_device_units = arg_printable_area_device_units
                        .cloned()
                        .map(|arg| arg.into());
                    let arg_printable_area_device_units = arg_printable_area_device_units
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_landscape_needs_flip = arg_landscape_needs_flip;
                    let result = f(
                        arg_self_,
                        arg_physical_size_device_units,
                        arg_printable_area_device_units,
                        arg_landscape_needs_flip,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_device_name(&self, name: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_device_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_device_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_device_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_dpi(&self, dpi: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_dpi
                .map(|f| {
                    let arg_dpi = dpi;
                    let arg_self_ = self.as_raw();
                    let arg_dpi = arg_dpi;
                    let result = f(arg_self_, arg_dpi);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_dpi(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_dpi
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_page_ranges(&self, ranges_count: usize, ranges: Option<&Range>) {
        unsafe {
            self.0
                .set_page_ranges
                .map(|f| {
                    let (arg_ranges_count, arg_ranges) = (ranges_count, ranges);
                    let arg_self_ = self.as_raw();
                    let arg_ranges_count = arg_ranges_count;
                    let arg_ranges = arg_ranges.cloned().map(|arg| arg.into());
                    let arg_ranges = arg_ranges
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_ranges_count, arg_ranges);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_page_ranges_count(&self) -> usize {
        unsafe {
            self.0
                .get_page_ranges_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_page_ranges(&self, ranges_count: Option<&mut usize>, ranges: Option<&mut Range>) {
        unsafe {
            self.0
                .get_page_ranges
                .map(|f| {
                    let (arg_ranges_count, arg_ranges) = (ranges_count, ranges);
                    let arg_self_ = self.as_raw();
                    let arg_ranges_count = arg_ranges_count
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_ranges = arg_ranges.cloned().map(|arg| arg.into());
                    let arg_ranges = arg_ranges
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_ranges_count, arg_ranges);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_selection_only(&self, selection_only: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_selection_only
                .map(|f| {
                    let arg_selection_only = selection_only;
                    let arg_self_ = self.as_raw();
                    let arg_selection_only = arg_selection_only;
                    let result = f(arg_self_, arg_selection_only);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_selection_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_selection_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_collate(&self, collate: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_collate
                .map(|f| {
                    let arg_collate = collate;
                    let arg_self_ = self.as_raw();
                    let arg_collate = arg_collate;
                    let result = f(arg_self_, arg_collate);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn will_collate(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .will_collate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_color_model(&self, model: ColorModel) {
        unsafe {
            self.0
                .set_color_model
                .map(|f| {
                    let arg_model = model;
                    let arg_self_ = self.as_raw();
                    let arg_model = arg_model.as_raw();
                    let result = f(arg_self_, arg_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_color_model(&self) -> ColorModel {
        unsafe {
            self.0
                .get_color_model
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_copies(&self, copies: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_copies
                .map(|f| {
                    let arg_copies = copies;
                    let arg_self_ = self.as_raw();
                    let arg_copies = arg_copies;
                    let result = f(arg_self_, arg_copies);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_copies(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_copies
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_duplex_mode(&self, mode: DuplexMode) {
        unsafe {
            self.0
                .set_duplex_mode
                .map(|f| {
                    let arg_mode = mode;
                    let arg_self_ = self.as_raw();
                    let arg_mode = arg_mode.as_raw();
                    let result = f(arg_self_, arg_mode);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_duplex_mode(&self) -> DuplexMode {
        unsafe {
            self.0
                .get_duplex_mode
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_print_settings_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_print_settings_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintSettings {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_settings_t> for &PrintSettings {
    fn as_raw(self) -> *mut _cef_print_settings_t {
        ImplPrintSettings::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_settings_t> for &mut PrintSettings {
    fn as_raw(self) -> *mut _cef_print_settings_t {
        ImplPrintSettings::get_raw(self)
    }
}
impl ConvertReturnValue<PrintSettings> for *mut _cef_print_settings_t {
    fn as_wrapper(self) -> PrintSettings {
        PrintSettings(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_settings_t> for PrintSettings {
    fn into(self) -> *mut _cef_print_settings_t {
        let object = ImplPrintSettings::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PrintSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_print_dialog_callback_t] for more documentation.
#[derive(Clone)]
pub struct PrintDialogCallback(RefGuard<_cef_print_dialog_callback_t>);
impl PrintDialogCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPrintDialogCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPrintDialogCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPrintDialogCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_print_dialog_callback_t).as_wrapper()
        }
    }
}
pub trait WrapPrintDialogCallback: ImplPrintDialogCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_print_dialog_callback_t, Self>);
}
pub trait ImplPrintDialogCallback: Clone + Sized + Rc {
    fn cont(&self, settings: Option<&mut impl ImplPrintSettings>) {}
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_print_dialog_callback_t) {
        impl_cef_print_dialog_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_print_dialog_callback_t;
}
mod impl_cef_print_dialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPrintDialogCallback>(object: &mut _cef_print_dialog_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplPrintDialogCallback>(
        self_: *mut _cef_print_dialog_callback_t,
        settings: *mut _cef_print_settings_t,
    ) {
        let (arg_self_, arg_settings) = (self_, settings);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_settings = unsafe { arg_settings.as_mut() }
            .map(|arg| PrintSettings(unsafe { RefGuard::from_raw(arg) }));
        let arg_settings = arg_settings.as_mut();
        let result = ImplPrintDialogCallback::cont(&arg_self_.interface, arg_settings);
    }
    extern "C" fn cancel<I: ImplPrintDialogCallback>(self_: *mut _cef_print_dialog_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintDialogCallback::cancel(&arg_self_.interface);
    }
}
impl ImplPrintDialogCallback for PrintDialogCallback {
    fn cont(&self, settings: Option<&mut impl ImplPrintSettings>) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_settings = settings;
                    let arg_self_ = self.as_raw();
                    let arg_settings = arg_settings
                        .map(|arg| {
                            arg.add_ref();
                            ImplPrintSettings::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_settings);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_print_dialog_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_print_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_dialog_callback_t> for &PrintDialogCallback {
    fn as_raw(self) -> *mut _cef_print_dialog_callback_t {
        ImplPrintDialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_dialog_callback_t> for &mut PrintDialogCallback {
    fn as_raw(self) -> *mut _cef_print_dialog_callback_t {
        ImplPrintDialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PrintDialogCallback> for *mut _cef_print_dialog_callback_t {
    fn as_wrapper(self) -> PrintDialogCallback {
        PrintDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_dialog_callback_t> for PrintDialogCallback {
    fn into(self) -> *mut _cef_print_dialog_callback_t {
        let object = ImplPrintDialogCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PrintDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_print_job_callback_t] for more documentation.
#[derive(Clone)]
pub struct PrintJobCallback(RefGuard<_cef_print_job_callback_t>);
impl PrintJobCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPrintJobCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPrintJobCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPrintJobCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_print_job_callback_t).as_wrapper()
        }
    }
}
pub trait WrapPrintJobCallback: ImplPrintJobCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_print_job_callback_t, Self>);
}
pub trait ImplPrintJobCallback: Clone + Sized + Rc {
    fn cont(&self) {}
    fn init_methods(object: &mut _cef_print_job_callback_t) {
        impl_cef_print_job_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_print_job_callback_t;
}
mod impl_cef_print_job_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPrintJobCallback>(object: &mut _cef_print_job_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplPrintJobCallback>(self_: *mut _cef_print_job_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPrintJobCallback::cont(&arg_self_.interface);
    }
}
impl ImplPrintJobCallback for PrintJobCallback {
    fn cont(&self) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_print_job_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_print_job_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintJobCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_job_callback_t> for &PrintJobCallback {
    fn as_raw(self) -> *mut _cef_print_job_callback_t {
        ImplPrintJobCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_job_callback_t> for &mut PrintJobCallback {
    fn as_raw(self) -> *mut _cef_print_job_callback_t {
        ImplPrintJobCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PrintJobCallback> for *mut _cef_print_job_callback_t {
    fn as_wrapper(self) -> PrintJobCallback {
        PrintJobCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_job_callback_t> for PrintJobCallback {
    fn into(self) -> *mut _cef_print_job_callback_t {
        let object = ImplPrintJobCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PrintJobCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_print_handler_t] for more documentation.
#[derive(Clone)]
pub struct PrintHandler(RefGuard<_cef_print_handler_t>);
impl PrintHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPrintHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPrintHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPrintHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_print_handler_t).as_wrapper()
        }
    }
}
pub trait WrapPrintHandler: ImplPrintHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_print_handler_t, Self>);
}
pub trait ImplPrintHandler: Clone + Sized + Rc {
    fn on_print_start(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn on_print_settings(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        settings: Option<&mut impl ImplPrintSettings>,
        get_defaults: ::std::os::raw::c_int,
    ) {
    }
    fn on_print_dialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        has_selection: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplPrintDialogCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_print_job(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        document_name: Option<&CefStringUtf16>,
        pdf_file_path: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplPrintJobCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_print_reset(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn get_pdf_paper_size(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> Size {
        Default::default()
    }
    fn init_methods(object: &mut _cef_print_handler_t) {
        impl_cef_print_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_print_handler_t;
}
mod impl_cef_print_handler_t {
    use super::*;
    pub fn init_methods<I: ImplPrintHandler>(object: &mut _cef_print_handler_t) {
        object.on_print_start = Some(on_print_start::<I>);
        object.on_print_settings = Some(on_print_settings::<I>);
        object.on_print_dialog = Some(on_print_dialog::<I>);
        object.on_print_job = Some(on_print_job::<I>);
        object.on_print_reset = Some(on_print_reset::<I>);
        object.get_pdf_paper_size = Some(get_pdf_paper_size::<I>);
    }
    extern "C" fn on_print_start<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplPrintHandler::on_print_start(&arg_self_.interface, arg_browser);
    }
    extern "C" fn on_print_settings<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        settings: *mut _cef_print_settings_t,
        get_defaults: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_settings, arg_get_defaults) =
            (self_, browser, settings, get_defaults);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_settings = unsafe { arg_settings.as_mut() }
            .map(|arg| PrintSettings(unsafe { RefGuard::from_raw(arg) }));
        let arg_settings = arg_settings.as_mut();
        let arg_get_defaults = arg_get_defaults.as_raw();
        let result = ImplPrintHandler::on_print_settings(
            &arg_self_.interface,
            arg_browser,
            arg_settings,
            arg_get_defaults,
        );
    }
    extern "C" fn on_print_dialog<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        has_selection: ::std::os::raw::c_int,
        callback: *mut _cef_print_dialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_has_selection, arg_callback) =
            (self_, browser, has_selection, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_has_selection = arg_has_selection.as_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| PrintDialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplPrintHandler::on_print_dialog(
            &arg_self_.interface,
            arg_browser,
            arg_has_selection,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_print_job<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        document_name: *const _cef_string_utf16_t,
        pdf_file_path: *const _cef_string_utf16_t,
        callback: *mut _cef_print_job_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_document_name, arg_pdf_file_path, arg_callback) =
            (self_, browser, document_name, pdf_file_path, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_document_name = if arg_document_name.is_null() {
            None
        } else {
            Some(arg_document_name.into())
        };
        let arg_document_name = arg_document_name.as_ref();
        let arg_pdf_file_path = if arg_pdf_file_path.is_null() {
            None
        } else {
            Some(arg_pdf_file_path.into())
        };
        let arg_pdf_file_path = arg_pdf_file_path.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| PrintJobCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplPrintHandler::on_print_job(
            &arg_self_.interface,
            arg_browser,
            arg_document_name,
            arg_pdf_file_path,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_print_reset<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplPrintHandler::on_print_reset(&arg_self_.interface, arg_browser);
    }
    extern "C" fn get_pdf_paper_size<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> _cef_size_t {
        let (arg_self_, arg_browser, arg_device_units_per_inch) =
            (self_, browser, device_units_per_inch);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_device_units_per_inch = arg_device_units_per_inch.as_raw();
        let result = ImplPrintHandler::get_pdf_paper_size(
            &arg_self_.interface,
            arg_browser,
            arg_device_units_per_inch,
        );
        result.into()
    }
}
impl ImplPrintHandler for PrintHandler {
    fn on_print_start(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_print_start
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_print_settings(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        settings: Option<&mut impl ImplPrintSettings>,
        get_defaults: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_print_settings
                .map(|f| {
                    let (arg_browser, arg_settings, arg_get_defaults) =
                        (browser, settings, get_defaults);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_settings = arg_settings
                        .map(|arg| {
                            arg.add_ref();
                            ImplPrintSettings::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_get_defaults = arg_get_defaults;
                    let result = f(arg_self_, arg_browser, arg_settings, arg_get_defaults);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_print_dialog(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        has_selection: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplPrintDialogCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_print_dialog
                .map(|f| {
                    let (arg_browser, arg_has_selection, arg_callback) =
                        (browser, has_selection, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_has_selection = arg_has_selection;
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplPrintDialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_has_selection, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_print_job(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        document_name: Option<&CefStringUtf16>,
        pdf_file_path: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplPrintJobCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_print_job
                .map(|f| {
                    let (arg_browser, arg_document_name, arg_pdf_file_path, arg_callback) =
                        (browser, document_name, pdf_file_path, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_document_name = arg_document_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_pdf_file_path = arg_pdf_file_path
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplPrintJobCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_document_name,
                        arg_pdf_file_path,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_print_reset(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_print_reset
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_pdf_paper_size(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> Size {
        unsafe {
            self.0
                .get_pdf_paper_size
                .map(|f| {
                    let (arg_browser, arg_device_units_per_inch) = (browser, device_units_per_inch);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_device_units_per_inch = arg_device_units_per_inch;
                    let result = f(arg_self_, arg_browser, arg_device_units_per_inch);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_print_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_print_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_handler_t> for &PrintHandler {
    fn as_raw(self) -> *mut _cef_print_handler_t {
        ImplPrintHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_handler_t> for &mut PrintHandler {
    fn as_raw(self) -> *mut _cef_print_handler_t {
        ImplPrintHandler::get_raw(self)
    }
}
impl ConvertReturnValue<PrintHandler> for *mut _cef_print_handler_t {
    fn as_wrapper(self) -> PrintHandler {
        PrintHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_handler_t> for PrintHandler {
    fn into(self) -> *mut _cef_print_handler_t {
        let object = ImplPrintHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PrintHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_accessibility_handler_t] for more documentation.
#[derive(Clone)]
pub struct AccessibilityHandler(RefGuard<_cef_accessibility_handler_t>);
impl AccessibilityHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapAccessibilityHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplAccessibilityHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapAccessibilityHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_accessibility_handler_t).as_wrapper()
        }
    }
}
pub trait WrapAccessibilityHandler: ImplAccessibilityHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_accessibility_handler_t, Self>);
}
pub trait ImplAccessibilityHandler: Clone + Sized + Rc {
    fn on_accessibility_tree_change(&self, value: Option<&mut impl ImplValue>) {}
    fn on_accessibility_location_change(&self, value: Option<&mut impl ImplValue>) {}
    fn init_methods(object: &mut _cef_accessibility_handler_t) {
        impl_cef_accessibility_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_accessibility_handler_t;
}
mod impl_cef_accessibility_handler_t {
    use super::*;
    pub fn init_methods<I: ImplAccessibilityHandler>(object: &mut _cef_accessibility_handler_t) {
        object.on_accessibility_tree_change = Some(on_accessibility_tree_change::<I>);
        object.on_accessibility_location_change = Some(on_accessibility_location_change::<I>);
    }
    extern "C" fn on_accessibility_tree_change<I: ImplAccessibilityHandler>(
        self_: *mut _cef_accessibility_handler_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result =
            ImplAccessibilityHandler::on_accessibility_tree_change(&arg_self_.interface, arg_value);
    }
    extern "C" fn on_accessibility_location_change<I: ImplAccessibilityHandler>(
        self_: *mut _cef_accessibility_handler_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplAccessibilityHandler::on_accessibility_location_change(
            &arg_self_.interface,
            arg_value,
        );
    }
}
impl ImplAccessibilityHandler for AccessibilityHandler {
    fn on_accessibility_tree_change(&self, value: Option<&mut impl ImplValue>) {
        unsafe {
            self.0
                .on_accessibility_tree_change
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_accessibility_location_change(&self, value: Option<&mut impl ImplValue>) {
        unsafe {
            self.0
                .on_accessibility_location_change
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_accessibility_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_accessibility_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AccessibilityHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_accessibility_handler_t> for &AccessibilityHandler {
    fn as_raw(self) -> *mut _cef_accessibility_handler_t {
        ImplAccessibilityHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_accessibility_handler_t> for &mut AccessibilityHandler {
    fn as_raw(self) -> *mut _cef_accessibility_handler_t {
        ImplAccessibilityHandler::get_raw(self)
    }
}
impl ConvertReturnValue<AccessibilityHandler> for *mut _cef_accessibility_handler_t {
    fn as_wrapper(self) -> AccessibilityHandler {
        AccessibilityHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_accessibility_handler_t> for AccessibilityHandler {
    fn into(self) -> *mut _cef_accessibility_handler_t {
        let object = ImplAccessibilityHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for AccessibilityHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_render_handler_t] for more documentation.
#[derive(Clone)]
pub struct RenderHandler(RefGuard<_cef_render_handler_t>);
impl RenderHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRenderHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRenderHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRenderHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_render_handler_t).as_wrapper()
        }
    }
}
pub trait WrapRenderHandler: ImplRenderHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_render_handler_t, Self>);
}
pub trait ImplRenderHandler: Clone + Sized + Rc {
    fn get_accessibility_handler(&self) -> Option<AccessibilityHandler> {
        Default::default()
    }
    fn get_root_screen_rect(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        rect: Option<&mut Rect>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_view_rect(&self, browser: Option<&mut impl ImplBrowser>, rect: Option<&mut Rect>) {}
    fn get_screen_point(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: Option<&mut ::std::os::raw::c_int>,
        screen_y: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_screen_info(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        screen_info: Option<&mut ScreenInfo>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_popup_show(&self, browser: Option<&mut impl ImplBrowser>, show: ::std::os::raw::c_int) {}
    fn on_popup_size(&self, browser: Option<&mut impl ImplBrowser>, rect: Option<&Rect>) {}
    fn on_paint(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        buffer: *const u8,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
    }
    fn on_accelerated_paint(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        info: Option<&AcceleratedPaintInfo>,
    ) {
    }
    fn get_touch_handle_size(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        orientation: HorizontalAlignment,
        size: Option<&mut Size>,
    ) {
    }
    fn on_touch_handle_state_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        state: Option<&TouchHandleState>,
    ) {
    }
    fn start_dragging(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        drag_data: Option<&mut impl ImplDragData>,
        allowed_ops: DragOperationsMask,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn update_drag_cursor(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        operation: DragOperationsMask,
    ) {
    }
    fn on_scroll_offset_changed(&self, browser: Option<&mut impl ImplBrowser>, x: f64, y: f64) {}
    fn on_ime_composition_range_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        selected_range: Option<&Range>,
        character_bounds_count: usize,
        character_bounds: Option<&Rect>,
    ) {
    }
    fn on_text_selection_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        selected_text: Option<&CefStringUtf16>,
        selected_range: Option<&Range>,
    ) {
    }
    fn on_virtual_keyboard_requested(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        input_mode: TextInputMode,
    ) {
    }
    fn init_methods(object: &mut _cef_render_handler_t) {
        impl_cef_render_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_render_handler_t;
}
mod impl_cef_render_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRenderHandler>(object: &mut _cef_render_handler_t) {
        object.get_accessibility_handler = Some(get_accessibility_handler::<I>);
        object.get_root_screen_rect = Some(get_root_screen_rect::<I>);
        object.get_view_rect = Some(get_view_rect::<I>);
        object.get_screen_point = Some(get_screen_point::<I>);
        object.get_screen_info = Some(get_screen_info::<I>);
        object.on_popup_show = Some(on_popup_show::<I>);
        object.on_popup_size = Some(on_popup_size::<I>);
        object.on_paint = Some(on_paint::<I>);
        object.on_accelerated_paint = Some(on_accelerated_paint::<I>);
        object.get_touch_handle_size = Some(get_touch_handle_size::<I>);
        object.on_touch_handle_state_changed = Some(on_touch_handle_state_changed::<I>);
        object.start_dragging = Some(start_dragging::<I>);
        object.update_drag_cursor = Some(update_drag_cursor::<I>);
        object.on_scroll_offset_changed = Some(on_scroll_offset_changed::<I>);
        object.on_ime_composition_range_changed = Some(on_ime_composition_range_changed::<I>);
        object.on_text_selection_changed = Some(on_text_selection_changed::<I>);
        object.on_virtual_keyboard_requested = Some(on_virtual_keyboard_requested::<I>);
    }
    extern "C" fn get_accessibility_handler<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
    ) -> *mut _cef_accessibility_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRenderHandler::get_accessibility_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_root_screen_rect<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *mut _cef_rect_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_rect = if arg_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_rect))
        };
        let arg_rect = arg_rect.as_mut().map(|arg| arg.as_mut());
        let result =
            ImplRenderHandler::get_root_screen_rect(&arg_self_.interface, arg_browser, arg_rect);
        result.into()
    }
    extern "C" fn get_view_rect<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *mut _cef_rect_t,
    ) {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_rect = if arg_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_rect))
        };
        let arg_rect = arg_rect.as_mut().map(|arg| arg.as_mut());
        let result = ImplRenderHandler::get_view_rect(&arg_self_.interface, arg_browser, arg_rect);
    }
    extern "C" fn get_screen_point<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: *mut ::std::os::raw::c_int,
        screen_y: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_view_x, arg_view_y, arg_screen_x, arg_screen_y) =
            (self_, browser, view_x, view_y, screen_x, screen_y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_view_x = arg_view_x.as_raw();
        let arg_view_y = arg_view_y.as_raw();
        let mut arg_screen_x = if arg_screen_x.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_screen_x))
        };
        let arg_screen_x = arg_screen_x.as_mut().map(|arg| arg.as_mut());
        let mut arg_screen_y = if arg_screen_y.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_screen_y))
        };
        let arg_screen_y = arg_screen_y.as_mut().map(|arg| arg.as_mut());
        let result = ImplRenderHandler::get_screen_point(
            &arg_self_.interface,
            arg_browser,
            arg_view_x,
            arg_view_y,
            arg_screen_x,
            arg_screen_y,
        );
        result.into()
    }
    extern "C" fn get_screen_info<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        screen_info: *mut _cef_screen_info_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_screen_info) = (self_, browser, screen_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_screen_info = if arg_screen_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<ScreenInfo>::from(arg_screen_info))
        };
        let arg_screen_info = arg_screen_info.as_mut().map(|arg| arg.as_mut());
        let result =
            ImplRenderHandler::get_screen_info(&arg_self_.interface, arg_browser, arg_screen_info);
        result.into()
    }
    extern "C" fn on_popup_show<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        show: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_show) = (self_, browser, show);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_show = arg_show.as_raw();
        let result = ImplRenderHandler::on_popup_show(&arg_self_.interface, arg_browser, arg_show);
    }
    extern "C" fn on_popup_size<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_rect = if arg_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_rect))
        };
        let arg_rect = arg_rect.as_ref().map(|arg| arg.as_ref());
        let result = ImplRenderHandler::on_popup_size(&arg_self_.interface, arg_browser, arg_rect);
    }
    extern "C" fn on_paint<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        type_: cef_paint_element_type_t,
        dirty_rects_count: usize,
        dirty_rects: *const _cef_rect_t,
        buffer: *const ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_buffer,
            arg_width,
            arg_height,
        ) = (
            self_,
            browser,
            type_,
            dirty_rects_count,
            dirty_rects,
            buffer,
            width,
            height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_type_ = arg_type_.as_raw();
        let arg_dirty_rects_count = arg_dirty_rects_count.as_raw();
        let arg_dirty_rects = if arg_dirty_rects.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_dirty_rects))
        };
        let arg_dirty_rects = arg_dirty_rects.as_ref().map(|arg| arg.as_ref());
        let arg_buffer = arg_buffer as *const _;
        let arg_width = arg_width.as_raw();
        let arg_height = arg_height.as_raw();
        let result = ImplRenderHandler::on_paint(
            &arg_self_.interface,
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_buffer,
            arg_width,
            arg_height,
        );
    }
    extern "C" fn on_accelerated_paint<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        type_: cef_paint_element_type_t,
        dirty_rects_count: usize,
        dirty_rects: *const _cef_rect_t,
        info: *const _cef_accelerated_paint_info_t,
    ) {
        let (arg_self_, arg_browser, arg_type_, arg_dirty_rects_count, arg_dirty_rects, arg_info) =
            (self_, browser, type_, dirty_rects_count, dirty_rects, info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_type_ = arg_type_.as_raw();
        let arg_dirty_rects_count = arg_dirty_rects_count.as_raw();
        let arg_dirty_rects = if arg_dirty_rects.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_dirty_rects))
        };
        let arg_dirty_rects = arg_dirty_rects.as_ref().map(|arg| arg.as_ref());
        let arg_info = if arg_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<AcceleratedPaintInfo>::from(arg_info))
        };
        let arg_info = arg_info.as_ref().map(|arg| arg.as_ref());
        let result = ImplRenderHandler::on_accelerated_paint(
            &arg_self_.interface,
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_info,
        );
    }
    extern "C" fn get_touch_handle_size<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        orientation: cef_horizontal_alignment_t,
        size: *mut _cef_size_t,
    ) {
        let (arg_self_, arg_browser, arg_orientation, arg_size) =
            (self_, browser, orientation, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_orientation = arg_orientation.as_raw();
        let mut arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_size))
        };
        let arg_size = arg_size.as_mut().map(|arg| arg.as_mut());
        let result = ImplRenderHandler::get_touch_handle_size(
            &arg_self_.interface,
            arg_browser,
            arg_orientation,
            arg_size,
        );
    }
    extern "C" fn on_touch_handle_state_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        state: *const _cef_touch_handle_state_t,
    ) {
        let (arg_self_, arg_browser, arg_state) = (self_, browser, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_state = if arg_state.is_null() {
            None
        } else {
            Some(WrapParamRef::<TouchHandleState>::from(arg_state))
        };
        let arg_state = arg_state.as_ref().map(|arg| arg.as_ref());
        let result = ImplRenderHandler::on_touch_handle_state_changed(
            &arg_self_.interface,
            arg_browser,
            arg_state,
        );
    }
    extern "C" fn start_dragging<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        drag_data: *mut _cef_drag_data_t,
        allowed_ops: cef_drag_operations_mask_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_drag_data, arg_allowed_ops, arg_x, arg_y) =
            (self_, browser, drag_data, allowed_ops, x, y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_drag_data = unsafe { arg_drag_data.as_mut() }
            .map(|arg| DragData(unsafe { RefGuard::from_raw(arg) }));
        let arg_drag_data = arg_drag_data.as_mut();
        let arg_allowed_ops = arg_allowed_ops.as_raw();
        let arg_x = arg_x.as_raw();
        let arg_y = arg_y.as_raw();
        let result = ImplRenderHandler::start_dragging(
            &arg_self_.interface,
            arg_browser,
            arg_drag_data,
            arg_allowed_ops,
            arg_x,
            arg_y,
        );
        result.into()
    }
    extern "C" fn update_drag_cursor<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        operation: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_browser, arg_operation) = (self_, browser, operation);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_operation = arg_operation.as_raw();
        let result =
            ImplRenderHandler::update_drag_cursor(&arg_self_.interface, arg_browser, arg_operation);
    }
    extern "C" fn on_scroll_offset_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        x: f64,
        y: f64,
    ) {
        let (arg_self_, arg_browser, arg_x, arg_y) = (self_, browser, x, y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_x = arg_x.as_raw();
        let arg_y = arg_y.as_raw();
        let result = ImplRenderHandler::on_scroll_offset_changed(
            &arg_self_.interface,
            arg_browser,
            arg_x,
            arg_y,
        );
    }
    extern "C" fn on_ime_composition_range_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        selected_range: *const _cef_range_t,
        character_bounds_count: usize,
        character_bounds: *const _cef_rect_t,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_selected_range,
            arg_character_bounds_count,
            arg_character_bounds,
        ) = (
            self_,
            browser,
            selected_range,
            character_bounds_count,
            character_bounds,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_selected_range = if arg_selected_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_selected_range))
        };
        let arg_selected_range = arg_selected_range.as_ref().map(|arg| arg.as_ref());
        let arg_character_bounds_count = arg_character_bounds_count.as_raw();
        let arg_character_bounds = if arg_character_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_character_bounds))
        };
        let arg_character_bounds = arg_character_bounds.as_ref().map(|arg| arg.as_ref());
        let result = ImplRenderHandler::on_ime_composition_range_changed(
            &arg_self_.interface,
            arg_browser,
            arg_selected_range,
            arg_character_bounds_count,
            arg_character_bounds,
        );
    }
    extern "C" fn on_text_selection_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        selected_text: *const _cef_string_utf16_t,
        selected_range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_browser, arg_selected_text, arg_selected_range) =
            (self_, browser, selected_text, selected_range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_selected_text = if arg_selected_text.is_null() {
            None
        } else {
            Some(arg_selected_text.into())
        };
        let arg_selected_text = arg_selected_text.as_ref();
        let arg_selected_range = if arg_selected_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_selected_range))
        };
        let arg_selected_range = arg_selected_range.as_ref().map(|arg| arg.as_ref());
        let result = ImplRenderHandler::on_text_selection_changed(
            &arg_self_.interface,
            arg_browser,
            arg_selected_text,
            arg_selected_range,
        );
    }
    extern "C" fn on_virtual_keyboard_requested<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        input_mode: cef_text_input_mode_t,
    ) {
        let (arg_self_, arg_browser, arg_input_mode) = (self_, browser, input_mode);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_input_mode = arg_input_mode.as_raw();
        let result = ImplRenderHandler::on_virtual_keyboard_requested(
            &arg_self_.interface,
            arg_browser,
            arg_input_mode,
        );
    }
}
impl ImplRenderHandler for RenderHandler {
    fn get_accessibility_handler(&self) -> Option<AccessibilityHandler> {
        unsafe {
            self.0
                .get_accessibility_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_root_screen_rect(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        rect: Option<&mut Rect>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_root_screen_rect
                .map(|f| {
                    let (arg_browser, arg_rect) = (browser, rect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_rect = arg_rect.cloned().map(|arg| arg.into());
                    let arg_rect = arg_rect
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_rect);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_view_rect(&self, browser: Option<&mut impl ImplBrowser>, rect: Option<&mut Rect>) {
        unsafe {
            self.0
                .get_view_rect
                .map(|f| {
                    let (arg_browser, arg_rect) = (browser, rect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_rect = arg_rect.cloned().map(|arg| arg.into());
                    let arg_rect = arg_rect
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_rect);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_screen_point(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: Option<&mut ::std::os::raw::c_int>,
        screen_y: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_screen_point
                .map(|f| {
                    let (arg_browser, arg_view_x, arg_view_y, arg_screen_x, arg_screen_y) =
                        (browser, view_x, view_y, screen_x, screen_y);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_view_x = arg_view_x;
                    let arg_view_y = arg_view_y;
                    let arg_screen_x = arg_screen_x
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_screen_y = arg_screen_y
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_view_x,
                        arg_view_y,
                        arg_screen_x,
                        arg_screen_y,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_screen_info(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        screen_info: Option<&mut ScreenInfo>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_screen_info
                .map(|f| {
                    let (arg_browser, arg_screen_info) = (browser, screen_info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_screen_info = arg_screen_info.cloned().map(|arg| arg.into());
                    let arg_screen_info = arg_screen_info
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_screen_info);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_popup_show(&self, browser: Option<&mut impl ImplBrowser>, show: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_popup_show
                .map(|f| {
                    let (arg_browser, arg_show) = (browser, show);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_show = arg_show;
                    let result = f(arg_self_, arg_browser, arg_show);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_popup_size(&self, browser: Option<&mut impl ImplBrowser>, rect: Option<&Rect>) {
        unsafe {
            self.0
                .on_popup_size
                .map(|f| {
                    let (arg_browser, arg_rect) = (browser, rect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_rect = arg_rect.cloned().map(|arg| arg.into());
                    let arg_rect = arg_rect
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_rect);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_paint(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        buffer: *const u8,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_paint
                .map(|f| {
                    let (
                        arg_browser,
                        arg_type_,
                        arg_dirty_rects_count,
                        arg_dirty_rects,
                        arg_buffer,
                        arg_width,
                        arg_height,
                    ) = (
                        browser,
                        type_,
                        dirty_rects_count,
                        dirty_rects,
                        buffer,
                        width,
                        height,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_type_ = arg_type_.as_raw();
                    let arg_dirty_rects_count = arg_dirty_rects_count;
                    let arg_dirty_rects = arg_dirty_rects.cloned().map(|arg| arg.into());
                    let arg_dirty_rects = arg_dirty_rects
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_buffer = arg_buffer as *const _;
                    let arg_width = arg_width;
                    let arg_height = arg_height;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_type_,
                        arg_dirty_rects_count,
                        arg_dirty_rects,
                        arg_buffer,
                        arg_width,
                        arg_height,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_accelerated_paint(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        info: Option<&AcceleratedPaintInfo>,
    ) {
        unsafe {
            self.0
                .on_accelerated_paint
                .map(|f| {
                    let (arg_browser, arg_type_, arg_dirty_rects_count, arg_dirty_rects, arg_info) =
                        (browser, type_, dirty_rects_count, dirty_rects, info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_type_ = arg_type_.as_raw();
                    let arg_dirty_rects_count = arg_dirty_rects_count;
                    let arg_dirty_rects = arg_dirty_rects.cloned().map(|arg| arg.into());
                    let arg_dirty_rects = arg_dirty_rects
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_info = arg_info.cloned().map(|arg| arg.into());
                    let arg_info = arg_info
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_type_,
                        arg_dirty_rects_count,
                        arg_dirty_rects,
                        arg_info,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_touch_handle_size(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        orientation: HorizontalAlignment,
        size: Option<&mut Size>,
    ) {
        unsafe {
            self.0
                .get_touch_handle_size
                .map(|f| {
                    let (arg_browser, arg_orientation, arg_size) = (browser, orientation, size);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_orientation = arg_orientation.as_raw();
                    let mut arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_orientation, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_touch_handle_state_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        state: Option<&TouchHandleState>,
    ) {
        unsafe {
            self.0
                .on_touch_handle_state_changed
                .map(|f| {
                    let (arg_browser, arg_state) = (browser, state);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_state = arg_state.cloned().map(|arg| arg.into());
                    let arg_state = arg_state
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn start_dragging(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        drag_data: Option<&mut impl ImplDragData>,
        allowed_ops: DragOperationsMask,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .start_dragging
                .map(|f| {
                    let (arg_browser, arg_drag_data, arg_allowed_ops, arg_x, arg_y) =
                        (browser, drag_data, allowed_ops, x, y);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_drag_data = arg_drag_data
                        .map(|arg| {
                            arg.add_ref();
                            ImplDragData::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_allowed_ops = arg_allowed_ops.as_raw();
                    let arg_x = arg_x;
                    let arg_y = arg_y;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_drag_data,
                        arg_allowed_ops,
                        arg_x,
                        arg_y,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn update_drag_cursor(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        operation: DragOperationsMask,
    ) {
        unsafe {
            self.0
                .update_drag_cursor
                .map(|f| {
                    let (arg_browser, arg_operation) = (browser, operation);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_operation = arg_operation.as_raw();
                    let result = f(arg_self_, arg_browser, arg_operation);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_scroll_offset_changed(&self, browser: Option<&mut impl ImplBrowser>, x: f64, y: f64) {
        unsafe {
            self.0
                .on_scroll_offset_changed
                .map(|f| {
                    let (arg_browser, arg_x, arg_y) = (browser, x, y);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_x = arg_x;
                    let arg_y = arg_y;
                    let result = f(arg_self_, arg_browser, arg_x, arg_y);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_ime_composition_range_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        selected_range: Option<&Range>,
        character_bounds_count: usize,
        character_bounds: Option<&Rect>,
    ) {
        unsafe {
            self.0
                .on_ime_composition_range_changed
                .map(|f| {
                    let (
                        arg_browser,
                        arg_selected_range,
                        arg_character_bounds_count,
                        arg_character_bounds,
                    ) = (
                        browser,
                        selected_range,
                        character_bounds_count,
                        character_bounds,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_selected_range = arg_selected_range.cloned().map(|arg| arg.into());
                    let arg_selected_range = arg_selected_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_character_bounds_count = arg_character_bounds_count;
                    let arg_character_bounds = arg_character_bounds.cloned().map(|arg| arg.into());
                    let arg_character_bounds = arg_character_bounds
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_selected_range,
                        arg_character_bounds_count,
                        arg_character_bounds,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_text_selection_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        selected_text: Option<&CefStringUtf16>,
        selected_range: Option<&Range>,
    ) {
        unsafe {
            self.0
                .on_text_selection_changed
                .map(|f| {
                    let (arg_browser, arg_selected_text, arg_selected_range) =
                        (browser, selected_text, selected_range);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_selected_text = arg_selected_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_selected_range = arg_selected_range.cloned().map(|arg| arg.into());
                    let arg_selected_range = arg_selected_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_selected_text,
                        arg_selected_range,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_virtual_keyboard_requested(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        input_mode: TextInputMode,
    ) {
        unsafe {
            self.0
                .on_virtual_keyboard_requested
                .map(|f| {
                    let (arg_browser, arg_input_mode) = (browser, input_mode);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_input_mode = arg_input_mode.as_raw();
                    let result = f(arg_self_, arg_browser, arg_input_mode);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_render_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_render_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RenderHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_render_handler_t> for &RenderHandler {
    fn as_raw(self) -> *mut _cef_render_handler_t {
        ImplRenderHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_render_handler_t> for &mut RenderHandler {
    fn as_raw(self) -> *mut _cef_render_handler_t {
        ImplRenderHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RenderHandler> for *mut _cef_render_handler_t {
    fn as_wrapper(self) -> RenderHandler {
        RenderHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_render_handler_t> for RenderHandler {
    fn into(self) -> *mut _cef_render_handler_t {
        let object = ImplRenderHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RenderHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_auth_callback_t] for more documentation.
#[derive(Clone)]
pub struct AuthCallback(RefGuard<_cef_auth_callback_t>);
impl AuthCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapAuthCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplAuthCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapAuthCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_auth_callback_t).as_wrapper()
        }
    }
}
pub trait WrapAuthCallback: ImplAuthCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_auth_callback_t, Self>);
}
pub trait ImplAuthCallback: Clone + Sized + Rc {
    fn cont(&self, username: Option<&CefStringUtf16>, password: Option<&CefStringUtf16>) {}
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_auth_callback_t) {
        impl_cef_auth_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_auth_callback_t;
}
mod impl_cef_auth_callback_t {
    use super::*;
    pub fn init_methods<I: ImplAuthCallback>(object: &mut _cef_auth_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplAuthCallback>(
        self_: *mut _cef_auth_callback_t,
        username: *const _cef_string_utf16_t,
        password: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_username, arg_password) = (self_, username, password);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_username = if arg_username.is_null() {
            None
        } else {
            Some(arg_username.into())
        };
        let arg_username = arg_username.as_ref();
        let arg_password = if arg_password.is_null() {
            None
        } else {
            Some(arg_password.into())
        };
        let arg_password = arg_password.as_ref();
        let result = ImplAuthCallback::cont(&arg_self_.interface, arg_username, arg_password);
    }
    extern "C" fn cancel<I: ImplAuthCallback>(self_: *mut _cef_auth_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplAuthCallback::cancel(&arg_self_.interface);
    }
}
impl ImplAuthCallback for AuthCallback {
    fn cont(&self, username: Option<&CefStringUtf16>, password: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_username, arg_password) = (username, password);
                    let arg_self_ = self.as_raw();
                    let arg_username = arg_username
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_password = arg_password
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_username, arg_password);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_auth_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_auth_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AuthCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_auth_callback_t> for &AuthCallback {
    fn as_raw(self) -> *mut _cef_auth_callback_t {
        ImplAuthCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_auth_callback_t> for &mut AuthCallback {
    fn as_raw(self) -> *mut _cef_auth_callback_t {
        ImplAuthCallback::get_raw(self)
    }
}
impl ConvertReturnValue<AuthCallback> for *mut _cef_auth_callback_t {
    fn as_wrapper(self) -> AuthCallback {
        AuthCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_auth_callback_t> for AuthCallback {
    fn into(self) -> *mut _cef_auth_callback_t {
        let object = ImplAuthCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for AuthCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_response_t] for more documentation.
#[derive(Clone)]
pub struct Response(RefGuard<_cef_response_t>);
impl Response {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResponse,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResponse>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResponse>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_response_t).as_wrapper()
        }
    }
}
pub trait WrapResponse: ImplResponse {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_response_t, Self>);
}
pub trait ImplResponse: Clone + Sized + Rc {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_error(&self) -> Errorcode {
        Default::default()
    }
    fn set_error(&self, error: Errorcode) {}
    fn get_status(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_status(&self, status: ::std::os::raw::c_int) {}
    fn get_status_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_status_text(&self, status_text: Option<&CefStringUtf16>) {}
    fn get_mime_type(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_mime_type(&self, mime_type: Option<&CefStringUtf16>) {}
    fn get_charset(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_charset(&self, charset: Option<&CefStringUtf16>) {}
    fn get_header_by_name(&self, name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_header_by_name(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
        overwrite: ::std::os::raw::c_int,
    ) {
    }
    fn get_header_map(&self, header_map: Option<&mut CefStringMultimap>) {}
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>) {}
    fn get_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_url(&self, url: Option<&CefStringUtf16>) {}
    fn init_methods(object: &mut _cef_response_t) {
        impl_cef_response_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_response_t;
}
mod impl_cef_response_t {
    use super::*;
    pub fn init_methods<I: ImplResponse>(object: &mut _cef_response_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.get_error = Some(get_error::<I>);
        object.set_error = Some(set_error::<I>);
        object.get_status = Some(get_status::<I>);
        object.set_status = Some(set_status::<I>);
        object.get_status_text = Some(get_status_text::<I>);
        object.set_status_text = Some(set_status_text::<I>);
        object.get_mime_type = Some(get_mime_type::<I>);
        object.set_mime_type = Some(set_mime_type::<I>);
        object.get_charset = Some(get_charset::<I>);
        object.set_charset = Some(set_charset::<I>);
        object.get_header_by_name = Some(get_header_by_name::<I>);
        object.set_header_by_name = Some(set_header_by_name::<I>);
        object.get_header_map = Some(get_header_map::<I>);
        object.set_header_map = Some(set_header_map::<I>);
        object.get_url = Some(get_url::<I>);
        object.set_url = Some(set_url::<I>);
    }
    extern "C" fn is_read_only<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponse::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_error<I: ImplResponse>(self_: *mut _cef_response_t) -> cef_errorcode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponse::get_error(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_error<I: ImplResponse>(self_: *mut _cef_response_t, error: cef_errorcode_t) {
        let (arg_self_, arg_error) = (self_, error);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_error = arg_error.as_raw();
        let result = ImplResponse::set_error(&arg_self_.interface, arg_error);
    }
    extern "C" fn get_status<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponse::get_status(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_status<I: ImplResponse>(
        self_: *mut _cef_response_t,
        status: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_status) = (self_, status);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_status = arg_status.as_raw();
        let result = ImplResponse::set_status(&arg_self_.interface, arg_status);
    }
    extern "C" fn get_status_text<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponse::get_status_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_status_text<I: ImplResponse>(
        self_: *mut _cef_response_t,
        status_text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_status_text) = (self_, status_text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_status_text = if arg_status_text.is_null() {
            None
        } else {
            Some(arg_status_text.into())
        };
        let arg_status_text = arg_status_text.as_ref();
        let result = ImplResponse::set_status_text(&arg_self_.interface, arg_status_text);
    }
    extern "C" fn get_mime_type<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponse::get_mime_type(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_mime_type<I: ImplResponse>(
        self_: *mut _cef_response_t,
        mime_type: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_mime_type) = (self_, mime_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mime_type = if arg_mime_type.is_null() {
            None
        } else {
            Some(arg_mime_type.into())
        };
        let arg_mime_type = arg_mime_type.as_ref();
        let result = ImplResponse::set_mime_type(&arg_self_.interface, arg_mime_type);
    }
    extern "C" fn get_charset<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponse::get_charset(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_charset<I: ImplResponse>(
        self_: *mut _cef_response_t,
        charset: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_charset) = (self_, charset);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_charset = if arg_charset.is_null() {
            None
        } else {
            Some(arg_charset.into())
        };
        let arg_charset = arg_charset.as_ref();
        let result = ImplResponse::set_charset(&arg_self_.interface, arg_charset);
    }
    extern "C" fn get_header_by_name<I: ImplResponse>(
        self_: *mut _cef_response_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplResponse::get_header_by_name(&arg_self_.interface, arg_name);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_header_by_name<I: ImplResponse>(
        self_: *mut _cef_response_t,
        name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
        overwrite: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_name, arg_value, arg_overwrite) = (self_, name, value, overwrite);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let arg_overwrite = arg_overwrite.as_raw();
        let result = ImplResponse::set_header_by_name(
            &arg_self_.interface,
            arg_name,
            arg_value,
            arg_overwrite,
        );
    }
    extern "C" fn get_header_map<I: ImplResponse>(
        self_: *mut _cef_response_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = if arg_header_map.is_null() {
            None
        } else {
            Some(arg_header_map.into())
        };
        let arg_header_map = arg_header_map.as_mut();
        let result = ImplResponse::get_header_map(&arg_self_.interface, arg_header_map);
    }
    extern "C" fn set_header_map<I: ImplResponse>(
        self_: *mut _cef_response_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = if arg_header_map.is_null() {
            None
        } else {
            Some(arg_header_map.into())
        };
        let arg_header_map = arg_header_map.as_mut();
        let result = ImplResponse::set_header_map(&arg_self_.interface, arg_header_map);
    }
    extern "C" fn get_url<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponse::get_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_url<I: ImplResponse>(
        self_: *mut _cef_response_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let result = ImplResponse::set_url(&arg_self_.interface, arg_url);
    }
}
impl ImplResponse for Response {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_error(&self) -> Errorcode {
        unsafe {
            self.0
                .get_error
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_error(&self, error: Errorcode) {
        unsafe {
            self.0
                .set_error
                .map(|f| {
                    let arg_error = error;
                    let arg_self_ = self.as_raw();
                    let arg_error = arg_error.as_raw();
                    let result = f(arg_self_, arg_error);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_status(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_status(&self, status: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_status
                .map(|f| {
                    let arg_status = status;
                    let arg_self_ = self.as_raw();
                    let arg_status = arg_status;
                    let result = f(arg_self_, arg_status);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_status_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_status_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_status_text(&self, status_text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_status_text
                .map(|f| {
                    let arg_status_text = status_text;
                    let arg_self_ = self.as_raw();
                    let arg_status_text = arg_status_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_status_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_mime_type(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_mime_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_mime_type(&self, mime_type: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_mime_type
                .map(|f| {
                    let arg_mime_type = mime_type;
                    let arg_self_ = self.as_raw();
                    let arg_mime_type = arg_mime_type
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_mime_type);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_charset(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_charset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_charset(&self, charset: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_charset
                .map(|f| {
                    let arg_charset = charset;
                    let arg_self_ = self.as_raw();
                    let arg_charset = arg_charset
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_charset);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_by_name(&self, name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_header_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_header_by_name(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_header_by_name
                .map(|f| {
                    let (arg_name, arg_value, arg_overwrite) = (name, value, overwrite);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_overwrite = arg_overwrite;
                    let result = f(arg_self_, arg_name, arg_value, arg_overwrite);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            self.0
                .get_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            self.0
                .set_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_url(&self, url: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_response_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_response_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Response {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_response_t> for &Response {
    fn as_raw(self) -> *mut _cef_response_t {
        ImplResponse::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_response_t> for &mut Response {
    fn as_raw(self) -> *mut _cef_response_t {
        ImplResponse::get_raw(self)
    }
}
impl ConvertReturnValue<Response> for *mut _cef_response_t {
    fn as_wrapper(self) -> Response {
        Response(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_response_t> for Response {
    fn into(self) -> *mut _cef_response_t {
        let object = ImplResponse::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Response {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_resource_skip_callback_t] for more documentation.
#[derive(Clone)]
pub struct ResourceSkipCallback(RefGuard<_cef_resource_skip_callback_t>);
impl ResourceSkipCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceSkipCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceSkipCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceSkipCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_resource_skip_callback_t).as_wrapper()
        }
    }
}
pub trait WrapResourceSkipCallback: ImplResourceSkipCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_skip_callback_t, Self>);
}
pub trait ImplResourceSkipCallback: Clone + Sized + Rc {
    fn cont(&self, bytes_skipped: i64) {}
    fn init_methods(object: &mut _cef_resource_skip_callback_t) {
        impl_cef_resource_skip_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_skip_callback_t;
}
mod impl_cef_resource_skip_callback_t {
    use super::*;
    pub fn init_methods<I: ImplResourceSkipCallback>(object: &mut _cef_resource_skip_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplResourceSkipCallback>(
        self_: *mut _cef_resource_skip_callback_t,
        bytes_skipped: i64,
    ) {
        let (arg_self_, arg_bytes_skipped) = (self_, bytes_skipped);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_skipped = arg_bytes_skipped.as_raw();
        let result = ImplResourceSkipCallback::cont(&arg_self_.interface, arg_bytes_skipped);
    }
}
impl ImplResourceSkipCallback for ResourceSkipCallback {
    fn cont(&self, bytes_skipped: i64) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_bytes_skipped = bytes_skipped;
                    let arg_self_ = self.as_raw();
                    let arg_bytes_skipped = arg_bytes_skipped;
                    let result = f(arg_self_, arg_bytes_skipped);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_skip_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_resource_skip_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceSkipCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_skip_callback_t> for &ResourceSkipCallback {
    fn as_raw(self) -> *mut _cef_resource_skip_callback_t {
        ImplResourceSkipCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_skip_callback_t> for &mut ResourceSkipCallback {
    fn as_raw(self) -> *mut _cef_resource_skip_callback_t {
        ImplResourceSkipCallback::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceSkipCallback> for *mut _cef_resource_skip_callback_t {
    fn as_wrapper(self) -> ResourceSkipCallback {
        ResourceSkipCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_skip_callback_t> for ResourceSkipCallback {
    fn into(self) -> *mut _cef_resource_skip_callback_t {
        let object = ImplResourceSkipCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ResourceSkipCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_resource_read_callback_t] for more documentation.
#[derive(Clone)]
pub struct ResourceReadCallback(RefGuard<_cef_resource_read_callback_t>);
impl ResourceReadCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceReadCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceReadCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceReadCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_resource_read_callback_t).as_wrapper()
        }
    }
}
pub trait WrapResourceReadCallback: ImplResourceReadCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_read_callback_t, Self>);
}
pub trait ImplResourceReadCallback: Clone + Sized + Rc {
    fn cont(&self, bytes_read: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_resource_read_callback_t) {
        impl_cef_resource_read_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_read_callback_t;
}
mod impl_cef_resource_read_callback_t {
    use super::*;
    pub fn init_methods<I: ImplResourceReadCallback>(object: &mut _cef_resource_read_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplResourceReadCallback>(
        self_: *mut _cef_resource_read_callback_t,
        bytes_read: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_bytes_read) = (self_, bytes_read);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_read = arg_bytes_read.as_raw();
        let result = ImplResourceReadCallback::cont(&arg_self_.interface, arg_bytes_read);
    }
}
impl ImplResourceReadCallback for ResourceReadCallback {
    fn cont(&self, bytes_read: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_bytes_read = bytes_read;
                    let arg_self_ = self.as_raw();
                    let arg_bytes_read = arg_bytes_read;
                    let result = f(arg_self_, arg_bytes_read);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_read_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_resource_read_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceReadCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_read_callback_t> for &ResourceReadCallback {
    fn as_raw(self) -> *mut _cef_resource_read_callback_t {
        ImplResourceReadCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_read_callback_t> for &mut ResourceReadCallback {
    fn as_raw(self) -> *mut _cef_resource_read_callback_t {
        ImplResourceReadCallback::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceReadCallback> for *mut _cef_resource_read_callback_t {
    fn as_wrapper(self) -> ResourceReadCallback {
        ResourceReadCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_read_callback_t> for ResourceReadCallback {
    fn into(self) -> *mut _cef_resource_read_callback_t {
        let object = ImplResourceReadCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ResourceReadCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_resource_handler_t] for more documentation.
#[derive(Clone)]
pub struct ResourceHandler(RefGuard<_cef_resource_handler_t>);
impl ResourceHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_resource_handler_t).as_wrapper()
        }
    }
}
pub trait WrapResourceHandler: ImplResourceHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_handler_t, Self>);
}
pub trait ImplResourceHandler: Clone + Sized + Rc {
    fn open(
        &self,
        request: Option<&mut impl ImplRequest>,
        handle_request: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn process_request(
        &self,
        request: Option<&mut impl ImplRequest>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_response_headers(
        &self,
        response: Option<&mut impl ImplResponse>,
        response_length: Option<&mut i64>,
        redirect_url: Option<&mut CefStringUtf16>,
    ) {
    }
    fn skip(
        &self,
        bytes_to_skip: i64,
        bytes_skipped: Option<&mut i64>,
        callback: Option<&mut impl ImplResourceSkipCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn read(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut impl ImplResourceReadCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn read_response(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_resource_handler_t) {
        impl_cef_resource_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_handler_t;
}
mod impl_cef_resource_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceHandler>(object: &mut _cef_resource_handler_t) {
        object.open = Some(open::<I>);
        object.process_request = Some(process_request::<I>);
        object.get_response_headers = Some(get_response_headers::<I>);
        object.skip = Some(skip::<I>);
        object.read = Some(read::<I>);
        object.read_response = Some(read_response::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn open<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        request: *mut _cef_request_t,
        handle_request: *mut ::std::os::raw::c_int,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_request, arg_handle_request, arg_callback) =
            (self_, request, handle_request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_handle_request = if arg_handle_request.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_handle_request,
            ))
        };
        let arg_handle_request = arg_handle_request.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplResourceHandler::open(
            &arg_self_.interface,
            arg_request,
            arg_handle_request,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn process_request<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        request: *mut _cef_request_t,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_request, arg_callback) = (self_, request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result =
            ImplResourceHandler::process_request(&arg_self_.interface, arg_request, arg_callback);
        result.into()
    }
    extern "C" fn get_response_headers<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        response: *mut _cef_response_t,
        response_length: *mut i64,
        redirect_url: *mut _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_response, arg_response_length, arg_redirect_url) =
            (self_, response, response_length, redirect_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let mut arg_response_length = if arg_response_length.is_null() {
            None
        } else {
            Some(WrapParamRef::<i64>::from(arg_response_length))
        };
        let arg_response_length = arg_response_length.as_mut().map(|arg| arg.as_mut());
        let mut arg_redirect_url = if arg_redirect_url.is_null() {
            None
        } else {
            Some(arg_redirect_url.into())
        };
        let arg_redirect_url = arg_redirect_url.as_mut();
        let result = ImplResourceHandler::get_response_headers(
            &arg_self_.interface,
            arg_response,
            arg_response_length,
            arg_redirect_url,
        );
    }
    extern "C" fn skip<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        bytes_to_skip: i64,
        bytes_skipped: *mut i64,
        callback: *mut _cef_resource_skip_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_bytes_to_skip, arg_bytes_skipped, arg_callback) =
            (self_, bytes_to_skip, bytes_skipped, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_to_skip = arg_bytes_to_skip.as_raw();
        let mut arg_bytes_skipped = if arg_bytes_skipped.is_null() {
            None
        } else {
            Some(WrapParamRef::<i64>::from(arg_bytes_skipped))
        };
        let arg_bytes_skipped = arg_bytes_skipped.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| ResourceSkipCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplResourceHandler::skip(
            &arg_self_.interface,
            arg_bytes_to_skip,
            arg_bytes_skipped,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn read<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: *mut _cef_resource_read_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
            (self_, data_out, bytes_to_read, bytes_read, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_data_out = arg_data_out as *mut _;
        let arg_bytes_to_read = arg_bytes_to_read.as_raw();
        let mut arg_bytes_read = if arg_bytes_read.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_bytes_read))
        };
        let arg_bytes_read = arg_bytes_read.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| ResourceReadCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplResourceHandler::read(
            &arg_self_.interface,
            arg_data_out,
            arg_bytes_to_read,
            arg_bytes_read,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn read_response<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
            (self_, data_out, bytes_to_read, bytes_read, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_data_out = arg_data_out as *mut _;
        let arg_bytes_to_read = arg_bytes_to_read.as_raw();
        let mut arg_bytes_read = if arg_bytes_read.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_bytes_read))
        };
        let arg_bytes_read = arg_bytes_read.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplResourceHandler::read_response(
            &arg_self_.interface,
            arg_data_out,
            arg_bytes_to_read,
            arg_bytes_read,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn cancel<I: ImplResourceHandler>(self_: *mut _cef_resource_handler_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResourceHandler::cancel(&arg_self_.interface);
    }
}
impl ImplResourceHandler for ResourceHandler {
    fn open(
        &self,
        request: Option<&mut impl ImplRequest>,
        handle_request: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .open
                .map(|f| {
                    let (arg_request, arg_handle_request, arg_callback) =
                        (request, handle_request, callback);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_handle_request = arg_handle_request
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request, arg_handle_request, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn process_request(
        &self,
        request: Option<&mut impl ImplRequest>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .process_request
                .map(|f| {
                    let (arg_request, arg_callback) = (request, callback);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_response_headers(
        &self,
        response: Option<&mut impl ImplResponse>,
        response_length: Option<&mut i64>,
        redirect_url: Option<&mut CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .get_response_headers
                .map(|f| {
                    let (arg_response, arg_response_length, arg_redirect_url) =
                        (response, response_length, redirect_url);
                    let arg_self_ = self.as_raw();
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response_length = arg_response_length
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_redirect_url = arg_redirect_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_response,
                        arg_response_length,
                        arg_redirect_url,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn skip(
        &self,
        bytes_to_skip: i64,
        bytes_skipped: Option<&mut i64>,
        callback: Option<&mut impl ImplResourceSkipCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .skip
                .map(|f| {
                    let (arg_bytes_to_skip, arg_bytes_skipped, arg_callback) =
                        (bytes_to_skip, bytes_skipped, callback);
                    let arg_self_ = self.as_raw();
                    let arg_bytes_to_skip = arg_bytes_to_skip;
                    let arg_bytes_skipped = arg_bytes_skipped
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplResourceSkipCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_bytes_to_skip,
                        arg_bytes_skipped,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn read(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut impl ImplResourceReadCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
                        (data_out, bytes_to_read, bytes_read, callback);
                    let arg_self_ = self.as_raw();
                    let arg_data_out = arg_data_out as *mut _;
                    let arg_bytes_to_read = arg_bytes_to_read;
                    let arg_bytes_read = arg_bytes_read
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplResourceReadCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_data_out,
                        arg_bytes_to_read,
                        arg_bytes_read,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn read_response(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .read_response
                .map(|f| {
                    let (arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
                        (data_out, bytes_to_read, bytes_read, callback);
                    let arg_self_ = self.as_raw();
                    let arg_data_out = arg_data_out as *mut _;
                    let arg_bytes_to_read = arg_bytes_to_read;
                    let arg_bytes_read = arg_bytes_read
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_data_out,
                        arg_bytes_to_read,
                        arg_bytes_read,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_resource_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_handler_t> for &ResourceHandler {
    fn as_raw(self) -> *mut _cef_resource_handler_t {
        ImplResourceHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_handler_t> for &mut ResourceHandler {
    fn as_raw(self) -> *mut _cef_resource_handler_t {
        ImplResourceHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceHandler> for *mut _cef_resource_handler_t {
    fn as_wrapper(self) -> ResourceHandler {
        ResourceHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_handler_t> for ResourceHandler {
    fn into(self) -> *mut _cef_resource_handler_t {
        let object = ImplResourceHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ResourceHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_response_filter_t] for more documentation.
#[derive(Clone)]
pub struct ResponseFilter(RefGuard<_cef_response_filter_t>);
impl ResponseFilter {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResponseFilter,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResponseFilter>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResponseFilter>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_response_filter_t).as_wrapper()
        }
    }
}
pub trait WrapResponseFilter: ImplResponseFilter {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_response_filter_t, Self>);
}
pub trait ImplResponseFilter: Clone + Sized + Rc {
    fn init_filter(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn filter(
        &self,
        data_in: Option<&mut Vec<u8>>,
        data_in_read: Option<&mut usize>,
        data_out: Option<&mut Vec<u8>>,
        data_out_written: Option<&mut usize>,
    ) -> ResponseFilterStatus {
        Default::default()
    }
    fn init_methods(object: &mut _cef_response_filter_t) {
        impl_cef_response_filter_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_response_filter_t;
}
mod impl_cef_response_filter_t {
    use super::*;
    pub fn init_methods<I: ImplResponseFilter>(object: &mut _cef_response_filter_t) {
        object.init_filter = Some(init_filter::<I>);
        object.filter = Some(filter::<I>);
    }
    extern "C" fn init_filter<I: ImplResponseFilter>(
        self_: *mut _cef_response_filter_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplResponseFilter::init_filter(&arg_self_.interface);
        result.into()
    }
    extern "C" fn filter<I: ImplResponseFilter>(
        self_: *mut _cef_response_filter_t,
        data_in: *mut ::std::os::raw::c_void,
        data_in_size: usize,
        data_in_read: *mut usize,
        data_out: *mut ::std::os::raw::c_void,
        data_out_size: usize,
        data_out_written: *mut usize,
    ) -> cef_response_filter_status_t {
        let (
            arg_self_,
            arg_data_in,
            arg_data_in_size,
            arg_data_in_read,
            arg_data_out,
            arg_data_out_size,
            arg_data_out_written,
        ) = (
            self_,
            data_in,
            data_in_size,
            data_in_read,
            data_out,
            data_out_size,
            data_out_written,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let out_data_in = (!arg_data_in.is_null() && arg_data_in_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_data_in as *mut _, arg_data_in_size)
        });
        let mut vec_data_in = out_data_in.as_ref().map(|arg| arg.to_vec());
        let arg_data_in = vec_data_in.as_mut();
        let mut arg_data_in_read = if arg_data_in_read.is_null() {
            None
        } else {
            Some(WrapParamRef::<usize>::from(arg_data_in_read))
        };
        let arg_data_in_read = arg_data_in_read.as_mut().map(|arg| arg.as_mut());
        let out_data_out = (!arg_data_out.is_null() && arg_data_out_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_data_out as *mut _, arg_data_out_size)
        });
        let mut vec_data_out = out_data_out.as_ref().map(|arg| arg.to_vec());
        let arg_data_out = vec_data_out.as_mut();
        let mut arg_data_out_written = if arg_data_out_written.is_null() {
            None
        } else {
            Some(WrapParamRef::<usize>::from(arg_data_out_written))
        };
        let arg_data_out_written = arg_data_out_written.as_mut().map(|arg| arg.as_mut());
        let result = ImplResponseFilter::filter(
            &arg_self_.interface,
            arg_data_in,
            arg_data_in_read,
            arg_data_out,
            arg_data_out_written,
        );
        if let (Some(out_data_in), Some(vec_data_in)) = (out_data_in, vec_data_in.as_mut()) {
            let size = vec_data_in.len().min(out_data_in.len());
            out_data_in[..size].copy_from_slice(&vec_data_in[..size]);
        }
        if let (Some(out_data_out), Some(vec_data_out)) = (out_data_out, vec_data_out.as_mut()) {
            let size = vec_data_out.len().min(out_data_out.len());
            out_data_out[..size].copy_from_slice(&vec_data_out[..size]);
        }
        result.into()
    }
}
impl ImplResponseFilter for ResponseFilter {
    fn init_filter(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .init_filter
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn filter(
        &self,
        data_in: Option<&mut Vec<u8>>,
        data_in_read: Option<&mut usize>,
        data_out: Option<&mut Vec<u8>>,
        data_out_written: Option<&mut usize>,
    ) -> ResponseFilterStatus {
        unsafe {
            self.0
                .filter
                .map(|f| {
                    let (arg_data_in, arg_data_in_read, arg_data_out, arg_data_out_written) =
                        (data_in, data_in_read, data_out, data_out_written);
                    let arg_self_ = self.as_raw();
                    let arg_data_in_size = arg_data_in
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let mut out_data_in = arg_data_in;
                    let arg_data_in = out_data_in
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_in_read = arg_data_in_read
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_out_size = arg_data_out
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let mut out_data_out = arg_data_out;
                    let arg_data_out = out_data_out
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_out_written = arg_data_out_written
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_data_in,
                        arg_data_in_size,
                        arg_data_in_read,
                        arg_data_out,
                        arg_data_out_size,
                        arg_data_out_written,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_response_filter_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_response_filter_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResponseFilter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_response_filter_t> for &ResponseFilter {
    fn as_raw(self) -> *mut _cef_response_filter_t {
        ImplResponseFilter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_response_filter_t> for &mut ResponseFilter {
    fn as_raw(self) -> *mut _cef_response_filter_t {
        ImplResponseFilter::get_raw(self)
    }
}
impl ConvertReturnValue<ResponseFilter> for *mut _cef_response_filter_t {
    fn as_wrapper(self) -> ResponseFilter {
        ResponseFilter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_response_filter_t> for ResponseFilter {
    fn into(self) -> *mut _cef_response_filter_t {
        let object = ImplResponseFilter::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ResponseFilter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_resource_request_handler_t] for more documentation.
#[derive(Clone)]
pub struct ResourceRequestHandler(RefGuard<_cef_resource_request_handler_t>);
impl ResourceRequestHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceRequestHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceRequestHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceRequestHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_resource_request_handler_t).as_wrapper()
        }
    }
}
pub trait WrapResourceRequestHandler: ImplResourceRequestHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_request_handler_t, Self>);
}
pub trait ImplResourceRequestHandler: Clone + Sized + Rc {
    fn get_cookie_access_filter(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
    ) -> Option<CookieAccessFilter> {
        Default::default()
    }
    fn on_before_resource_load(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ReturnValue {
        Default::default()
    }
    fn get_resource_handler(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
    ) -> Option<ResourceHandler> {
        Default::default()
    }
    fn on_resource_redirect(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
        new_url: Option<&mut CefStringUtf16>,
    ) {
    }
    fn on_resource_response(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_resource_response_filter(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
    ) -> Option<ResponseFilter> {
        Default::default()
    }
    fn on_resource_load_complete(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
        status: UrlrequestStatus,
        received_content_length: i64,
    ) {
    }
    fn on_protocol_execution(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        allow_os_execution: Option<&mut ::std::os::raw::c_int>,
    ) {
    }
    fn init_methods(object: &mut _cef_resource_request_handler_t) {
        impl_cef_resource_request_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_request_handler_t;
}
mod impl_cef_resource_request_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceRequestHandler>(
        object: &mut _cef_resource_request_handler_t,
    ) {
        object.get_cookie_access_filter = Some(get_cookie_access_filter::<I>);
        object.on_before_resource_load = Some(on_before_resource_load::<I>);
        object.get_resource_handler = Some(get_resource_handler::<I>);
        object.on_resource_redirect = Some(on_resource_redirect::<I>);
        object.on_resource_response = Some(on_resource_response::<I>);
        object.get_resource_response_filter = Some(get_resource_response_filter::<I>);
        object.on_resource_load_complete = Some(on_resource_load_complete::<I>);
        object.on_protocol_execution = Some(on_protocol_execution::<I>);
    }
    extern "C" fn get_cookie_access_filter<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_cookie_access_filter_t {
        let (arg_self_, arg_browser, arg_frame, arg_request) = (self_, browser, frame, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplResourceRequestHandler::get_cookie_access_filter(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_before_resource_load<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        callback: *mut _cef_callback_t,
    ) -> cef_return_value_t {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_callback) =
            (self_, browser, frame, request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplResourceRequestHandler::on_before_resource_load(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn get_resource_handler<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_resource_handler_t {
        let (arg_self_, arg_browser, arg_frame, arg_request) = (self_, browser, frame, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplResourceRequestHandler::get_resource_handler(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_resource_redirect<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        new_url: *mut _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response, arg_new_url) =
            (self_, browser, frame, request, response, new_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let mut arg_new_url = if arg_new_url.is_null() {
            None
        } else {
            Some(arg_new_url.into())
        };
        let arg_new_url = arg_new_url.as_mut();
        let result = ImplResourceRequestHandler::on_resource_redirect(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_new_url,
        );
    }
    extern "C" fn on_resource_response<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response) =
            (self_, browser, frame, request, response);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let result = ImplResourceRequestHandler::on_resource_response(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
        );
        result.into()
    }
    extern "C" fn get_resource_response_filter<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
    ) -> *mut _cef_response_filter_t {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response) =
            (self_, browser, frame, request, response);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let result = ImplResourceRequestHandler::get_resource_response_filter(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_resource_load_complete<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        status: cef_urlrequest_status_t,
        received_content_length: i64,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_status,
            arg_received_content_length,
        ) = (
            self_,
            browser,
            frame,
            request,
            response,
            status,
            received_content_length,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let arg_status = arg_status.as_raw();
        let arg_received_content_length = arg_received_content_length.as_raw();
        let result = ImplResourceRequestHandler::on_resource_load_complete(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_status,
            arg_received_content_length,
        );
    }
    extern "C" fn on_protocol_execution<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        allow_os_execution: *mut ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_allow_os_execution) =
            (self_, browser, frame, request, allow_os_execution);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_allow_os_execution = if arg_allow_os_execution.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_allow_os_execution,
            ))
        };
        let arg_allow_os_execution = arg_allow_os_execution.as_mut().map(|arg| arg.as_mut());
        let result = ImplResourceRequestHandler::on_protocol_execution(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_allow_os_execution,
        );
    }
}
impl ImplResourceRequestHandler for ResourceRequestHandler {
    fn get_cookie_access_filter(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
    ) -> Option<CookieAccessFilter> {
        unsafe {
            self.0
                .get_cookie_access_filter
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request) = (browser, frame, request);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_before_resource_load(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ReturnValue {
        unsafe {
            self.0
                .on_before_resource_load
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_callback) =
                        (browser, frame, request, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_resource_handler(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
    ) -> Option<ResourceHandler> {
        unsafe {
            self.0
                .get_resource_handler
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request) = (browser, frame, request);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_resource_redirect(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
        new_url: Option<&mut CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .on_resource_redirect
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response, arg_new_url) =
                        (browser, frame, request, response, new_url);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_new_url = arg_new_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_new_url,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_resource_response(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_resource_response
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response) =
                        (browser, frame, request, response);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_response);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_resource_response_filter(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
    ) -> Option<ResponseFilter> {
        unsafe {
            self.0
                .get_resource_response_filter
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response) =
                        (browser, frame, request, response);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_response);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_resource_load_complete(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
        status: UrlrequestStatus,
        received_content_length: i64,
    ) {
        unsafe {
            self.0
                .on_resource_load_complete
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_status,
                        arg_received_content_length,
                    ) = (
                        browser,
                        frame,
                        request,
                        response,
                        status,
                        received_content_length,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_status = arg_status.as_raw();
                    let arg_received_content_length = arg_received_content_length;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_status,
                        arg_received_content_length,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_protocol_execution(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        allow_os_execution: Option<&mut ::std::os::raw::c_int>,
    ) {
        unsafe {
            self.0
                .on_protocol_execution
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_allow_os_execution) =
                        (browser, frame, request, allow_os_execution);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_allow_os_execution = arg_allow_os_execution
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_allow_os_execution,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_request_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_resource_request_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceRequestHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_request_handler_t> for &ResourceRequestHandler {
    fn as_raw(self) -> *mut _cef_resource_request_handler_t {
        ImplResourceRequestHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_request_handler_t> for &mut ResourceRequestHandler {
    fn as_raw(self) -> *mut _cef_resource_request_handler_t {
        ImplResourceRequestHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceRequestHandler> for *mut _cef_resource_request_handler_t {
    fn as_wrapper(self) -> ResourceRequestHandler {
        ResourceRequestHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_request_handler_t> for ResourceRequestHandler {
    fn into(self) -> *mut _cef_resource_request_handler_t {
        let object = ImplResourceRequestHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ResourceRequestHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_cookie_access_filter_t] for more documentation.
#[derive(Clone)]
pub struct CookieAccessFilter(RefGuard<_cef_cookie_access_filter_t>);
impl CookieAccessFilter {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCookieAccessFilter,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCookieAccessFilter>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCookieAccessFilter>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_cookie_access_filter_t).as_wrapper()
        }
    }
}
pub trait WrapCookieAccessFilter: ImplCookieAccessFilter {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_cookie_access_filter_t, Self>);
}
pub trait ImplCookieAccessFilter: Clone + Sized + Rc {
    fn can_send_cookie(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn can_save_cookie(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_cookie_access_filter_t) {
        impl_cef_cookie_access_filter_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_cookie_access_filter_t;
}
mod impl_cef_cookie_access_filter_t {
    use super::*;
    pub fn init_methods<I: ImplCookieAccessFilter>(object: &mut _cef_cookie_access_filter_t) {
        object.can_send_cookie = Some(can_send_cookie::<I>);
        object.can_save_cookie = Some(can_save_cookie::<I>);
    }
    extern "C" fn can_send_cookie<I: ImplCookieAccessFilter>(
        self_: *mut _cef_cookie_access_filter_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        cookie: *const _cef_cookie_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_cookie) =
            (self_, browser, frame, request, cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_cookie = if arg_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<Cookie>::from(arg_cookie))
        };
        let arg_cookie = arg_cookie.as_ref().map(|arg| arg.as_ref());
        let result = ImplCookieAccessFilter::can_send_cookie(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_cookie,
        );
        result.into()
    }
    extern "C" fn can_save_cookie<I: ImplCookieAccessFilter>(
        self_: *mut _cef_cookie_access_filter_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        cookie: *const _cef_cookie_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response, arg_cookie) =
            (self_, browser, frame, request, response, cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let arg_cookie = if arg_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<Cookie>::from(arg_cookie))
        };
        let arg_cookie = arg_cookie.as_ref().map(|arg| arg.as_ref());
        let result = ImplCookieAccessFilter::can_save_cookie(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_cookie,
        );
        result.into()
    }
}
impl ImplCookieAccessFilter for CookieAccessFilter {
    fn can_send_cookie(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_send_cookie
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_cookie) =
                        (browser, frame, request, cookie);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_cookie);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn can_save_cookie(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        response: Option<&mut impl ImplResponse>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_save_cookie
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response, arg_cookie) =
                        (browser, frame, request, response, cookie);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_cookie,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_cookie_access_filter_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_cookie_access_filter_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieAccessFilter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_access_filter_t> for &CookieAccessFilter {
    fn as_raw(self) -> *mut _cef_cookie_access_filter_t {
        ImplCookieAccessFilter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_cookie_access_filter_t> for &mut CookieAccessFilter {
    fn as_raw(self) -> *mut _cef_cookie_access_filter_t {
        ImplCookieAccessFilter::get_raw(self)
    }
}
impl ConvertReturnValue<CookieAccessFilter> for *mut _cef_cookie_access_filter_t {
    fn as_wrapper(self) -> CookieAccessFilter {
        CookieAccessFilter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_cookie_access_filter_t> for CookieAccessFilter {
    fn into(self) -> *mut _cef_cookie_access_filter_t {
        let object = ImplCookieAccessFilter::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for CookieAccessFilter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_sslinfo_t] for more documentation.
#[derive(Clone)]
pub struct Sslinfo(RefGuard<_cef_sslinfo_t>);
impl Sslinfo {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSslinfo,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSslinfo>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSslinfo>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_sslinfo_t).as_wrapper()
        }
    }
}
pub trait WrapSslinfo: ImplSslinfo {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_sslinfo_t, Self>);
}
pub trait ImplSslinfo: Clone + Sized + Rc {
    fn get_cert_status(&self) -> CertStatus {
        Default::default()
    }
    fn get_x509certificate(&self) -> Option<X509certificate> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_sslinfo_t) {
        impl_cef_sslinfo_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_sslinfo_t;
}
mod impl_cef_sslinfo_t {
    use super::*;
    pub fn init_methods<I: ImplSslinfo>(object: &mut _cef_sslinfo_t) {
        object.get_cert_status = Some(get_cert_status::<I>);
        object.get_x509certificate = Some(get_x509certificate::<I>);
    }
    extern "C" fn get_cert_status<I: ImplSslinfo>(self_: *mut _cef_sslinfo_t) -> cef_cert_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSslinfo::get_cert_status(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_x509certificate<I: ImplSslinfo>(
        self_: *mut _cef_sslinfo_t,
    ) -> *mut _cef_x509certificate_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplSslinfo::get_x509certificate(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplSslinfo for Sslinfo {
    fn get_cert_status(&self) -> CertStatus {
        unsafe {
            self.0
                .get_cert_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_x509certificate(&self) -> Option<X509certificate> {
        unsafe {
            self.0
                .get_x509certificate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_sslinfo_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_sslinfo_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Sslinfo {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_sslinfo_t> for &Sslinfo {
    fn as_raw(self) -> *mut _cef_sslinfo_t {
        ImplSslinfo::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_sslinfo_t> for &mut Sslinfo {
    fn as_raw(self) -> *mut _cef_sslinfo_t {
        ImplSslinfo::get_raw(self)
    }
}
impl ConvertReturnValue<Sslinfo> for *mut _cef_sslinfo_t {
    fn as_wrapper(self) -> Sslinfo {
        Sslinfo(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_sslinfo_t> for Sslinfo {
    fn into(self) -> *mut _cef_sslinfo_t {
        let object = ImplSslinfo::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Sslinfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_unresponsive_process_callback_t] for more documentation.
#[derive(Clone)]
pub struct UnresponsiveProcessCallback(RefGuard<_cef_unresponsive_process_callback_t>);
impl UnresponsiveProcessCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapUnresponsiveProcessCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplUnresponsiveProcessCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapUnresponsiveProcessCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_unresponsive_process_callback_t).as_wrapper()
        }
    }
}
pub trait WrapUnresponsiveProcessCallback: ImplUnresponsiveProcessCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_unresponsive_process_callback_t, Self>);
}
pub trait ImplUnresponsiveProcessCallback: Clone + Sized + Rc {
    fn wait(&self) {}
    fn terminate(&self) {}
    fn init_methods(object: &mut _cef_unresponsive_process_callback_t) {
        impl_cef_unresponsive_process_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_unresponsive_process_callback_t;
}
mod impl_cef_unresponsive_process_callback_t {
    use super::*;
    pub fn init_methods<I: ImplUnresponsiveProcessCallback>(
        object: &mut _cef_unresponsive_process_callback_t,
    ) {
        object.wait = Some(wait::<I>);
        object.terminate = Some(terminate::<I>);
    }
    extern "C" fn wait<I: ImplUnresponsiveProcessCallback>(
        self_: *mut _cef_unresponsive_process_callback_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUnresponsiveProcessCallback::wait(&arg_self_.interface);
    }
    extern "C" fn terminate<I: ImplUnresponsiveProcessCallback>(
        self_: *mut _cef_unresponsive_process_callback_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUnresponsiveProcessCallback::terminate(&arg_self_.interface);
    }
}
impl ImplUnresponsiveProcessCallback for UnresponsiveProcessCallback {
    fn wait(&self) {
        unsafe {
            self.0
                .wait
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn terminate(&self) {
        unsafe {
            self.0
                .terminate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_unresponsive_process_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_unresponsive_process_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for UnresponsiveProcessCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_unresponsive_process_callback_t> for &UnresponsiveProcessCallback {
    fn as_raw(self) -> *mut _cef_unresponsive_process_callback_t {
        ImplUnresponsiveProcessCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_unresponsive_process_callback_t> for &mut UnresponsiveProcessCallback {
    fn as_raw(self) -> *mut _cef_unresponsive_process_callback_t {
        ImplUnresponsiveProcessCallback::get_raw(self)
    }
}
impl ConvertReturnValue<UnresponsiveProcessCallback> for *mut _cef_unresponsive_process_callback_t {
    fn as_wrapper(self) -> UnresponsiveProcessCallback {
        UnresponsiveProcessCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_unresponsive_process_callback_t> for UnresponsiveProcessCallback {
    fn into(self) -> *mut _cef_unresponsive_process_callback_t {
        let object = ImplUnresponsiveProcessCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for UnresponsiveProcessCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_select_client_certificate_callback_t] for more documentation.
#[derive(Clone)]
pub struct SelectClientCertificateCallback(RefGuard<_cef_select_client_certificate_callback_t>);
impl SelectClientCertificateCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSelectClientCertificateCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSelectClientCertificateCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSelectClientCertificateCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_select_client_certificate_callback_t).as_wrapper()
        }
    }
}
pub trait WrapSelectClientCertificateCallback: ImplSelectClientCertificateCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_select_client_certificate_callback_t, Self>);
}
pub trait ImplSelectClientCertificateCallback: Clone + Sized + Rc {
    fn select(&self, cert: Option<&mut impl ImplX509certificate>) {}
    fn init_methods(object: &mut _cef_select_client_certificate_callback_t) {
        impl_cef_select_client_certificate_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_select_client_certificate_callback_t;
}
mod impl_cef_select_client_certificate_callback_t {
    use super::*;
    pub fn init_methods<I: ImplSelectClientCertificateCallback>(
        object: &mut _cef_select_client_certificate_callback_t,
    ) {
        object.select = Some(select::<I>);
    }
    extern "C" fn select<I: ImplSelectClientCertificateCallback>(
        self_: *mut _cef_select_client_certificate_callback_t,
        cert: *mut _cef_x509certificate_t,
    ) {
        let (arg_self_, arg_cert) = (self_, cert);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_cert = unsafe { arg_cert.as_mut() }
            .map(|arg| X509certificate(unsafe { RefGuard::from_raw(arg) }));
        let arg_cert = arg_cert.as_mut();
        let result = ImplSelectClientCertificateCallback::select(&arg_self_.interface, arg_cert);
    }
}
impl ImplSelectClientCertificateCallback for SelectClientCertificateCallback {
    fn select(&self, cert: Option<&mut impl ImplX509certificate>) {
        unsafe {
            self.0
                .select
                .map(|f| {
                    let arg_cert = cert;
                    let arg_self_ = self.as_raw();
                    let arg_cert = arg_cert
                        .map(|arg| {
                            arg.add_ref();
                            ImplX509certificate::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_cert);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_select_client_certificate_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_select_client_certificate_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SelectClientCertificateCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_select_client_certificate_callback_t>
    for &SelectClientCertificateCallback
{
    fn as_raw(self) -> *mut _cef_select_client_certificate_callback_t {
        ImplSelectClientCertificateCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_select_client_certificate_callback_t>
    for &mut SelectClientCertificateCallback
{
    fn as_raw(self) -> *mut _cef_select_client_certificate_callback_t {
        ImplSelectClientCertificateCallback::get_raw(self)
    }
}
impl ConvertReturnValue<SelectClientCertificateCallback>
    for *mut _cef_select_client_certificate_callback_t
{
    fn as_wrapper(self) -> SelectClientCertificateCallback {
        SelectClientCertificateCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_select_client_certificate_callback_t> for SelectClientCertificateCallback {
    fn into(self) -> *mut _cef_select_client_certificate_callback_t {
        let object = ImplSelectClientCertificateCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for SelectClientCertificateCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_request_handler_t] for more documentation.
#[derive(Clone)]
pub struct RequestHandler(RefGuard<_cef_request_handler_t>);
impl RequestHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRequestHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRequestHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRequestHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_request_handler_t).as_wrapper()
        }
    }
}
pub trait WrapRequestHandler: ImplRequestHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_request_handler_t, Self>);
}
pub trait ImplRequestHandler: Clone + Sized + Rc {
    fn on_before_browse(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_open_urlfrom_tab(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        target_url: Option<&CefStringUtf16>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_resource_request_handler(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefStringUtf16>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        Default::default()
    }
    fn get_auth_credentials(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        origin_url: Option<&CefStringUtf16>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefStringUtf16>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefStringUtf16>,
        scheme: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplAuthCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_certificate_error(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        cert_error: Errorcode,
        request_url: Option<&CefStringUtf16>,
        ssl_info: Option<&mut impl ImplSslinfo>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_select_client_certificate(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefStringUtf16>,
        port: ::std::os::raw::c_int,
        certificates: Option<&[Option<impl ImplX509certificate>]>,
        callback: Option<&mut impl ImplSelectClientCertificateCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_render_view_ready(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn on_render_process_unresponsive(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        callback: Option<&mut impl ImplUnresponsiveProcessCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_render_process_responsive(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn on_render_process_terminated(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        status: TerminationStatus,
        error_code: ::std::os::raw::c_int,
        error_string: Option<&CefStringUtf16>,
    ) {
    }
    fn on_document_available_in_main_frame(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn init_methods(object: &mut _cef_request_handler_t) {
        impl_cef_request_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_request_handler_t;
}
mod impl_cef_request_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRequestHandler>(object: &mut _cef_request_handler_t) {
        object.on_before_browse = Some(on_before_browse::<I>);
        object.on_open_urlfrom_tab = Some(on_open_urlfrom_tab::<I>);
        object.get_resource_request_handler = Some(get_resource_request_handler::<I>);
        object.get_auth_credentials = Some(get_auth_credentials::<I>);
        object.on_certificate_error = Some(on_certificate_error::<I>);
        object.on_select_client_certificate = Some(on_select_client_certificate::<I>);
        object.on_render_view_ready = Some(on_render_view_ready::<I>);
        object.on_render_process_unresponsive = Some(on_render_process_unresponsive::<I>);
        object.on_render_process_responsive = Some(on_render_process_responsive::<I>);
        object.on_render_process_terminated = Some(on_render_process_terminated::<I>);
        object.on_document_available_in_main_frame = Some(on_document_available_in_main_frame::<I>);
    }
    extern "C" fn on_before_browse<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_user_gesture, arg_is_redirect) =
            (self_, browser, frame, request, user_gesture, is_redirect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_user_gesture = arg_user_gesture.as_raw();
        let arg_is_redirect = arg_is_redirect.as_raw();
        let result = ImplRequestHandler::on_before_browse(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_user_gesture,
            arg_is_redirect,
        );
        result.into()
    }
    extern "C" fn on_open_urlfrom_tab<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        target_url: *const _cef_string_utf16_t,
        target_disposition: cef_window_open_disposition_t,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_target_url,
            arg_target_disposition,
            arg_user_gesture,
        ) = (
            self_,
            browser,
            frame,
            target_url,
            target_disposition,
            user_gesture,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_target_url = if arg_target_url.is_null() {
            None
        } else {
            Some(arg_target_url.into())
        };
        let arg_target_url = arg_target_url.as_ref();
        let arg_target_disposition = arg_target_disposition.as_raw();
        let arg_user_gesture = arg_user_gesture.as_raw();
        let result = ImplRequestHandler::on_open_urlfrom_tab(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_target_url,
            arg_target_disposition,
            arg_user_gesture,
        );
        result.into()
    }
    extern "C" fn get_resource_request_handler<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: *const _cef_string_utf16_t,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_resource_request_handler_t {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        ) = (
            self_,
            browser,
            frame,
            request,
            is_navigation,
            is_download,
            request_initiator,
            disable_default_handling,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_is_navigation = arg_is_navigation.as_raw();
        let arg_is_download = arg_is_download.as_raw();
        let arg_request_initiator = if arg_request_initiator.is_null() {
            None
        } else {
            Some(arg_request_initiator.into())
        };
        let arg_request_initiator = arg_request_initiator.as_ref();
        let mut arg_disable_default_handling = if arg_disable_default_handling.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_disable_default_handling,
            ))
        };
        let arg_disable_default_handling = arg_disable_default_handling
            .as_mut()
            .map(|arg| arg.as_mut());
        let result = ImplRequestHandler::get_resource_request_handler(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_auth_credentials<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        origin_url: *const _cef_string_utf16_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const _cef_string_utf16_t,
        port: ::std::os::raw::c_int,
        realm: *const _cef_string_utf16_t,
        scheme: *const _cef_string_utf16_t,
        callback: *mut _cef_auth_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_origin_url,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_realm,
            arg_scheme,
            arg_callback,
        ) = (
            self_, browser, origin_url, is_proxy, host, port, realm, scheme, callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_origin_url = if arg_origin_url.is_null() {
            None
        } else {
            Some(arg_origin_url.into())
        };
        let arg_origin_url = arg_origin_url.as_ref();
        let arg_is_proxy = arg_is_proxy.as_raw();
        let arg_host = if arg_host.is_null() {
            None
        } else {
            Some(arg_host.into())
        };
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.as_raw();
        let arg_realm = if arg_realm.is_null() {
            None
        } else {
            Some(arg_realm.into())
        };
        let arg_realm = arg_realm.as_ref();
        let arg_scheme = if arg_scheme.is_null() {
            None
        } else {
            Some(arg_scheme.into())
        };
        let arg_scheme = arg_scheme.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| AuthCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplRequestHandler::get_auth_credentials(
            &arg_self_.interface,
            arg_browser,
            arg_origin_url,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_realm,
            arg_scheme,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_certificate_error<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        cert_error: cef_errorcode_t,
        request_url: *const _cef_string_utf16_t,
        ssl_info: *mut _cef_sslinfo_t,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_cert_error, arg_request_url, arg_ssl_info, arg_callback) =
            (self_, browser, cert_error, request_url, ssl_info, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_cert_error = arg_cert_error.as_raw();
        let arg_request_url = if arg_request_url.is_null() {
            None
        } else {
            Some(arg_request_url.into())
        };
        let arg_request_url = arg_request_url.as_ref();
        let mut arg_ssl_info =
            unsafe { arg_ssl_info.as_mut() }.map(|arg| Sslinfo(unsafe { RefGuard::from_raw(arg) }));
        let arg_ssl_info = arg_ssl_info.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplRequestHandler::on_certificate_error(
            &arg_self_.interface,
            arg_browser,
            arg_cert_error,
            arg_request_url,
            arg_ssl_info,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_select_client_certificate<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const _cef_string_utf16_t,
        port: ::std::os::raw::c_int,
        certificates_count: usize,
        certificates: *const *mut _cef_x509certificate_t,
        callback: *mut _cef_select_client_certificate_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_certificates_count,
            arg_certificates,
            arg_callback,
        ) = (
            self_,
            browser,
            is_proxy,
            host,
            port,
            certificates_count,
            certificates,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_is_proxy = arg_is_proxy.as_raw();
        let arg_host = if arg_host.is_null() {
            None
        } else {
            Some(arg_host.into())
        };
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.as_raw();
        let vec_certificates = unsafe { arg_certificates.as_ref() }.map(|arg| {
            let arg = unsafe {
                std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_certificates_count)
            };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(X509certificate(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_certificates = vec_certificates.as_ref().map(|arg| arg.as_slice());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| SelectClientCertificateCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplRequestHandler::on_select_client_certificate(
            &arg_self_.interface,
            arg_browser,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_certificates,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_render_view_ready<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplRequestHandler::on_render_view_ready(&arg_self_.interface, arg_browser);
    }
    extern "C" fn on_render_process_unresponsive<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        callback: *mut _cef_unresponsive_process_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_callback) = (self_, browser, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| UnresponsiveProcessCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplRequestHandler::on_render_process_unresponsive(
            &arg_self_.interface,
            arg_browser,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn on_render_process_responsive<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result =
            ImplRequestHandler::on_render_process_responsive(&arg_self_.interface, arg_browser);
    }
    extern "C" fn on_render_process_terminated<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        status: cef_termination_status_t,
        error_code: ::std::os::raw::c_int,
        error_string: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_status, arg_error_code, arg_error_string) =
            (self_, browser, status, error_code, error_string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_status = arg_status.as_raw();
        let arg_error_code = arg_error_code.as_raw();
        let arg_error_string = if arg_error_string.is_null() {
            None
        } else {
            Some(arg_error_string.into())
        };
        let arg_error_string = arg_error_string.as_ref();
        let result = ImplRequestHandler::on_render_process_terminated(
            &arg_self_.interface,
            arg_browser,
            arg_status,
            arg_error_code,
            arg_error_string,
        );
    }
    extern "C" fn on_document_available_in_main_frame<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplRequestHandler::on_document_available_in_main_frame(
            &arg_self_.interface,
            arg_browser,
        );
    }
}
impl ImplRequestHandler for RequestHandler {
    fn on_before_browse(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_browse
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_user_gesture, arg_is_redirect) =
                        (browser, frame, request, user_gesture, is_redirect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_user_gesture = arg_user_gesture;
                    let arg_is_redirect = arg_is_redirect;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_user_gesture,
                        arg_is_redirect,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_open_urlfrom_tab(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        target_url: Option<&CefStringUtf16>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_open_urlfrom_tab
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_target_url,
                        arg_target_disposition,
                        arg_user_gesture,
                    ) = (browser, frame, target_url, target_disposition, user_gesture);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_target_url = arg_target_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_target_disposition = arg_target_disposition.as_raw();
                    let arg_user_gesture = arg_user_gesture;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_target_url,
                        arg_target_disposition,
                        arg_user_gesture,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_resource_request_handler(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefStringUtf16>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        unsafe {
            self.0
                .get_resource_request_handler
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    ) = (
                        browser,
                        frame,
                        request,
                        is_navigation,
                        is_download,
                        request_initiator,
                        disable_default_handling,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_navigation = arg_is_navigation;
                    let arg_is_download = arg_is_download;
                    let arg_request_initiator = arg_request_initiator
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_disable_default_handling = arg_disable_default_handling
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_auth_credentials(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        origin_url: Option<&CefStringUtf16>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefStringUtf16>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefStringUtf16>,
        scheme: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplAuthCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_auth_credentials
                .map(|f| {
                    let (
                        arg_browser,
                        arg_origin_url,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    ) = (
                        browser, origin_url, is_proxy, host, port, realm, scheme, callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_origin_url = arg_origin_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_is_proxy = arg_is_proxy;
                    let arg_host = arg_host.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_port = arg_port;
                    let arg_realm = arg_realm
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_scheme = arg_scheme
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplAuthCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_origin_url,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_certificate_error(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        cert_error: Errorcode,
        request_url: Option<&CefStringUtf16>,
        ssl_info: Option<&mut impl ImplSslinfo>,
        callback: Option<&mut impl ImplCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_certificate_error
                .map(|f| {
                    let (arg_browser, arg_cert_error, arg_request_url, arg_ssl_info, arg_callback) =
                        (browser, cert_error, request_url, ssl_info, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cert_error = arg_cert_error.as_raw();
                    let arg_request_url = arg_request_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_ssl_info = arg_ssl_info
                        .map(|arg| {
                            arg.add_ref();
                            ImplSslinfo::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_cert_error,
                        arg_request_url,
                        arg_ssl_info,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_select_client_certificate(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefStringUtf16>,
        port: ::std::os::raw::c_int,
        certificates: Option<&[Option<impl ImplX509certificate>]>,
        callback: Option<&mut impl ImplSelectClientCertificateCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_select_client_certificate
                .map(|f| {
                    let (
                        arg_browser,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_certificates,
                        arg_callback,
                    ) = (browser, is_proxy, host, port, certificates, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_proxy = arg_is_proxy;
                    let arg_host = arg_host.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_port = arg_port;
                    let arg_certificates_count = arg_certificates
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_certificates = arg_certificates
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_certificates = if vec_certificates.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_certificates.as_ptr()
                    };
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplSelectClientCertificateCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_certificates_count,
                        arg_certificates,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_render_view_ready(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_render_view_ready
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_render_process_unresponsive(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        callback: Option<&mut impl ImplUnresponsiveProcessCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_render_process_unresponsive
                .map(|f| {
                    let (arg_browser, arg_callback) = (browser, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplUnresponsiveProcessCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_render_process_responsive(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_render_process_responsive
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_render_process_terminated(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        status: TerminationStatus,
        error_code: ::std::os::raw::c_int,
        error_string: Option<&CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .on_render_process_terminated
                .map(|f| {
                    let (arg_browser, arg_status, arg_error_code, arg_error_string) =
                        (browser, status, error_code, error_string);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_status = arg_status.as_raw();
                    let arg_error_code = arg_error_code;
                    let arg_error_string = arg_error_string
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_status,
                        arg_error_code,
                        arg_error_string,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_document_available_in_main_frame(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_document_available_in_main_frame
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_request_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_request_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_handler_t> for &RequestHandler {
    fn as_raw(self) -> *mut _cef_request_handler_t {
        ImplRequestHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_handler_t> for &mut RequestHandler {
    fn as_raw(self) -> *mut _cef_request_handler_t {
        ImplRequestHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RequestHandler> for *mut _cef_request_handler_t {
    fn as_wrapper(self) -> RequestHandler {
        RequestHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_handler_t> for RequestHandler {
    fn into(self) -> *mut _cef_request_handler_t {
        let object = ImplRequestHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RequestHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_client_t] for more documentation.
#[derive(Clone)]
pub struct Client(RefGuard<_cef_client_t>);
impl Client {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapClient,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplClient>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapClient>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_client_t).as_wrapper()
        }
    }
}
pub trait WrapClient: ImplClient {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_client_t, Self>);
}
pub trait ImplClient: Clone + Sized + Rc {
    fn get_audio_handler(&self) -> Option<AudioHandler> {
        Default::default()
    }
    fn get_command_handler(&self) -> Option<CommandHandler> {
        Default::default()
    }
    fn get_context_menu_handler(&self) -> Option<ContextMenuHandler> {
        Default::default()
    }
    fn get_dialog_handler(&self) -> Option<DialogHandler> {
        Default::default()
    }
    fn get_display_handler(&self) -> Option<DisplayHandler> {
        Default::default()
    }
    fn get_download_handler(&self) -> Option<DownloadHandler> {
        Default::default()
    }
    fn get_drag_handler(&self) -> Option<DragHandler> {
        Default::default()
    }
    fn get_find_handler(&self) -> Option<FindHandler> {
        Default::default()
    }
    fn get_focus_handler(&self) -> Option<FocusHandler> {
        Default::default()
    }
    fn get_frame_handler(&self) -> Option<FrameHandler> {
        Default::default()
    }
    fn get_permission_handler(&self) -> Option<PermissionHandler> {
        Default::default()
    }
    fn get_jsdialog_handler(&self) -> Option<JsdialogHandler> {
        Default::default()
    }
    fn get_keyboard_handler(&self) -> Option<KeyboardHandler> {
        Default::default()
    }
    fn get_life_span_handler(&self) -> Option<LifeSpanHandler> {
        Default::default()
    }
    fn get_load_handler(&self) -> Option<LoadHandler> {
        Default::default()
    }
    fn get_print_handler(&self) -> Option<PrintHandler> {
        Default::default()
    }
    fn get_render_handler(&self) -> Option<RenderHandler> {
        Default::default()
    }
    fn get_request_handler(&self) -> Option<RequestHandler> {
        Default::default()
    }
    fn on_process_message_received(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        source_process: ProcessId,
        message: Option<&mut impl ImplProcessMessage>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_client_t) {
        impl_cef_client_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_client_t;
}
mod impl_cef_client_t {
    use super::*;
    pub fn init_methods<I: ImplClient>(object: &mut _cef_client_t) {
        object.get_audio_handler = Some(get_audio_handler::<I>);
        object.get_command_handler = Some(get_command_handler::<I>);
        object.get_context_menu_handler = Some(get_context_menu_handler::<I>);
        object.get_dialog_handler = Some(get_dialog_handler::<I>);
        object.get_display_handler = Some(get_display_handler::<I>);
        object.get_download_handler = Some(get_download_handler::<I>);
        object.get_drag_handler = Some(get_drag_handler::<I>);
        object.get_find_handler = Some(get_find_handler::<I>);
        object.get_focus_handler = Some(get_focus_handler::<I>);
        object.get_frame_handler = Some(get_frame_handler::<I>);
        object.get_permission_handler = Some(get_permission_handler::<I>);
        object.get_jsdialog_handler = Some(get_jsdialog_handler::<I>);
        object.get_keyboard_handler = Some(get_keyboard_handler::<I>);
        object.get_life_span_handler = Some(get_life_span_handler::<I>);
        object.get_load_handler = Some(get_load_handler::<I>);
        object.get_print_handler = Some(get_print_handler::<I>);
        object.get_render_handler = Some(get_render_handler::<I>);
        object.get_request_handler = Some(get_request_handler::<I>);
        object.on_process_message_received = Some(on_process_message_received::<I>);
    }
    extern "C" fn get_audio_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_audio_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_audio_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_command_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_command_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_command_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_context_menu_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_context_menu_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_context_menu_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_dialog_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_dialog_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_dialog_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_display_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_display_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_display_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_download_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_download_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_download_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_drag_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_drag_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_drag_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_find_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_find_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_find_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_focus_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_focus_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_focus_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_frame_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_frame_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_permission_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_permission_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_permission_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_jsdialog_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_jsdialog_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_jsdialog_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_keyboard_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_keyboard_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_keyboard_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_life_span_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_life_span_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_life_span_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_load_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_load_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_load_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_print_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_print_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_print_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_render_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_render_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_render_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_request_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_request_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::get_request_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_process_message_received<I: ImplClient>(
        self_: *mut _cef_client_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        source_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_source_process, arg_message) =
            (self_, browser, frame, source_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_source_process = arg_source_process.as_raw();
        let mut arg_message = unsafe { arg_message.as_mut() }
            .map(|arg| ProcessMessage(unsafe { RefGuard::from_raw(arg) }));
        let arg_message = arg_message.as_mut();
        let result = ImplClient::on_process_message_received(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_source_process,
            arg_message,
        );
        result.into()
    }
}
impl ImplClient for Client {
    fn get_audio_handler(&self) -> Option<AudioHandler> {
        unsafe {
            self.0
                .get_audio_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_command_handler(&self) -> Option<CommandHandler> {
        unsafe {
            self.0
                .get_command_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_context_menu_handler(&self) -> Option<ContextMenuHandler> {
        unsafe {
            self.0
                .get_context_menu_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_dialog_handler(&self) -> Option<DialogHandler> {
        unsafe {
            self.0
                .get_dialog_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_display_handler(&self) -> Option<DisplayHandler> {
        unsafe {
            self.0
                .get_display_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_download_handler(&self) -> Option<DownloadHandler> {
        unsafe {
            self.0
                .get_download_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_drag_handler(&self) -> Option<DragHandler> {
        unsafe {
            self.0
                .get_drag_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_find_handler(&self) -> Option<FindHandler> {
        unsafe {
            self.0
                .get_find_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_focus_handler(&self) -> Option<FocusHandler> {
        unsafe {
            self.0
                .get_focus_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_handler(&self) -> Option<FrameHandler> {
        unsafe {
            self.0
                .get_frame_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_permission_handler(&self) -> Option<PermissionHandler> {
        unsafe {
            self.0
                .get_permission_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_jsdialog_handler(&self) -> Option<JsdialogHandler> {
        unsafe {
            self.0
                .get_jsdialog_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_keyboard_handler(&self) -> Option<KeyboardHandler> {
        unsafe {
            self.0
                .get_keyboard_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_life_span_handler(&self) -> Option<LifeSpanHandler> {
        unsafe {
            self.0
                .get_life_span_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_load_handler(&self) -> Option<LoadHandler> {
        unsafe {
            self.0
                .get_load_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_print_handler(&self) -> Option<PrintHandler> {
        unsafe {
            self.0
                .get_print_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_render_handler(&self) -> Option<RenderHandler> {
        unsafe {
            self.0
                .get_render_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_request_handler(&self) -> Option<RequestHandler> {
        unsafe {
            self.0
                .get_request_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_process_message_received(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        source_process: ProcessId,
        message: Option<&mut impl ImplProcessMessage>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_process_message_received
                .map(|f| {
                    let (arg_browser, arg_frame, arg_source_process, arg_message) =
                        (browser, frame, source_process, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_source_process = arg_source_process.as_raw();
                    let arg_message = arg_message
                        .map(|arg| {
                            arg.add_ref();
                            ImplProcessMessage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_source_process,
                        arg_message,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_client_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_client_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Client {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_client_t> for &Client {
    fn as_raw(self) -> *mut _cef_client_t {
        ImplClient::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_client_t> for &mut Client {
    fn as_raw(self) -> *mut _cef_client_t {
        ImplClient::get_raw(self)
    }
}
impl ConvertReturnValue<Client> for *mut _cef_client_t {
    fn as_wrapper(self) -> Client {
        Client(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_client_t> for Client {
    fn into(self) -> *mut _cef_client_t {
        let object = ImplClient::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Client {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_command_line_t] for more documentation.
#[derive(Clone)]
pub struct CommandLine(RefGuard<_cef_command_line_t>);
impl CommandLine {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCommandLine,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCommandLine>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCommandLine>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_command_line_t).as_wrapper()
        }
    }
}
pub trait WrapCommandLine: ImplCommandLine {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_command_line_t, Self>);
}
pub trait ImplCommandLine: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn copy(&self) -> Option<CommandLine> {
        Default::default()
    }
    fn init_from_argv(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    ) {
    }
    fn init_from_string(&self, command_line: Option<&CefStringUtf16>) {}
    fn reset(&self) {}
    fn get_argv(&self, argv: Option<&mut CefStringList>) {}
    fn get_command_line_string(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_program(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_program(&self, program: Option<&CefStringUtf16>) {}
    fn has_switches(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_switch(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_switch_value(&self, name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_switches(&self, switches: Option<&mut CefStringMap>) {}
    fn append_switch(&self, name: Option<&CefStringUtf16>) {}
    fn append_switch_with_value(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
    ) {
    }
    fn has_arguments(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_arguments(&self, arguments: Option<&mut CefStringList>) {}
    fn append_argument(&self, argument: Option<&CefStringUtf16>) {}
    fn prepend_wrapper(&self, wrapper: Option<&CefStringUtf16>) {}
    fn init_methods(object: &mut _cef_command_line_t) {
        impl_cef_command_line_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_command_line_t;
}
mod impl_cef_command_line_t {
    use super::*;
    pub fn init_methods<I: ImplCommandLine>(object: &mut _cef_command_line_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.copy = Some(copy::<I>);
        object.init_from_argv = Some(init_from_argv::<I>);
        object.init_from_string = Some(init_from_string::<I>);
        object.reset = Some(reset::<I>);
        object.get_argv = Some(get_argv::<I>);
        object.get_command_line_string = Some(get_command_line_string::<I>);
        object.get_program = Some(get_program::<I>);
        object.set_program = Some(set_program::<I>);
        object.has_switches = Some(has_switches::<I>);
        object.has_switch = Some(has_switch::<I>);
        object.get_switch_value = Some(get_switch_value::<I>);
        object.get_switches = Some(get_switches::<I>);
        object.append_switch = Some(append_switch::<I>);
        object.append_switch_with_value = Some(append_switch_with_value::<I>);
        object.has_arguments = Some(has_arguments::<I>);
        object.get_arguments = Some(get_arguments::<I>);
        object.append_argument = Some(append_argument::<I>);
        object.prepend_wrapper = Some(prepend_wrapper::<I>);
    }
    extern "C" fn is_valid<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_read_only<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn copy<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> *mut _cef_command_line_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::copy(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn init_from_argv<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    ) {
        let (arg_self_, arg_argc, arg_argv) = (self_, argc, argv);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_argc = arg_argc.as_raw();
        let arg_argv = arg_argv.as_raw();
        let result = ImplCommandLine::init_from_argv(&arg_self_.interface, arg_argc, arg_argv);
    }
    extern "C" fn init_from_string<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        command_line: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_command_line) = (self_, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_line = if arg_command_line.is_null() {
            None
        } else {
            Some(arg_command_line.into())
        };
        let arg_command_line = arg_command_line.as_ref();
        let result = ImplCommandLine::init_from_string(&arg_self_.interface, arg_command_line);
    }
    extern "C" fn reset<I: ImplCommandLine>(self_: *mut _cef_command_line_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::reset(&arg_self_.interface);
    }
    extern "C" fn get_argv<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        argv: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_argv) = (self_, argv);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_argv = if arg_argv.is_null() {
            None
        } else {
            Some(arg_argv.into())
        };
        let arg_argv = arg_argv.as_mut();
        let result = ImplCommandLine::get_argv(&arg_self_.interface, arg_argv);
    }
    extern "C" fn get_command_line_string<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::get_command_line_string(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_program<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::get_program(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_program<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        program: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_program) = (self_, program);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_program = if arg_program.is_null() {
            None
        } else {
            Some(arg_program.into())
        };
        let arg_program = arg_program.as_ref();
        let result = ImplCommandLine::set_program(&arg_self_.interface, arg_program);
    }
    extern "C" fn has_switches<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::has_switches(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_switch<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplCommandLine::has_switch(&arg_self_.interface, arg_name);
        result.into()
    }
    extern "C" fn get_switch_value<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplCommandLine::get_switch_value(&arg_self_.interface, arg_name);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_switches<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        switches: *mut _cef_string_map_t,
    ) {
        let (arg_self_, arg_switches) = (self_, switches);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_switches = if arg_switches.is_null() {
            None
        } else {
            Some(arg_switches.into())
        };
        let arg_switches = arg_switches.as_mut();
        let result = ImplCommandLine::get_switches(&arg_self_.interface, arg_switches);
    }
    extern "C" fn append_switch<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplCommandLine::append_switch(&arg_self_.interface, arg_name);
    }
    extern "C" fn append_switch_with_value<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name, arg_value) = (self_, name, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        let result =
            ImplCommandLine::append_switch_with_value(&arg_self_.interface, arg_name, arg_value);
    }
    extern "C" fn has_arguments<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplCommandLine::has_arguments(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_arguments<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        arguments: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_arguments) = (self_, arguments);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_arguments = if arg_arguments.is_null() {
            None
        } else {
            Some(arg_arguments.into())
        };
        let arg_arguments = arg_arguments.as_mut();
        let result = ImplCommandLine::get_arguments(&arg_self_.interface, arg_arguments);
    }
    extern "C" fn append_argument<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        argument: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_argument) = (self_, argument);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_argument = if arg_argument.is_null() {
            None
        } else {
            Some(arg_argument.into())
        };
        let arg_argument = arg_argument.as_ref();
        let result = ImplCommandLine::append_argument(&arg_self_.interface, arg_argument);
    }
    extern "C" fn prepend_wrapper<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        wrapper: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_wrapper) = (self_, wrapper);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_wrapper = if arg_wrapper.is_null() {
            None
        } else {
            Some(arg_wrapper.into())
        };
        let arg_wrapper = arg_wrapper.as_ref();
        let result = ImplCommandLine::prepend_wrapper(&arg_self_.interface, arg_wrapper);
    }
}
impl ImplCommandLine for CommandLine {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<CommandLine> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn init_from_argv(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    ) {
        unsafe {
            self.0
                .init_from_argv
                .map(|f| {
                    let (arg_argc, arg_argv) = (argc, argv);
                    let arg_self_ = self.as_raw();
                    let arg_argc = arg_argc;
                    let arg_argv = arg_argv as *const _;
                    let result = f(arg_self_, arg_argc, arg_argv);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn init_from_string(&self, command_line: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .init_from_string
                .map(|f| {
                    let arg_command_line = command_line;
                    let arg_self_ = self.as_raw();
                    let arg_command_line = arg_command_line
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reset(&self) {
        unsafe {
            self.0
                .reset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_argv(&self, argv: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .get_argv
                .map(|f| {
                    let arg_argv = argv;
                    let arg_self_ = self.as_raw();
                    let arg_argv = arg_argv
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_argv);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_command_line_string(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_command_line_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_program(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_program
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_program(&self, program: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_program
                .map(|f| {
                    let arg_program = program;
                    let arg_self_ = self.as_raw();
                    let arg_program = arg_program
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_program);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_switches(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_switches
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_switch(&self, name: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_switch
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_switch_value(&self, name: Option<&CefStringUtf16>) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_switch_value
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_switches(&self, switches: Option<&mut CefStringMap>) {
        unsafe {
            self.0
                .get_switches
                .map(|f| {
                    let arg_switches = switches;
                    let arg_self_ = self.as_raw();
                    let arg_switches = arg_switches
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_switches);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_switch(&self, name: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .append_switch
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_switch_with_value(
        &self,
        name: Option<&CefStringUtf16>,
        value: Option<&CefStringUtf16>,
    ) {
        unsafe {
            self.0
                .append_switch_with_value
                .map(|f| {
                    let (arg_name, arg_value) = (name, value);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_arguments(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_arguments
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_arguments(&self, arguments: Option<&mut CefStringList>) {
        unsafe {
            self.0
                .get_arguments
                .map(|f| {
                    let arg_arguments = arguments;
                    let arg_self_ = self.as_raw();
                    let arg_arguments = arg_arguments
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_arguments);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_argument(&self, argument: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .append_argument
                .map(|f| {
                    let arg_argument = argument;
                    let arg_self_ = self.as_raw();
                    let arg_argument = arg_argument
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_argument);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn prepend_wrapper(&self, wrapper: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .prepend_wrapper
                .map(|f| {
                    let arg_wrapper = wrapper;
                    let arg_self_ = self.as_raw();
                    let arg_wrapper = arg_wrapper
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_wrapper);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_command_line_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_command_line_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CommandLine {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_command_line_t> for &CommandLine {
    fn as_raw(self) -> *mut _cef_command_line_t {
        ImplCommandLine::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_command_line_t> for &mut CommandLine {
    fn as_raw(self) -> *mut _cef_command_line_t {
        ImplCommandLine::get_raw(self)
    }
}
impl ConvertReturnValue<CommandLine> for *mut _cef_command_line_t {
    fn as_wrapper(self) -> CommandLine {
        CommandLine(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_command_line_t> for CommandLine {
    fn into(self) -> *mut _cef_command_line_t {
        let object = ImplCommandLine::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for CommandLine {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_request_context_handler_t] for more documentation.
#[derive(Clone)]
pub struct RequestContextHandler(RefGuard<_cef_request_context_handler_t>);
impl RequestContextHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRequestContextHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRequestContextHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRequestContextHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_request_context_handler_t).as_wrapper()
        }
    }
}
pub trait WrapRequestContextHandler: ImplRequestContextHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_request_context_handler_t, Self>);
}
pub trait ImplRequestContextHandler: Clone + Sized + Rc {
    fn on_request_context_initialized(
        &self,
        request_context: Option<&mut impl ImplRequestContext>,
    ) {
    }
    fn get_resource_request_handler(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefStringUtf16>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_request_context_handler_t) {
        impl_cef_request_context_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_request_context_handler_t;
}
mod impl_cef_request_context_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRequestContextHandler>(object: &mut _cef_request_context_handler_t) {
        object.on_request_context_initialized = Some(on_request_context_initialized::<I>);
        object.get_resource_request_handler = Some(get_resource_request_handler::<I>);
    }
    extern "C" fn on_request_context_initialized<I: ImplRequestContextHandler>(
        self_: *mut _cef_request_context_handler_t,
        request_context: *mut _cef_request_context_t,
    ) {
        let (arg_self_, arg_request_context) = (self_, request_context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request_context = unsafe { arg_request_context.as_mut() }
            .map(|arg| RequestContext(unsafe { RefGuard::from_raw(arg) }));
        let arg_request_context = arg_request_context.as_mut();
        let result = ImplRequestContextHandler::on_request_context_initialized(
            &arg_self_.interface,
            arg_request_context,
        );
    }
    extern "C" fn get_resource_request_handler<I: ImplRequestContextHandler>(
        self_: *mut _cef_request_context_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: *const _cef_string_utf16_t,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_resource_request_handler_t {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        ) = (
            self_,
            browser,
            frame,
            request,
            is_navigation,
            is_download,
            request_initiator,
            disable_default_handling,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_is_navigation = arg_is_navigation.as_raw();
        let arg_is_download = arg_is_download.as_raw();
        let arg_request_initiator = if arg_request_initiator.is_null() {
            None
        } else {
            Some(arg_request_initiator.into())
        };
        let arg_request_initiator = arg_request_initiator.as_ref();
        let mut arg_disable_default_handling = if arg_disable_default_handling.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_disable_default_handling,
            ))
        };
        let arg_disable_default_handling = arg_disable_default_handling
            .as_mut()
            .map(|arg| arg.as_mut());
        let result = ImplRequestContextHandler::get_resource_request_handler(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplRequestContextHandler for RequestContextHandler {
    fn on_request_context_initialized(
        &self,
        request_context: Option<&mut impl ImplRequestContext>,
    ) {
        unsafe {
            self.0
                .on_request_context_initialized
                .map(|f| {
                    let arg_request_context = request_context;
                    let arg_self_ = self.as_raw();
                    let arg_request_context = arg_request_context
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequestContext::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request_context);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_request_handler(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        request: Option<&mut impl ImplRequest>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefStringUtf16>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        unsafe {
            self.0
                .get_resource_request_handler
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    ) = (
                        browser,
                        frame,
                        request,
                        is_navigation,
                        is_download,
                        request_initiator,
                        disable_default_handling,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_navigation = arg_is_navigation;
                    let arg_is_download = arg_is_download;
                    let arg_request_initiator = arg_request_initiator
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_disable_default_handling = arg_disable_default_handling
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_request_context_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_request_context_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestContextHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_context_handler_t> for &RequestContextHandler {
    fn as_raw(self) -> *mut _cef_request_context_handler_t {
        ImplRequestContextHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_context_handler_t> for &mut RequestContextHandler {
    fn as_raw(self) -> *mut _cef_request_context_handler_t {
        ImplRequestContextHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RequestContextHandler> for *mut _cef_request_context_handler_t {
    fn as_wrapper(self) -> RequestContextHandler {
        RequestContextHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_context_handler_t> for RequestContextHandler {
    fn into(self) -> *mut _cef_request_context_handler_t {
        let object = ImplRequestContextHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RequestContextHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_browser_process_handler_t] for more documentation.
#[derive(Clone)]
pub struct BrowserProcessHandler(RefGuard<_cef_browser_process_handler_t>);
impl BrowserProcessHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBrowserProcessHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBrowserProcessHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBrowserProcessHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_browser_process_handler_t).as_wrapper()
        }
    }
}
pub trait WrapBrowserProcessHandler: ImplBrowserProcessHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_browser_process_handler_t, Self>);
}
pub trait ImplBrowserProcessHandler: Clone + Sized + Rc {
    fn on_register_custom_preferences(
        &self,
        type_: PreferencesType,
        registrar: Option<&mut PreferenceRegistrar>,
    ) {
    }
    fn on_context_initialized(&self) {}
    fn on_before_child_process_launch(&self, command_line: Option<&mut impl ImplCommandLine>) {}
    fn on_already_running_app_relaunch(
        &self,
        command_line: Option<&mut impl ImplCommandLine>,
        current_directory: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_schedule_message_pump_work(&self, delay_ms: i64) {}
    fn get_default_client(&self) -> Option<Client> {
        Default::default()
    }
    fn get_default_request_context_handler(&self) -> Option<RequestContextHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_browser_process_handler_t) {
        impl_cef_browser_process_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_browser_process_handler_t;
}
mod impl_cef_browser_process_handler_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserProcessHandler>(object: &mut _cef_browser_process_handler_t) {
        object.on_register_custom_preferences = Some(on_register_custom_preferences::<I>);
        object.on_context_initialized = Some(on_context_initialized::<I>);
        object.on_before_child_process_launch = Some(on_before_child_process_launch::<I>);
        object.on_already_running_app_relaunch = Some(on_already_running_app_relaunch::<I>);
        object.on_schedule_message_pump_work = Some(on_schedule_message_pump_work::<I>);
        object.get_default_client = Some(get_default_client::<I>);
        object.get_default_request_context_handler = Some(get_default_request_context_handler::<I>);
    }
    extern "C" fn on_register_custom_preferences<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        type_: cef_preferences_type_t,
        registrar: *mut _cef_preference_registrar_t,
    ) {
        let (arg_self_, arg_type_, arg_registrar) = (self_, type_, registrar);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_type_ = arg_type_.as_raw();
        let mut arg_registrar = if arg_registrar.is_null() {
            None
        } else {
            Some(PreferenceRegistrar(arg_registrar))
        };
        let arg_registrar = arg_registrar.as_mut();
        let result = ImplBrowserProcessHandler::on_register_custom_preferences(
            &arg_self_.interface,
            arg_type_,
            arg_registrar,
        );
    }
    extern "C" fn on_context_initialized<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserProcessHandler::on_context_initialized(&arg_self_.interface);
    }
    extern "C" fn on_before_child_process_launch<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        command_line: *mut _cef_command_line_t,
    ) {
        let (arg_self_, arg_command_line) = (self_, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_command_line = unsafe { arg_command_line.as_mut() }
            .map(|arg| CommandLine(unsafe { RefGuard::from_raw(arg) }));
        let arg_command_line = arg_command_line.as_mut();
        let result = ImplBrowserProcessHandler::on_before_child_process_launch(
            &arg_self_.interface,
            arg_command_line,
        );
    }
    extern "C" fn on_already_running_app_relaunch<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        command_line: *mut _cef_command_line_t,
        current_directory: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_line, arg_current_directory) =
            (self_, command_line, current_directory);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_command_line = unsafe { arg_command_line.as_mut() }
            .map(|arg| CommandLine(unsafe { RefGuard::from_raw(arg) }));
        let arg_command_line = arg_command_line.as_mut();
        let arg_current_directory = if arg_current_directory.is_null() {
            None
        } else {
            Some(arg_current_directory.into())
        };
        let arg_current_directory = arg_current_directory.as_ref();
        let result = ImplBrowserProcessHandler::on_already_running_app_relaunch(
            &arg_self_.interface,
            arg_command_line,
            arg_current_directory,
        );
        result.into()
    }
    extern "C" fn on_schedule_message_pump_work<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        delay_ms: i64,
    ) {
        let (arg_self_, arg_delay_ms) = (self_, delay_ms);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_delay_ms = arg_delay_ms.as_raw();
        let result = ImplBrowserProcessHandler::on_schedule_message_pump_work(
            &arg_self_.interface,
            arg_delay_ms,
        );
    }
    extern "C" fn get_default_client<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) -> *mut _cef_client_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserProcessHandler::get_default_client(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_default_request_context_handler<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) -> *mut _cef_request_context_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result =
            ImplBrowserProcessHandler::get_default_request_context_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplBrowserProcessHandler for BrowserProcessHandler {
    fn on_register_custom_preferences(
        &self,
        type_: PreferencesType,
        registrar: Option<&mut PreferenceRegistrar>,
    ) {
        unsafe {
            self.0
                .on_register_custom_preferences
                .map(|f| {
                    let (arg_type_, arg_registrar) = (type_, registrar);
                    let arg_self_ = self.as_raw();
                    let arg_type_ = arg_type_.as_raw();
                    let arg_registrar = arg_registrar
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_type_, arg_registrar);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_context_initialized(&self) {
        unsafe {
            self.0
                .on_context_initialized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_child_process_launch(&self, command_line: Option<&mut impl ImplCommandLine>) {
        unsafe {
            self.0
                .on_before_child_process_launch
                .map(|f| {
                    let arg_command_line = command_line;
                    let arg_self_ = self.as_raw();
                    let arg_command_line = arg_command_line
                        .map(|arg| {
                            arg.add_ref();
                            ImplCommandLine::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_command_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_already_running_app_relaunch(
        &self,
        command_line: Option<&mut impl ImplCommandLine>,
        current_directory: Option<&CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_already_running_app_relaunch
                .map(|f| {
                    let (arg_command_line, arg_current_directory) =
                        (command_line, current_directory);
                    let arg_self_ = self.as_raw();
                    let arg_command_line = arg_command_line
                        .map(|arg| {
                            arg.add_ref();
                            ImplCommandLine::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_current_directory = arg_current_directory
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_line, arg_current_directory);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_schedule_message_pump_work(&self, delay_ms: i64) {
        unsafe {
            self.0
                .on_schedule_message_pump_work
                .map(|f| {
                    let arg_delay_ms = delay_ms;
                    let arg_self_ = self.as_raw();
                    let arg_delay_ms = arg_delay_ms;
                    let result = f(arg_self_, arg_delay_ms);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_default_client(&self) -> Option<Client> {
        unsafe {
            self.0
                .get_default_client
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_default_request_context_handler(&self) -> Option<RequestContextHandler> {
        unsafe {
            self.0
                .get_default_request_context_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_process_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_browser_process_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserProcessHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_process_handler_t> for &BrowserProcessHandler {
    fn as_raw(self) -> *mut _cef_browser_process_handler_t {
        ImplBrowserProcessHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_process_handler_t> for &mut BrowserProcessHandler {
    fn as_raw(self) -> *mut _cef_browser_process_handler_t {
        ImplBrowserProcessHandler::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserProcessHandler> for *mut _cef_browser_process_handler_t {
    fn as_wrapper(self) -> BrowserProcessHandler {
        BrowserProcessHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_process_handler_t> for BrowserProcessHandler {
    fn into(self) -> *mut _cef_browser_process_handler_t {
        let object = ImplBrowserProcessHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for BrowserProcessHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_task_t] for more documentation.
#[derive(Clone)]
pub struct Task(RefGuard<_cef_task_t>);
impl Task {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapTask,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplTask>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapTask>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_task_t).as_wrapper()
        }
    }
}
pub trait WrapTask: ImplTask {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_task_t, Self>);
}
pub trait ImplTask: Clone + Sized + Rc {
    fn execute(&self) {}
    fn init_methods(object: &mut _cef_task_t) {
        impl_cef_task_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_task_t;
}
mod impl_cef_task_t {
    use super::*;
    pub fn init_methods<I: ImplTask>(object: &mut _cef_task_t) {
        object.execute = Some(execute::<I>);
    }
    extern "C" fn execute<I: ImplTask>(self_: *mut _cef_task_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTask::execute(&arg_self_.interface);
    }
}
impl ImplTask for Task {
    fn execute(&self) {
        unsafe {
            self.0
                .execute
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_task_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_task_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Task {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_task_t> for &Task {
    fn as_raw(self) -> *mut _cef_task_t {
        ImplTask::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_task_t> for &mut Task {
    fn as_raw(self) -> *mut _cef_task_t {
        ImplTask::get_raw(self)
    }
}
impl ConvertReturnValue<Task> for *mut _cef_task_t {
    fn as_wrapper(self) -> Task {
        Task(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_task_t> for Task {
    fn into(self) -> *mut _cef_task_t {
        let object = ImplTask::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Task {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_task_runner_t] for more documentation.
#[derive(Clone)]
pub struct TaskRunner(RefGuard<_cef_task_runner_t>);
impl TaskRunner {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapTaskRunner,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplTaskRunner>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapTaskRunner>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_task_runner_t).as_wrapper()
        }
    }
}
pub trait WrapTaskRunner: ImplTaskRunner {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_task_runner_t, Self>);
}
pub trait ImplTaskRunner: Clone + Sized + Rc {
    fn is_same(&self, that: Option<&mut impl ImplTaskRunner>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn belongs_to_current_thread(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn belongs_to_thread(&self, thread_id: ThreadId) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn post_task(&self, task: Option<&mut impl ImplTask>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn post_delayed_task(
        &self,
        task: Option<&mut impl ImplTask>,
        delay_ms: i64,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_task_runner_t) {
        impl_cef_task_runner_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_task_runner_t;
}
mod impl_cef_task_runner_t {
    use super::*;
    pub fn init_methods<I: ImplTaskRunner>(object: &mut _cef_task_runner_t) {
        object.is_same = Some(is_same::<I>);
        object.belongs_to_current_thread = Some(belongs_to_current_thread::<I>);
        object.belongs_to_thread = Some(belongs_to_thread::<I>);
        object.post_task = Some(post_task::<I>);
        object.post_delayed_task = Some(post_delayed_task::<I>);
    }
    extern "C" fn is_same<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        that: *mut _cef_task_runner_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| TaskRunner(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplTaskRunner::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn belongs_to_current_thread<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTaskRunner::belongs_to_current_thread(&arg_self_.interface);
        result.into()
    }
    extern "C" fn belongs_to_thread<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        thread_id: cef_thread_id_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_thread_id) = (self_, thread_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_thread_id = arg_thread_id.as_raw();
        let result = ImplTaskRunner::belongs_to_thread(&arg_self_.interface, arg_thread_id);
        result.into()
    }
    extern "C" fn post_task<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        task: *mut _cef_task_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_task) = (self_, task);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_task =
            unsafe { arg_task.as_mut() }.map(|arg| Task(unsafe { RefGuard::from_raw(arg) }));
        let arg_task = arg_task.as_mut();
        let result = ImplTaskRunner::post_task(&arg_self_.interface, arg_task);
        result.into()
    }
    extern "C" fn post_delayed_task<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        task: *mut _cef_task_t,
        delay_ms: i64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_task, arg_delay_ms) = (self_, task, delay_ms);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_task =
            unsafe { arg_task.as_mut() }.map(|arg| Task(unsafe { RefGuard::from_raw(arg) }));
        let arg_task = arg_task.as_mut();
        let arg_delay_ms = arg_delay_ms.as_raw();
        let result =
            ImplTaskRunner::post_delayed_task(&arg_self_.interface, arg_task, arg_delay_ms);
        result.into()
    }
}
impl ImplTaskRunner for TaskRunner {
    fn is_same(&self, that: Option<&mut impl ImplTaskRunner>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplTaskRunner::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn belongs_to_current_thread(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .belongs_to_current_thread
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn belongs_to_thread(&self, thread_id: ThreadId) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .belongs_to_thread
                .map(|f| {
                    let arg_thread_id = thread_id;
                    let arg_self_ = self.as_raw();
                    let arg_thread_id = arg_thread_id.as_raw();
                    let result = f(arg_self_, arg_thread_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn post_task(&self, task: Option<&mut impl ImplTask>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .post_task
                .map(|f| {
                    let arg_task = task;
                    let arg_self_ = self.as_raw();
                    let arg_task = arg_task
                        .map(|arg| {
                            arg.add_ref();
                            ImplTask::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_task);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn post_delayed_task(
        &self,
        task: Option<&mut impl ImplTask>,
        delay_ms: i64,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .post_delayed_task
                .map(|f| {
                    let (arg_task, arg_delay_ms) = (task, delay_ms);
                    let arg_self_ = self.as_raw();
                    let arg_task = arg_task
                        .map(|arg| {
                            arg.add_ref();
                            ImplTask::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_delay_ms = arg_delay_ms;
                    let result = f(arg_self_, arg_task, arg_delay_ms);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_task_runner_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_task_runner_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for TaskRunner {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_task_runner_t> for &TaskRunner {
    fn as_raw(self) -> *mut _cef_task_runner_t {
        ImplTaskRunner::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_task_runner_t> for &mut TaskRunner {
    fn as_raw(self) -> *mut _cef_task_runner_t {
        ImplTaskRunner::get_raw(self)
    }
}
impl ConvertReturnValue<TaskRunner> for *mut _cef_task_runner_t {
    fn as_wrapper(self) -> TaskRunner {
        TaskRunner(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_task_runner_t> for TaskRunner {
    fn into(self) -> *mut _cef_task_runner_t {
        let object = ImplTaskRunner::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for TaskRunner {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8context_t] for more documentation.
#[derive(Clone)]
pub struct V8context(RefGuard<_cef_v8context_t>);
impl V8context {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8context,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8context>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8context>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8context_t).as_wrapper()
        }
    }
}
pub trait WrapV8context: ImplV8context {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8context_t, Self>);
}
pub trait ImplV8context: Clone + Sized + Rc {
    fn get_task_runner(&self) -> Option<TaskRunner> {
        Default::default()
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_browser(&self) -> Option<Browser> {
        Default::default()
    }
    fn get_frame(&self) -> Option<Frame> {
        Default::default()
    }
    fn get_global(&self) -> Option<V8value> {
        Default::default()
    }
    fn enter(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn exit(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplV8context>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn eval(
        &self,
        code: Option<&CefStringUtf16>,
        script_url: Option<&CefStringUtf16>,
        start_line: ::std::os::raw::c_int,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut impl ImplV8exception>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8context_t) {
        impl_cef_v8context_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8context_t;
}
mod impl_cef_v8context_t {
    use super::*;
    pub fn init_methods<I: ImplV8context>(object: &mut _cef_v8context_t) {
        object.get_task_runner = Some(get_task_runner::<I>);
        object.is_valid = Some(is_valid::<I>);
        object.get_browser = Some(get_browser::<I>);
        object.get_frame = Some(get_frame::<I>);
        object.get_global = Some(get_global::<I>);
        object.enter = Some(enter::<I>);
        object.exit = Some(exit::<I>);
        object.is_same = Some(is_same::<I>);
        object.eval = Some(eval::<I>);
    }
    extern "C" fn get_task_runner<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> *mut _cef_task_runner_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8context::get_task_runner(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_valid<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8context::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_browser<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8context::get_browser(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame<I: ImplV8context>(self_: *mut _cef_v8context_t) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8context::get_frame(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_global<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> *mut _cef_v8value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8context::get_global(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn enter<I: ImplV8context>(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8context::enter(&arg_self_.interface);
        result.into()
    }
    extern "C" fn exit<I: ImplV8context>(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8context::exit(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
        that: *mut _cef_v8context_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| V8context(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplV8context::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn eval<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
        code: *const _cef_string_utf16_t,
        script_url: *const _cef_string_utf16_t,
        start_line: ::std::os::raw::c_int,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_code, arg_script_url, arg_start_line, arg_retval, arg_exception) =
            (self_, code, script_url, start_line, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_code = if arg_code.is_null() {
            None
        } else {
            Some(arg_code.into())
        };
        let arg_code = arg_code.as_ref();
        let arg_script_url = if arg_script_url.is_null() {
            None
        } else {
            Some(arg_script_url.into())
        };
        let arg_script_url = arg_script_url.as_ref();
        let arg_start_line = arg_start_line.as_raw();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = unsafe { arg_exception.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8exception(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8context::eval(
            &arg_self_.interface,
            arg_code,
            arg_script_url,
            arg_start_line,
            arg_retval,
            arg_exception,
        );
        result.into()
    }
}
impl ImplV8context for V8context {
    fn get_task_runner(&self) -> Option<TaskRunner> {
        unsafe {
            self.0
                .get_task_runner
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_frame(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_global(&self) -> Option<V8value> {
        unsafe {
            self.0
                .get_global
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn enter(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .enter
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn exit(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .exit
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplV8context>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8context::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn eval(
        &self,
        code: Option<&CefStringUtf16>,
        script_url: Option<&CefStringUtf16>,
        start_line: ::std::os::raw::c_int,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut impl ImplV8exception>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eval
                .map(|f| {
                    let (arg_code, arg_script_url, arg_start_line, arg_retval, arg_exception) =
                        (code, script_url, start_line, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_code = arg_code.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_script_url = arg_script_url
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_start_line = arg_start_line;
                    let mut arg_retval = arg_retval.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_retval = arg_retval
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_exception = arg_exception.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_exception = arg_exception
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_code,
                        arg_script_url,
                        arg_start_line,
                        arg_retval,
                        arg_exception,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8context_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8context_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8context {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8context_t> for &V8context {
    fn as_raw(self) -> *mut _cef_v8context_t {
        ImplV8context::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8context_t> for &mut V8context {
    fn as_raw(self) -> *mut _cef_v8context_t {
        ImplV8context::get_raw(self)
    }
}
impl ConvertReturnValue<V8context> for *mut _cef_v8context_t {
    fn as_wrapper(self) -> V8context {
        V8context(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8context_t> for V8context {
    fn into(self) -> *mut _cef_v8context_t {
        let object = ImplV8context::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8context {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8handler_t] for more documentation.
#[derive(Clone)]
pub struct V8handler(RefGuard<_cef_v8handler_t>);
impl V8handler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8handler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8handler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8handler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8handler_t).as_wrapper()
        }
    }
}
pub trait WrapV8handler: ImplV8handler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8handler_t, Self>);
}
pub trait ImplV8handler: Clone + Sized + Rc {
    fn execute(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        arguments: Option<&[Option<impl ImplV8value>]>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8handler_t) {
        impl_cef_v8handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8handler_t;
}
mod impl_cef_v8handler_t {
    use super::*;
    pub fn init_methods<I: ImplV8handler>(object: &mut _cef_v8handler_t) {
        object.execute = Some(execute::<I>);
    }
    extern "C" fn execute<I: ImplV8handler>(
        self_: *mut _cef_v8handler_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        arguments_count: usize,
        arguments: *const *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_name,
            arg_object,
            arg_arguments_count,
            arg_arguments,
            arg_retval,
            arg_exception,
        ) = (
            self_,
            name,
            object,
            arguments_count,
            arguments,
            retval,
            exception,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let vec_arguments = unsafe { arg_arguments.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_arguments_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(V8value(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_arguments = vec_arguments.as_ref().map(|arg| arg.as_slice());
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8handler::execute(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_arguments,
            arg_retval,
            arg_exception,
        );
        result.into()
    }
}
impl ImplV8handler for V8handler {
    fn execute(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        arguments: Option<&[Option<impl ImplV8value>]>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .execute
                .map(|f| {
                    let (arg_name, arg_object, arg_arguments, arg_retval, arg_exception) =
                        (name, object, arguments, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_arguments_count = arg_arguments
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let mut arg_retval = arg_retval.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_retval = arg_retval
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_name,
                        arg_object,
                        arg_arguments_count,
                        arg_arguments,
                        arg_retval,
                        arg_exception,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8handler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8handler_t> for &V8handler {
    fn as_raw(self) -> *mut _cef_v8handler_t {
        ImplV8handler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8handler_t> for &mut V8handler {
    fn as_raw(self) -> *mut _cef_v8handler_t {
        ImplV8handler::get_raw(self)
    }
}
impl ConvertReturnValue<V8handler> for *mut _cef_v8handler_t {
    fn as_wrapper(self) -> V8handler {
        V8handler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8handler_t> for V8handler {
    fn into(self) -> *mut _cef_v8handler_t {
        let object = ImplV8handler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8handler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8accessor_t] for more documentation.
#[derive(Clone)]
pub struct V8accessor(RefGuard<_cef_v8accessor_t>);
impl V8accessor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8accessor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8accessor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8accessor>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8accessor_t).as_wrapper()
        }
    }
}
pub trait WrapV8accessor: ImplV8accessor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8accessor_t, Self>);
}
pub trait ImplV8accessor: Clone + Sized + Rc {
    fn get(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        value: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8accessor_t) {
        impl_cef_v8accessor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8accessor_t;
}
mod impl_cef_v8accessor_t {
    use super::*;
    pub fn init_methods<I: ImplV8accessor>(object: &mut _cef_v8accessor_t) {
        object.get = Some(get::<I>);
        object.set = Some(set::<I>);
    }
    extern "C" fn get<I: ImplV8accessor>(
        self_: *mut _cef_v8accessor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_retval, arg_exception) =
            (self_, name, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8accessor::get(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_retval,
            arg_exception,
        );
        result.into()
    }
    extern "C" fn set<I: ImplV8accessor>(
        self_: *mut _cef_v8accessor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        value: *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_value, arg_exception) =
            (self_, name, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8accessor::set(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_value,
            arg_exception,
        );
        result.into()
    }
}
impl ImplV8accessor for V8accessor {
    fn get(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get
                .map(|f| {
                    let (arg_name, arg_object, arg_retval, arg_exception) =
                        (name, object, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_retval = arg_retval.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_retval = arg_retval
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_retval, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        value: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set
                .map(|f| {
                    let (arg_name, arg_object, arg_value, arg_exception) =
                        (name, object, value, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_value, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8accessor_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8accessor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8accessor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8accessor_t> for &V8accessor {
    fn as_raw(self) -> *mut _cef_v8accessor_t {
        ImplV8accessor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8accessor_t> for &mut V8accessor {
    fn as_raw(self) -> *mut _cef_v8accessor_t {
        ImplV8accessor::get_raw(self)
    }
}
impl ConvertReturnValue<V8accessor> for *mut _cef_v8accessor_t {
    fn as_wrapper(self) -> V8accessor {
        V8accessor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8accessor_t> for V8accessor {
    fn into(self) -> *mut _cef_v8accessor_t {
        let object = ImplV8accessor::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8accessor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8interceptor_t] for more documentation.
#[derive(Clone)]
pub struct V8interceptor(RefGuard<_cef_v8interceptor_t>);
impl V8interceptor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8interceptor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8interceptor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8interceptor>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8interceptor_t).as_wrapper()
        }
    }
}
pub trait WrapV8interceptor: ImplV8interceptor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8interceptor_t, Self>);
}
pub trait ImplV8interceptor: Clone + Sized + Rc {
    fn get_byname(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut impl ImplV8value>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_byname(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        value: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut impl ImplV8value>,
        value: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8interceptor_t) {
        impl_cef_v8interceptor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8interceptor_t;
}
mod impl_cef_v8interceptor_t {
    use super::*;
    pub fn init_methods<I: ImplV8interceptor>(object: &mut _cef_v8interceptor_t) {
        object.get_byname = Some(get_byname::<I>);
        object.get_byindex = Some(get_byindex::<I>);
        object.set_byname = Some(set_byname::<I>);
        object.set_byindex = Some(set_byindex::<I>);
    }
    extern "C" fn get_byname<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_retval, arg_exception) =
            (self_, name, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8interceptor::get_byname(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_retval,
            arg_exception,
        );
        result.into()
    }
    extern "C" fn get_byindex<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        index: ::std::os::raw::c_int,
        object: *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_object, arg_retval, arg_exception) =
            (self_, index, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8interceptor::get_byindex(
            &arg_self_.interface,
            arg_index,
            arg_object,
            arg_retval,
            arg_exception,
        );
        result.into()
    }
    extern "C" fn set_byname<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        value: *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_value, arg_exception) =
            (self_, name, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8interceptor::set_byname(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_value,
            arg_exception,
        );
        result.into()
    }
    extern "C" fn set_byindex<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        index: ::std::os::raw::c_int,
        object: *mut _cef_v8value_t,
        value: *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_object, arg_value, arg_exception) =
            (self_, index, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        let result = ImplV8interceptor::set_byindex(
            &arg_self_.interface,
            arg_index,
            arg_object,
            arg_value,
            arg_exception,
        );
        result.into()
    }
}
impl ImplV8interceptor for V8interceptor {
    fn get_byname(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_byname
                .map(|f| {
                    let (arg_name, arg_object, arg_retval, arg_exception) =
                        (name, object, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_retval = arg_retval.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_retval = arg_retval
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_retval, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut impl ImplV8value>,
        retval: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_byindex
                .map(|f| {
                    let (arg_index, arg_object, arg_retval, arg_exception) =
                        (index, object, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_retval = arg_retval.map(|arg| {
                        arg.add_ref();
                        arg.get_raw()
                    });
                    let arg_retval = arg_retval
                        .as_mut()
                        .map(|arg| arg as *mut _)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_object, arg_retval, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_byname(
        &self,
        name: Option<&CefStringUtf16>,
        object: Option<&mut impl ImplV8value>,
        value: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_byname
                .map(|f| {
                    let (arg_name, arg_object, arg_value, arg_exception) =
                        (name, object, value, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_value, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut impl ImplV8value>,
        value: Option<&mut impl ImplV8value>,
        exception: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_byindex
                .map(|f| {
                    let (arg_index, arg_object, arg_value, arg_exception) =
                        (index, object, value, exception);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_object, arg_value, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8interceptor_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8interceptor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8interceptor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8interceptor_t> for &V8interceptor {
    fn as_raw(self) -> *mut _cef_v8interceptor_t {
        ImplV8interceptor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8interceptor_t> for &mut V8interceptor {
    fn as_raw(self) -> *mut _cef_v8interceptor_t {
        ImplV8interceptor::get_raw(self)
    }
}
impl ConvertReturnValue<V8interceptor> for *mut _cef_v8interceptor_t {
    fn as_wrapper(self) -> V8interceptor {
        V8interceptor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8interceptor_t> for V8interceptor {
    fn into(self) -> *mut _cef_v8interceptor_t {
        let object = ImplV8interceptor::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8interceptor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8exception_t] for more documentation.
#[derive(Clone)]
pub struct V8exception(RefGuard<_cef_v8exception_t>);
impl V8exception {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8exception,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8exception>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8exception>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8exception_t).as_wrapper()
        }
    }
}
pub trait WrapV8exception: ImplV8exception {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8exception_t, Self>);
}
pub trait ImplV8exception: Clone + Sized + Rc {
    fn get_message(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_source_line(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_script_resource_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_line_number(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_start_position(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_end_position(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_start_column(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_end_column(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8exception_t) {
        impl_cef_v8exception_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8exception_t;
}
mod impl_cef_v8exception_t {
    use super::*;
    pub fn init_methods<I: ImplV8exception>(object: &mut _cef_v8exception_t) {
        object.get_message = Some(get_message::<I>);
        object.get_source_line = Some(get_source_line::<I>);
        object.get_script_resource_name = Some(get_script_resource_name::<I>);
        object.get_line_number = Some(get_line_number::<I>);
        object.get_start_position = Some(get_start_position::<I>);
        object.get_end_position = Some(get_end_position::<I>);
        object.get_start_column = Some(get_start_column::<I>);
        object.get_end_column = Some(get_end_column::<I>);
    }
    extern "C" fn get_message<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_message(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_source_line<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_source_line(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_script_resource_name<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_script_resource_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_line_number<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_line_number(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_start_position<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_start_position(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_end_position<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_end_position(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_start_column<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_start_column(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_end_column<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8exception::get_end_column(&arg_self_.interface);
        result.into()
    }
}
impl ImplV8exception for V8exception {
    fn get_message(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_message
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_source_line(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_source_line
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_script_resource_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_script_resource_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_line_number(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_line_number
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_start_position(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_start_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_end_position(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_end_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_start_column(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_start_column
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_end_column(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_end_column
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8exception_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8exception_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8exception {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8exception_t> for &V8exception {
    fn as_raw(self) -> *mut _cef_v8exception_t {
        ImplV8exception::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8exception_t> for &mut V8exception {
    fn as_raw(self) -> *mut _cef_v8exception_t {
        ImplV8exception::get_raw(self)
    }
}
impl ConvertReturnValue<V8exception> for *mut _cef_v8exception_t {
    fn as_wrapper(self) -> V8exception {
        V8exception(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8exception_t> for V8exception {
    fn into(self) -> *mut _cef_v8exception_t {
        let object = ImplV8exception::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8exception {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8array_buffer_release_callback_t] for more documentation.
#[derive(Clone)]
pub struct V8arrayBufferReleaseCallback(RefGuard<_cef_v8array_buffer_release_callback_t>);
impl V8arrayBufferReleaseCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8arrayBufferReleaseCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8arrayBufferReleaseCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8arrayBufferReleaseCallback>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8array_buffer_release_callback_t).as_wrapper()
        }
    }
}
pub trait WrapV8arrayBufferReleaseCallback: ImplV8arrayBufferReleaseCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8array_buffer_release_callback_t, Self>);
}
pub trait ImplV8arrayBufferReleaseCallback: Clone + Sized + Rc {
    fn release_buffer(&self, buffer: *mut u8) {}
    fn init_methods(object: &mut _cef_v8array_buffer_release_callback_t) {
        impl_cef_v8array_buffer_release_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8array_buffer_release_callback_t;
}
mod impl_cef_v8array_buffer_release_callback_t {
    use super::*;
    pub fn init_methods<I: ImplV8arrayBufferReleaseCallback>(
        object: &mut _cef_v8array_buffer_release_callback_t,
    ) {
        object.release_buffer = Some(release_buffer::<I>);
    }
    extern "C" fn release_buffer<I: ImplV8arrayBufferReleaseCallback>(
        self_: *mut _cef_v8array_buffer_release_callback_t,
        buffer: *mut ::std::os::raw::c_void,
    ) {
        let (arg_self_, arg_buffer) = (self_, buffer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_buffer = arg_buffer as *mut _;
        let result =
            ImplV8arrayBufferReleaseCallback::release_buffer(&arg_self_.interface, arg_buffer);
    }
}
impl ImplV8arrayBufferReleaseCallback for V8arrayBufferReleaseCallback {
    fn release_buffer(&self, buffer: *mut u8) {
        unsafe {
            self.0
                .release_buffer
                .map(|f| {
                    let arg_buffer = buffer;
                    let arg_self_ = self.as_raw();
                    let arg_buffer = arg_buffer as *mut _;
                    let result = f(arg_self_, arg_buffer);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_v8array_buffer_release_callback_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8array_buffer_release_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8arrayBufferReleaseCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8array_buffer_release_callback_t> for &V8arrayBufferReleaseCallback {
    fn as_raw(self) -> *mut _cef_v8array_buffer_release_callback_t {
        ImplV8arrayBufferReleaseCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8array_buffer_release_callback_t>
    for &mut V8arrayBufferReleaseCallback
{
    fn as_raw(self) -> *mut _cef_v8array_buffer_release_callback_t {
        ImplV8arrayBufferReleaseCallback::get_raw(self)
    }
}
impl ConvertReturnValue<V8arrayBufferReleaseCallback>
    for *mut _cef_v8array_buffer_release_callback_t
{
    fn as_wrapper(self) -> V8arrayBufferReleaseCallback {
        V8arrayBufferReleaseCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8array_buffer_release_callback_t> for V8arrayBufferReleaseCallback {
    fn into(self) -> *mut _cef_v8array_buffer_release_callback_t {
        let object = ImplV8arrayBufferReleaseCallback::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8arrayBufferReleaseCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8value_t] for more documentation.
#[derive(Clone)]
pub struct V8value(RefGuard<_cef_v8value_t>);
impl V8value {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8value,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8value>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8value>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8value_t).as_wrapper()
        }
    }
}
pub trait WrapV8value: ImplV8value {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8value_t, Self>);
}
pub trait ImplV8value: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_undefined(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_null(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_bool(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_int(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_uint(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_double(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_date(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_string(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_object(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_array(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_array_buffer(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_function(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_promise(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplV8value>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_bool_value(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_int_value(&self) -> i32 {
        Default::default()
    }
    fn get_uint_value(&self) -> u32 {
        Default::default()
    }
    fn get_double_value(&self) -> f64 {
        Default::default()
    }
    fn get_date_value(&self) -> Basetime {
        Default::default()
    }
    fn get_string_value(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn is_user_created(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_exception(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_exception(&self) -> Option<V8exception> {
        Default::default()
    }
    fn clear_exception(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn will_rethrow_exceptions(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_rethrow_exceptions(&self, rethrow: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_value_bykey(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn delete_value_bykey(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn delete_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_value_bykey(&self, key: Option<&CefStringUtf16>) -> Option<V8value> {
        Default::default()
    }
    fn get_value_byindex(&self, index: ::std::os::raw::c_int) -> Option<V8value> {
        Default::default()
    }
    fn set_value_bykey(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplV8value>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_value_byindex(
        &self,
        index: ::std::os::raw::c_int,
        value: Option<&mut impl ImplV8value>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_value_byaccessor(
        &self,
        key: Option<&CefStringUtf16>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_user_data(&self, user_data: Option<&mut BaseRefCounted>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_user_data(&self) -> Option<BaseRefCounted> {
        Default::default()
    }
    fn get_externally_allocated_memory(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn adjust_externally_allocated_memory(
        &self,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_array_length(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_array_buffer_release_callback(&self) -> Option<V8arrayBufferReleaseCallback> {
        Default::default()
    }
    fn neuter_array_buffer(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_array_buffer_byte_length(&self) -> usize {
        Default::default()
    }
    fn get_array_buffer_data(&self) -> *mut ::std::os::raw::c_void {
        unsafe { std::mem::zeroed() }
    }
    fn get_function_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_function_handler(&self) -> Option<V8handler> {
        Default::default()
    }
    fn execute_function(
        &self,
        object: Option<&mut impl ImplV8value>,
        arguments: Option<&[Option<impl ImplV8value>]>,
    ) -> Option<V8value> {
        Default::default()
    }
    fn execute_function_with_context(
        &self,
        context: Option<&mut impl ImplV8context>,
        object: Option<&mut impl ImplV8value>,
        arguments: Option<&[Option<impl ImplV8value>]>,
    ) -> Option<V8value> {
        Default::default()
    }
    fn resolve_promise(&self, arg: Option<&mut impl ImplV8value>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn reject_promise(&self, error_msg: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8value_t) {
        impl_cef_v8value_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8value_t;
}
mod impl_cef_v8value_t {
    use super::*;
    pub fn init_methods<I: ImplV8value>(object: &mut _cef_v8value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_undefined = Some(is_undefined::<I>);
        object.is_null = Some(is_null::<I>);
        object.is_bool = Some(is_bool::<I>);
        object.is_int = Some(is_int::<I>);
        object.is_uint = Some(is_uint::<I>);
        object.is_double = Some(is_double::<I>);
        object.is_date = Some(is_date::<I>);
        object.is_string = Some(is_string::<I>);
        object.is_object = Some(is_object::<I>);
        object.is_array = Some(is_array::<I>);
        object.is_array_buffer = Some(is_array_buffer::<I>);
        object.is_function = Some(is_function::<I>);
        object.is_promise = Some(is_promise::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_bool_value = Some(get_bool_value::<I>);
        object.get_int_value = Some(get_int_value::<I>);
        object.get_uint_value = Some(get_uint_value::<I>);
        object.get_double_value = Some(get_double_value::<I>);
        object.get_date_value = Some(get_date_value::<I>);
        object.get_string_value = Some(get_string_value::<I>);
        object.is_user_created = Some(is_user_created::<I>);
        object.has_exception = Some(has_exception::<I>);
        object.get_exception = Some(get_exception::<I>);
        object.clear_exception = Some(clear_exception::<I>);
        object.will_rethrow_exceptions = Some(will_rethrow_exceptions::<I>);
        object.set_rethrow_exceptions = Some(set_rethrow_exceptions::<I>);
        object.has_value_bykey = Some(has_value_bykey::<I>);
        object.has_value_byindex = Some(has_value_byindex::<I>);
        object.delete_value_bykey = Some(delete_value_bykey::<I>);
        object.delete_value_byindex = Some(delete_value_byindex::<I>);
        object.get_value_bykey = Some(get_value_bykey::<I>);
        object.get_value_byindex = Some(get_value_byindex::<I>);
        object.set_value_bykey = Some(set_value_bykey::<I>);
        object.set_value_byindex = Some(set_value_byindex::<I>);
        object.set_value_byaccessor = Some(set_value_byaccessor::<I>);
        object.get_keys = Some(get_keys::<I>);
        object.set_user_data = Some(set_user_data::<I>);
        object.get_user_data = Some(get_user_data::<I>);
        object.get_externally_allocated_memory = Some(get_externally_allocated_memory::<I>);
        object.adjust_externally_allocated_memory = Some(adjust_externally_allocated_memory::<I>);
        object.get_array_length = Some(get_array_length::<I>);
        object.get_array_buffer_release_callback = Some(get_array_buffer_release_callback::<I>);
        object.neuter_array_buffer = Some(neuter_array_buffer::<I>);
        object.get_array_buffer_byte_length = Some(get_array_buffer_byte_length::<I>);
        object.get_array_buffer_data = Some(get_array_buffer_data::<I>);
        object.get_function_name = Some(get_function_name::<I>);
        object.get_function_handler = Some(get_function_handler::<I>);
        object.execute_function = Some(execute_function::<I>);
        object.execute_function_with_context = Some(execute_function_with_context::<I>);
        object.resolve_promise = Some(resolve_promise::<I>);
        object.reject_promise = Some(reject_promise::<I>);
    }
    extern "C" fn is_valid<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_undefined<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_undefined(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_null<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_null(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_bool<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_bool(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_int<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_int(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_uint<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_uint(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_double<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_double(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_date<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_date(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_string<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_string(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_object<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_object(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_array<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_array(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_array_buffer<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_array_buffer(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_function<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_function(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_promise<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_promise(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        that: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplV8value::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn get_bool_value<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_bool_value(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_int_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> i32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_int_value(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_uint_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_uint_value(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_double_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_double_value(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_date_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_date_value(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_string_value<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_string_value(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_user_created<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::is_user_created(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_exception<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::has_exception(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_exception<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_v8exception_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_exception(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn clear_exception<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::clear_exception(&arg_self_.interface);
        result.into()
    }
    extern "C" fn will_rethrow_exceptions<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::will_rethrow_exceptions(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_rethrow_exceptions<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        rethrow: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_rethrow) = (self_, rethrow);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_rethrow = arg_rethrow.as_raw();
        let result = ImplV8value::set_rethrow_exceptions(&arg_self_.interface, arg_rethrow);
        result.into()
    }
    extern "C" fn has_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplV8value::has_value_bykey(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn has_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplV8value::has_value_byindex(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn delete_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplV8value::delete_value_bykey(&arg_self_.interface, arg_key);
        result.into()
    }
    extern "C" fn delete_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplV8value::delete_value_byindex(&arg_self_.interface, arg_index);
        result.into()
    }
    extern "C" fn get_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let result = ImplV8value::get_value_bykey(&arg_self_.interface, arg_key);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplV8value::get_value_byindex(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_v8value_t,
        attribute: cef_v8_propertyattribute_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value, arg_attribute) = (self_, key, value, attribute);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let arg_attribute = arg_attribute.as_raw();
        let result =
            ImplV8value::set_value_bykey(&arg_self_.interface, arg_key, arg_value, arg_attribute);
        result.into()
    }
    extern "C" fn set_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
        value: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let result = ImplV8value::set_value_byindex(&arg_self_.interface, arg_index, arg_value);
        result.into()
    }
    extern "C" fn set_value_byaccessor<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
        attribute: cef_v8_propertyattribute_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_attribute) = (self_, key, attribute);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = if arg_key.is_null() {
            None
        } else {
            Some(arg_key.into())
        };
        let arg_key = arg_key.as_ref();
        let arg_attribute = arg_attribute.as_raw();
        let result =
            ImplV8value::set_value_byaccessor(&arg_self_.interface, arg_key, arg_attribute);
        result.into()
    }
    extern "C" fn get_keys<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        keys: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_keys) = (self_, keys);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_keys = if arg_keys.is_null() {
            None
        } else {
            Some(arg_keys.into())
        };
        let arg_keys = arg_keys.as_mut();
        let result = ImplV8value::get_keys(&arg_self_.interface, arg_keys);
        result.into()
    }
    extern "C" fn set_user_data<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        user_data: *mut _cef_base_ref_counted_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_user_data) = (self_, user_data);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_user_data = unsafe { arg_user_data.as_mut() }
            .map(|arg| BaseRefCounted(unsafe { RefGuard::from_raw(arg) }));
        let arg_user_data = arg_user_data.as_mut();
        let result = ImplV8value::set_user_data(&arg_self_.interface, arg_user_data);
        result.into()
    }
    extern "C" fn get_user_data<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_base_ref_counted_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_user_data(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_externally_allocated_memory<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_externally_allocated_memory(&arg_self_.interface);
        result.into()
    }
    extern "C" fn adjust_externally_allocated_memory<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_change_in_bytes) = (self_, change_in_bytes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_change_in_bytes = arg_change_in_bytes.as_raw();
        let result = ImplV8value::adjust_externally_allocated_memory(
            &arg_self_.interface,
            arg_change_in_bytes,
        );
        result.into()
    }
    extern "C" fn get_array_length<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_array_length(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_array_buffer_release_callback<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_v8array_buffer_release_callback_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_array_buffer_release_callback(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn neuter_array_buffer<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::neuter_array_buffer(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_array_buffer_byte_length<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_array_buffer_byte_length(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_array_buffer_data<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut ::std::os::raw::c_void {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_array_buffer_data(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_function_name<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_function_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_function_handler<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_v8handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8value::get_function_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn execute_function<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        object: *mut _cef_v8value_t,
        arguments_count: usize,
        arguments: *const *mut _cef_v8value_t,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_object, arg_arguments_count, arg_arguments) =
            (self_, object, arguments_count, arguments);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let vec_arguments = unsafe { arg_arguments.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_arguments_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(V8value(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_arguments = vec_arguments.as_ref().map(|arg| arg.as_slice());
        let result = ImplV8value::execute_function(&arg_self_.interface, arg_object, arg_arguments);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn execute_function_with_context<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        context: *mut _cef_v8context_t,
        object: *mut _cef_v8value_t,
        arguments_count: usize,
        arguments: *const *mut _cef_v8value_t,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_context, arg_object, arg_arguments_count, arg_arguments) =
            (self_, context, object, arguments_count, arguments);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_context = unsafe { arg_context.as_mut() }
            .map(|arg| V8context(unsafe { RefGuard::from_raw(arg) }));
        let arg_context = arg_context.as_mut();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let vec_arguments = unsafe { arg_arguments.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_arguments_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(V8value(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_arguments = vec_arguments.as_ref().map(|arg| arg.as_slice());
        let result = ImplV8value::execute_function_with_context(
            &arg_self_.interface,
            arg_context,
            arg_object,
            arg_arguments,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn resolve_promise<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        arg: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_arg) = (self_, arg);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_arg =
            unsafe { arg_arg.as_mut() }.map(|arg| V8value(unsafe { RefGuard::from_raw(arg) }));
        let arg_arg = arg_arg.as_mut();
        let result = ImplV8value::resolve_promise(&arg_self_.interface, arg_arg);
        result.into()
    }
    extern "C" fn reject_promise<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        error_msg: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_error_msg) = (self_, error_msg);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_error_msg = if arg_error_msg.is_null() {
            None
        } else {
            Some(arg_error_msg.into())
        };
        let arg_error_msg = arg_error_msg.as_ref();
        let result = ImplV8value::reject_promise(&arg_self_.interface, arg_error_msg);
        result.into()
    }
}
impl ImplV8value for V8value {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_undefined(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_undefined
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_null(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_null
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_bool(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_bool
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_int(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_int
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_uint(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_uint
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_double(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_double
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_date(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_date
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_string(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_object(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_object
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_array(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_array
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_array_buffer(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_array_buffer
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_function(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_function
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_promise(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_promise
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplV8value>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_bool_value(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_int_value(&self) -> i32 {
        unsafe {
            self.0
                .get_int_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_uint_value(&self) -> u32 {
        unsafe {
            self.0
                .get_uint_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_double_value(&self) -> f64 {
        unsafe {
            self.0
                .get_double_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_date_value(&self) -> Basetime {
        unsafe {
            self.0
                .get_date_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_string_value(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_string_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_user_created(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_user_created
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_exception(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_exception
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_exception(&self) -> Option<V8exception> {
        unsafe {
            self.0
                .get_exception
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn clear_exception(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear_exception
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn will_rethrow_exceptions(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .will_rethrow_exceptions
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_rethrow_exceptions(&self, rethrow: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_rethrow_exceptions
                .map(|f| {
                    let arg_rethrow = rethrow;
                    let arg_self_ = self.as_raw();
                    let arg_rethrow = arg_rethrow;
                    let result = f(arg_self_, arg_rethrow);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_value_bykey(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn delete_value_bykey(&self, key: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn delete_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_value_bykey(&self, key: Option<&CefStringUtf16>) -> Option<V8value> {
        unsafe {
            self.0
                .get_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_value_byindex(&self, index: ::std::os::raw::c_int) -> Option<V8value> {
        unsafe {
            self.0
                .get_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_value_bykey(
        &self,
        key: Option<&CefStringUtf16>,
        value: Option<&mut impl ImplV8value>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_bykey
                .map(|f| {
                    let (arg_key, arg_value, arg_attribute) = (key, value, attribute);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_attribute = arg_attribute.as_raw();
                    let result = f(arg_self_, arg_key, arg_value, arg_attribute);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_value_byindex(
        &self,
        index: ::std::os::raw::c_int,
        value: Option<&mut impl ImplV8value>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_byindex
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_value_byaccessor(
        &self,
        key: Option<&CefStringUtf16>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_byaccessor
                .map(|f| {
                    let (arg_key, arg_attribute) = (key, attribute);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_attribute = arg_attribute.as_raw();
                    let result = f(arg_self_, arg_key, arg_attribute);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_keys
                .map(|f| {
                    let arg_keys = keys;
                    let arg_self_ = self.as_raw();
                    let arg_keys = arg_keys
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_keys);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_user_data(&self, user_data: Option<&mut BaseRefCounted>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_user_data
                .map(|f| {
                    let arg_user_data = user_data;
                    let arg_self_ = self.as_raw();
                    let arg_user_data = arg_user_data
                        .map(|arg| {
                            arg.add_ref();
                            arg.as_raw()
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_user_data);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_user_data(&self) -> Option<BaseRefCounted> {
        unsafe {
            self.0
                .get_user_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_externally_allocated_memory(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_externally_allocated_memory
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn adjust_externally_allocated_memory(
        &self,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .adjust_externally_allocated_memory
                .map(|f| {
                    let arg_change_in_bytes = change_in_bytes;
                    let arg_self_ = self.as_raw();
                    let arg_change_in_bytes = arg_change_in_bytes;
                    let result = f(arg_self_, arg_change_in_bytes);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_array_length(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_array_length
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_array_buffer_release_callback(&self) -> Option<V8arrayBufferReleaseCallback> {
        unsafe {
            self.0
                .get_array_buffer_release_callback
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn neuter_array_buffer(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .neuter_array_buffer
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_array_buffer_byte_length(&self) -> usize {
        unsafe {
            self.0
                .get_array_buffer_byte_length
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_array_buffer_data(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            self.0
                .get_array_buffer_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_function_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_function_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_function_handler(&self) -> Option<V8handler> {
        unsafe {
            self.0
                .get_function_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn execute_function(
        &self,
        object: Option<&mut impl ImplV8value>,
        arguments: Option<&[Option<impl ImplV8value>]>,
    ) -> Option<V8value> {
        unsafe {
            self.0
                .execute_function
                .map(|f| {
                    let (arg_object, arg_arguments) = (object, arguments);
                    let arg_self_ = self.as_raw();
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_arguments_count = arg_arguments
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let result = f(arg_self_, arg_object, arg_arguments_count, arg_arguments);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn execute_function_with_context(
        &self,
        context: Option<&mut impl ImplV8context>,
        object: Option<&mut impl ImplV8value>,
        arguments: Option<&[Option<impl ImplV8value>]>,
    ) -> Option<V8value> {
        unsafe {
            self.0
                .execute_function_with_context
                .map(|f| {
                    let (arg_context, arg_object, arg_arguments) = (context, object, arguments);
                    let arg_self_ = self.as_raw();
                    let arg_context = arg_context
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8context::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_arguments_count = arg_arguments
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let result = f(
                        arg_self_,
                        arg_context,
                        arg_object,
                        arg_arguments_count,
                        arg_arguments,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn resolve_promise(&self, arg: Option<&mut impl ImplV8value>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .resolve_promise
                .map(|f| {
                    let arg_arg = arg;
                    let arg_self_ = self.as_raw();
                    let arg_arg = arg_arg
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_arg);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn reject_promise(&self, error_msg: Option<&CefStringUtf16>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .reject_promise
                .map(|f| {
                    let arg_error_msg = error_msg;
                    let arg_self_ = self.as_raw();
                    let arg_error_msg = arg_error_msg
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_error_msg);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8value_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8value {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8value_t> for &V8value {
    fn as_raw(self) -> *mut _cef_v8value_t {
        ImplV8value::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8value_t> for &mut V8value {
    fn as_raw(self) -> *mut _cef_v8value_t {
        ImplV8value::get_raw(self)
    }
}
impl ConvertReturnValue<V8value> for *mut _cef_v8value_t {
    fn as_wrapper(self) -> V8value {
        V8value(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8value_t> for V8value {
    fn into(self) -> *mut _cef_v8value_t {
        let object = ImplV8value::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8value {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8stack_trace_t] for more documentation.
#[derive(Clone)]
pub struct V8stackTrace(RefGuard<_cef_v8stack_trace_t>);
impl V8stackTrace {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8stackTrace,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8stackTrace>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8stackTrace>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8stack_trace_t).as_wrapper()
        }
    }
}
pub trait WrapV8stackTrace: ImplV8stackTrace {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8stack_trace_t, Self>);
}
pub trait ImplV8stackTrace: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_frame_count(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_frame(&self, index: ::std::os::raw::c_int) -> Option<V8stackFrame> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8stack_trace_t) {
        impl_cef_v8stack_trace_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8stack_trace_t;
}
mod impl_cef_v8stack_trace_t {
    use super::*;
    pub fn init_methods<I: ImplV8stackTrace>(object: &mut _cef_v8stack_trace_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_frame_count = Some(get_frame_count::<I>);
        object.get_frame = Some(get_frame::<I>);
    }
    extern "C" fn is_valid<I: ImplV8stackTrace>(
        self_: *mut _cef_v8stack_trace_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackTrace::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_frame_count<I: ImplV8stackTrace>(
        self_: *mut _cef_v8stack_trace_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackTrace::get_frame_count(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_frame<I: ImplV8stackTrace>(
        self_: *mut _cef_v8stack_trace_t,
        index: ::std::os::raw::c_int,
    ) -> *mut _cef_v8stack_frame_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplV8stackTrace::get_frame(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplV8stackTrace for V8stackTrace {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_frame_count(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_frame_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_frame(&self, index: ::std::os::raw::c_int) -> Option<V8stackFrame> {
        unsafe {
            self.0
                .get_frame
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8stack_trace_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8stack_trace_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8stackTrace {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8stack_trace_t> for &V8stackTrace {
    fn as_raw(self) -> *mut _cef_v8stack_trace_t {
        ImplV8stackTrace::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8stack_trace_t> for &mut V8stackTrace {
    fn as_raw(self) -> *mut _cef_v8stack_trace_t {
        ImplV8stackTrace::get_raw(self)
    }
}
impl ConvertReturnValue<V8stackTrace> for *mut _cef_v8stack_trace_t {
    fn as_wrapper(self) -> V8stackTrace {
        V8stackTrace(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8stack_trace_t> for V8stackTrace {
    fn into(self) -> *mut _cef_v8stack_trace_t {
        let object = ImplV8stackTrace::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8stackTrace {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_v8stack_frame_t] for more documentation.
#[derive(Clone)]
pub struct V8stackFrame(RefGuard<_cef_v8stack_frame_t>);
impl V8stackFrame {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8stackFrame,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8stackFrame>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8stackFrame>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_v8stack_frame_t).as_wrapper()
        }
    }
}
pub trait WrapV8stackFrame: ImplV8stackFrame {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8stack_frame_t, Self>);
}
pub trait ImplV8stackFrame: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_script_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_script_name_or_source_url(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_function_name(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn get_line_number(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_column(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_eval(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_constructor(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8stack_frame_t) {
        impl_cef_v8stack_frame_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8stack_frame_t;
}
mod impl_cef_v8stack_frame_t {
    use super::*;
    pub fn init_methods<I: ImplV8stackFrame>(object: &mut _cef_v8stack_frame_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_script_name = Some(get_script_name::<I>);
        object.get_script_name_or_source_url = Some(get_script_name_or_source_url::<I>);
        object.get_function_name = Some(get_function_name::<I>);
        object.get_line_number = Some(get_line_number::<I>);
        object.get_column = Some(get_column::<I>);
        object.is_eval = Some(is_eval::<I>);
        object.is_constructor = Some(is_constructor::<I>);
    }
    extern "C" fn is_valid<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_script_name<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::get_script_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_script_name_or_source_url<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::get_script_name_or_source_url(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_function_name<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::get_function_name(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_line_number<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::get_line_number(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_column<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::get_column(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_eval<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::is_eval(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_constructor<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplV8stackFrame::is_constructor(&arg_self_.interface);
        result.into()
    }
}
impl ImplV8stackFrame for V8stackFrame {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_script_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_script_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_script_name_or_source_url(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_script_name_or_source_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_function_name(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_function_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_line_number(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_line_number
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_column(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_column
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_eval(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_eval
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_constructor(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_constructor
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8stack_frame_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_v8stack_frame_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8stackFrame {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8stack_frame_t> for &V8stackFrame {
    fn as_raw(self) -> *mut _cef_v8stack_frame_t {
        ImplV8stackFrame::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8stack_frame_t> for &mut V8stackFrame {
    fn as_raw(self) -> *mut _cef_v8stack_frame_t {
        ImplV8stackFrame::get_raw(self)
    }
}
impl ConvertReturnValue<V8stackFrame> for *mut _cef_v8stack_frame_t {
    fn as_wrapper(self) -> V8stackFrame {
        V8stackFrame(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8stack_frame_t> for V8stackFrame {
    fn into(self) -> *mut _cef_v8stack_frame_t {
        let object = ImplV8stackFrame::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for V8stackFrame {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_render_process_handler_t] for more documentation.
#[derive(Clone)]
pub struct RenderProcessHandler(RefGuard<_cef_render_process_handler_t>);
impl RenderProcessHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRenderProcessHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRenderProcessHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRenderProcessHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_render_process_handler_t).as_wrapper()
        }
    }
}
pub trait WrapRenderProcessHandler: ImplRenderProcessHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_render_process_handler_t, Self>);
}
pub trait ImplRenderProcessHandler: Clone + Sized + Rc {
    fn on_web_kit_initialized(&self) {}
    fn on_browser_created(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        extra_info: Option<&mut impl ImplDictionaryValue>,
    ) {
    }
    fn on_browser_destroyed(&self, browser: Option<&mut impl ImplBrowser>) {}
    fn get_load_handler(&self) -> Option<LoadHandler> {
        Default::default()
    }
    fn on_context_created(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        context: Option<&mut impl ImplV8context>,
    ) {
    }
    fn on_context_released(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        context: Option<&mut impl ImplV8context>,
    ) {
    }
    fn on_uncaught_exception(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        context: Option<&mut impl ImplV8context>,
        exception: Option<&mut impl ImplV8exception>,
        stack_trace: Option<&mut impl ImplV8stackTrace>,
    ) {
    }
    fn on_focused_node_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        node: Option<&mut impl ImplDomnode>,
    ) {
    }
    fn on_process_message_received(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        source_process: ProcessId,
        message: Option<&mut impl ImplProcessMessage>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_render_process_handler_t) {
        impl_cef_render_process_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_render_process_handler_t;
}
mod impl_cef_render_process_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRenderProcessHandler>(object: &mut _cef_render_process_handler_t) {
        object.on_web_kit_initialized = Some(on_web_kit_initialized::<I>);
        object.on_browser_created = Some(on_browser_created::<I>);
        object.on_browser_destroyed = Some(on_browser_destroyed::<I>);
        object.get_load_handler = Some(get_load_handler::<I>);
        object.on_context_created = Some(on_context_created::<I>);
        object.on_context_released = Some(on_context_released::<I>);
        object.on_uncaught_exception = Some(on_uncaught_exception::<I>);
        object.on_focused_node_changed = Some(on_focused_node_changed::<I>);
        object.on_process_message_received = Some(on_process_message_received::<I>);
    }
    extern "C" fn on_web_kit_initialized<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRenderProcessHandler::on_web_kit_initialized(&arg_self_.interface);
    }
    extern "C" fn on_browser_created<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        extra_info: *mut _cef_dictionary_value_t,
    ) {
        let (arg_self_, arg_browser, arg_extra_info) = (self_, browser, extra_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_extra_info = unsafe { arg_extra_info.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_extra_info = arg_extra_info.as_mut();
        let result = ImplRenderProcessHandler::on_browser_created(
            &arg_self_.interface,
            arg_browser,
            arg_extra_info,
        );
    }
    extern "C" fn on_browser_destroyed<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result =
            ImplRenderProcessHandler::on_browser_destroyed(&arg_self_.interface, arg_browser);
    }
    extern "C" fn get_load_handler<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
    ) -> *mut _cef_load_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRenderProcessHandler::get_load_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_context_created<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8context_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context) = (self_, browser, frame, context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_context = unsafe { arg_context.as_mut() }
            .map(|arg| V8context(unsafe { RefGuard::from_raw(arg) }));
        let arg_context = arg_context.as_mut();
        let result = ImplRenderProcessHandler::on_context_created(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_context,
        );
    }
    extern "C" fn on_context_released<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8context_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context) = (self_, browser, frame, context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_context = unsafe { arg_context.as_mut() }
            .map(|arg| V8context(unsafe { RefGuard::from_raw(arg) }));
        let arg_context = arg_context.as_mut();
        let result = ImplRenderProcessHandler::on_context_released(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_context,
        );
    }
    extern "C" fn on_uncaught_exception<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8context_t,
        exception: *mut _cef_v8exception_t,
        stack_trace: *mut _cef_v8stack_trace_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context, arg_exception, arg_stack_trace) =
            (self_, browser, frame, context, exception, stack_trace);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_context = unsafe { arg_context.as_mut() }
            .map(|arg| V8context(unsafe { RefGuard::from_raw(arg) }));
        let arg_context = arg_context.as_mut();
        let mut arg_exception = unsafe { arg_exception.as_mut() }
            .map(|arg| V8exception(unsafe { RefGuard::from_raw(arg) }));
        let arg_exception = arg_exception.as_mut();
        let mut arg_stack_trace = unsafe { arg_stack_trace.as_mut() }
            .map(|arg| V8stackTrace(unsafe { RefGuard::from_raw(arg) }));
        let arg_stack_trace = arg_stack_trace.as_mut();
        let result = ImplRenderProcessHandler::on_uncaught_exception(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_context,
            arg_exception,
            arg_stack_trace,
        );
    }
    extern "C" fn on_focused_node_changed<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        node: *mut _cef_domnode_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_node) = (self_, browser, frame, node);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_node =
            unsafe { arg_node.as_mut() }.map(|arg| Domnode(unsafe { RefGuard::from_raw(arg) }));
        let arg_node = arg_node.as_mut();
        let result = ImplRenderProcessHandler::on_focused_node_changed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_node,
        );
    }
    extern "C" fn on_process_message_received<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        source_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_source_process, arg_message) =
            (self_, browser, frame, source_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_source_process = arg_source_process.as_raw();
        let mut arg_message = unsafe { arg_message.as_mut() }
            .map(|arg| ProcessMessage(unsafe { RefGuard::from_raw(arg) }));
        let arg_message = arg_message.as_mut();
        let result = ImplRenderProcessHandler::on_process_message_received(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_source_process,
            arg_message,
        );
        result.into()
    }
}
impl ImplRenderProcessHandler for RenderProcessHandler {
    fn on_web_kit_initialized(&self) {
        unsafe {
            self.0
                .on_web_kit_initialized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_browser_created(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        extra_info: Option<&mut impl ImplDictionaryValue>,
    ) {
        unsafe {
            self.0
                .on_browser_created
                .map(|f| {
                    let (arg_browser, arg_extra_info) = (browser, extra_info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_extra_info = arg_extra_info
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_extra_info);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_browser_destroyed(&self, browser: Option<&mut impl ImplBrowser>) {
        unsafe {
            self.0
                .on_browser_destroyed
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_load_handler(&self) -> Option<LoadHandler> {
        unsafe {
            self.0
                .get_load_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_context_created(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        context: Option<&mut impl ImplV8context>,
    ) {
        unsafe {
            self.0
                .on_context_created
                .map(|f| {
                    let (arg_browser, arg_frame, arg_context) = (browser, frame, context);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_context = arg_context
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8context::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_context);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_context_released(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        context: Option<&mut impl ImplV8context>,
    ) {
        unsafe {
            self.0
                .on_context_released
                .map(|f| {
                    let (arg_browser, arg_frame, arg_context) = (browser, frame, context);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_context = arg_context
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8context::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_context);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_uncaught_exception(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        context: Option<&mut impl ImplV8context>,
        exception: Option<&mut impl ImplV8exception>,
        stack_trace: Option<&mut impl ImplV8stackTrace>,
    ) {
        unsafe {
            self.0
                .on_uncaught_exception
                .map(|f| {
                    let (arg_browser, arg_frame, arg_context, arg_exception, arg_stack_trace) =
                        (browser, frame, context, exception, stack_trace);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_context = arg_context
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8context::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8exception::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_stack_trace = arg_stack_trace
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8stackTrace::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_context,
                        arg_exception,
                        arg_stack_trace,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_focused_node_changed(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        node: Option<&mut impl ImplDomnode>,
    ) {
        unsafe {
            self.0
                .on_focused_node_changed
                .map(|f| {
                    let (arg_browser, arg_frame, arg_node) = (browser, frame, node);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_node = arg_node
                        .map(|arg| {
                            arg.add_ref();
                            ImplDomnode::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_node);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_process_message_received(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        source_process: ProcessId,
        message: Option<&mut impl ImplProcessMessage>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_process_message_received
                .map(|f| {
                    let (arg_browser, arg_frame, arg_source_process, arg_message) =
                        (browser, frame, source_process, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_source_process = arg_source_process.as_raw();
                    let arg_message = arg_message
                        .map(|arg| {
                            arg.add_ref();
                            ImplProcessMessage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_source_process,
                        arg_message,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_render_process_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_render_process_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RenderProcessHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_render_process_handler_t> for &RenderProcessHandler {
    fn as_raw(self) -> *mut _cef_render_process_handler_t {
        ImplRenderProcessHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_render_process_handler_t> for &mut RenderProcessHandler {
    fn as_raw(self) -> *mut _cef_render_process_handler_t {
        ImplRenderProcessHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RenderProcessHandler> for *mut _cef_render_process_handler_t {
    fn as_wrapper(self) -> RenderProcessHandler {
        RenderProcessHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_render_process_handler_t> for RenderProcessHandler {
    fn into(self) -> *mut _cef_render_process_handler_t {
        let object = ImplRenderProcessHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for RenderProcessHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_resource_bundle_handler_t] for more documentation.
#[derive(Clone)]
pub struct ResourceBundleHandler(RefGuard<_cef_resource_bundle_handler_t>);
impl ResourceBundleHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceBundleHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceBundleHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceBundleHandler>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_resource_bundle_handler_t).as_wrapper()
        }
    }
}
pub trait WrapResourceBundleHandler: ImplResourceBundleHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_bundle_handler_t, Self>);
}
pub trait ImplResourceBundleHandler: Clone + Sized + Rc {
    fn get_localized_string(
        &self,
        string_id: ::std::os::raw::c_int,
        string: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_data_resource(
        &self,
        resource_id: ::std::os::raw::c_int,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_data_resource_for_scale(
        &self,
        resource_id: ::std::os::raw::c_int,
        scale_factor: ScaleFactor,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_resource_bundle_handler_t) {
        impl_cef_resource_bundle_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_bundle_handler_t;
}
mod impl_cef_resource_bundle_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceBundleHandler>(object: &mut _cef_resource_bundle_handler_t) {
        object.get_localized_string = Some(get_localized_string::<I>);
        object.get_data_resource = Some(get_data_resource::<I>);
        object.get_data_resource_for_scale = Some(get_data_resource_for_scale::<I>);
    }
    extern "C" fn get_localized_string<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        string_id: ::std::os::raw::c_int,
        string: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_string_id, arg_string) = (self_, string_id, string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_string_id = arg_string_id.as_raw();
        let mut arg_string = if arg_string.is_null() {
            None
        } else {
            Some(arg_string.into())
        };
        let arg_string = arg_string.as_mut();
        let result = ImplResourceBundleHandler::get_localized_string(
            &arg_self_.interface,
            arg_string_id,
            arg_string,
        );
        result.into()
    }
    extern "C" fn get_data_resource<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        resource_id: ::std::os::raw::c_int,
        data: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_resource_id, arg_data, arg_data_size) =
            (self_, resource_id, data, data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_resource_id = arg_resource_id.as_raw();
        let out_data_size = unsafe { arg_data_size.as_mut() };
        let arg_data_size = out_data_size
            .as_ref()
            .map(|size| **size)
            .unwrap_or_default();
        let out_data = (!arg_data.is_null() && arg_data_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts_mut(arg_data as *mut _, arg_data_size) });
        let mut vec_data = out_data.as_ref().map(|arg| arg.to_vec());
        let arg_data = vec_data.as_mut();
        let result = ImplResourceBundleHandler::get_data_resource(
            &arg_self_.interface,
            arg_resource_id,
            arg_data,
        );
        if let (Some(out_data_size), Some(out_data), Some(vec_data)) =
            (out_data_size, out_data, vec_data.as_mut())
        {
            *out_data_size = vec_data.len().min(*out_data_size);
            out_data[..(*out_data_size)].copy_from_slice(&vec_data[..(*out_data_size)]);
        }
        result.into()
    }
    extern "C" fn get_data_resource_for_scale<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        resource_id: ::std::os::raw::c_int,
        scale_factor: cef_scale_factor_t,
        data: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_resource_id, arg_scale_factor, arg_data, arg_data_size) =
            (self_, resource_id, scale_factor, data, data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_resource_id = arg_resource_id.as_raw();
        let arg_scale_factor = arg_scale_factor.as_raw();
        let out_data_size = unsafe { arg_data_size.as_mut() };
        let arg_data_size = out_data_size
            .as_ref()
            .map(|size| **size)
            .unwrap_or_default();
        let out_data = (!arg_data.is_null() && arg_data_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts_mut(arg_data as *mut _, arg_data_size) });
        let mut vec_data = out_data.as_ref().map(|arg| arg.to_vec());
        let arg_data = vec_data.as_mut();
        let result = ImplResourceBundleHandler::get_data_resource_for_scale(
            &arg_self_.interface,
            arg_resource_id,
            arg_scale_factor,
            arg_data,
        );
        if let (Some(out_data_size), Some(out_data), Some(vec_data)) =
            (out_data_size, out_data, vec_data.as_mut())
        {
            *out_data_size = vec_data.len().min(*out_data_size);
            out_data[..(*out_data_size)].copy_from_slice(&vec_data[..(*out_data_size)]);
        }
        result.into()
    }
}
impl ImplResourceBundleHandler for ResourceBundleHandler {
    fn get_localized_string(
        &self,
        string_id: ::std::os::raw::c_int,
        string: Option<&mut CefStringUtf16>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_localized_string
                .map(|f| {
                    let (arg_string_id, arg_string) = (string_id, string);
                    let arg_self_ = self.as_raw();
                    let arg_string_id = arg_string_id;
                    let arg_string = arg_string
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_string_id, arg_string);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_data_resource(
        &self,
        resource_id: ::std::os::raw::c_int,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_data_resource
                .map(|f| {
                    let (arg_resource_id, arg_data) = (resource_id, data);
                    let arg_self_ = self.as_raw();
                    let arg_resource_id = arg_resource_id;
                    let mut out_data_size =
                        arg_data.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_data_size = &mut out_data_size;
                    let mut out_data = arg_data;
                    let arg_data = out_data
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_resource_id, arg_data, arg_data_size);
                    if let Some(out_data) = out_data {
                        out_data.resize(out_data_size, Default::default());
                    }
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_data_resource_for_scale(
        &self,
        resource_id: ::std::os::raw::c_int,
        scale_factor: ScaleFactor,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_data_resource_for_scale
                .map(|f| {
                    let (arg_resource_id, arg_scale_factor, arg_data) =
                        (resource_id, scale_factor, data);
                    let arg_self_ = self.as_raw();
                    let arg_resource_id = arg_resource_id;
                    let arg_scale_factor = arg_scale_factor.as_raw();
                    let mut out_data_size =
                        arg_data.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_data_size = &mut out_data_size;
                    let mut out_data = arg_data;
                    let arg_data = out_data
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_resource_id,
                        arg_scale_factor,
                        arg_data,
                        arg_data_size,
                    );
                    if let Some(out_data) = out_data {
                        out_data.resize(out_data_size, Default::default());
                    }
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_bundle_handler_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_resource_bundle_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceBundleHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_bundle_handler_t> for &ResourceBundleHandler {
    fn as_raw(self) -> *mut _cef_resource_bundle_handler_t {
        ImplResourceBundleHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_bundle_handler_t> for &mut ResourceBundleHandler {
    fn as_raw(self) -> *mut _cef_resource_bundle_handler_t {
        ImplResourceBundleHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceBundleHandler> for *mut _cef_resource_bundle_handler_t {
    fn as_wrapper(self) -> ResourceBundleHandler {
        ResourceBundleHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_bundle_handler_t> for ResourceBundleHandler {
    fn into(self) -> *mut _cef_resource_bundle_handler_t {
        let object = ImplResourceBundleHandler::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ResourceBundleHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_scheme_registrar_t] for more documentation.
#[derive(Clone, Copy)]
pub struct SchemeRegistrar(*mut _cef_scheme_registrar_t);
pub trait ImplSchemeRegistrar: Sized {
    fn add_custom_scheme(
        &self,
        scheme_name: Option<&CefStringUtf16>,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    fn init_methods(object: &mut _cef_scheme_registrar_t) {
        impl_cef_scheme_registrar_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_scheme_registrar_t;
}
mod impl_cef_scheme_registrar_t {
    use super::*;
    pub fn init_methods<I: ImplSchemeRegistrar>(object: &mut _cef_scheme_registrar_t) {
        object.add_custom_scheme = Some(add_custom_scheme::<I>);
    }
    extern "C" fn add_custom_scheme<I: ImplSchemeRegistrar>(
        self_: *mut _cef_scheme_registrar_t,
        scheme_name: *const _cef_string_utf16_t,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scheme_name, arg_options) = (self_, scheme_name, options);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scheme_name = if arg_scheme_name.is_null() {
            None
        } else {
            Some(arg_scheme_name.into())
        };
        let arg_scheme_name = arg_scheme_name.as_ref();
        let arg_options = arg_options.as_raw();
        let result = ImplSchemeRegistrar::add_custom_scheme(
            &arg_self_.interface,
            arg_scheme_name,
            arg_options,
        );
        result.into()
    }
}
impl ImplSchemeRegistrar for SchemeRegistrar {
    fn add_custom_scheme(
        &self,
        scheme_name: Option<&CefStringUtf16>,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .as_ref()
                .and_then(|this| this.add_custom_scheme)
                .map(|f| {
                    let (arg_scheme_name, arg_options) = (scheme_name, options);
                    let arg_self_ = self.as_raw();
                    let arg_scheme_name = arg_scheme_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_options = arg_options;
                    let result = f(arg_self_, arg_scheme_name, arg_options);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_scheme_registrar_t {
        self.0
    }
}
impl ConvertParam<*mut _cef_scheme_registrar_t> for &SchemeRegistrar {
    fn as_raw(self) -> *mut _cef_scheme_registrar_t {
        ImplSchemeRegistrar::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_scheme_registrar_t> for &mut SchemeRegistrar {
    fn as_raw(self) -> *mut _cef_scheme_registrar_t {
        ImplSchemeRegistrar::get_raw(self)
    }
}
impl ConvertReturnValue<SchemeRegistrar> for *mut _cef_scheme_registrar_t {
    fn as_wrapper(self) -> SchemeRegistrar {
        SchemeRegistrar(self)
    }
}
impl Into<*mut _cef_scheme_registrar_t> for SchemeRegistrar {
    fn into(self) -> *mut _cef_scheme_registrar_t {
        ImplSchemeRegistrar::get_raw(&self)
    }
}
impl Default for SchemeRegistrar {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

/// See [_cef_scheme_handler_factory_t] for more documentation.
#[derive(Clone)]
pub struct SchemeHandlerFactory(RefGuard<_cef_scheme_handler_factory_t>);
impl SchemeHandlerFactory {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSchemeHandlerFactory,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSchemeHandlerFactory>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSchemeHandlerFactory>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_scheme_handler_factory_t).as_wrapper()
        }
    }
}
pub trait WrapSchemeHandlerFactory: ImplSchemeHandlerFactory {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_scheme_handler_factory_t, Self>);
}
pub trait ImplSchemeHandlerFactory: Clone + Sized + Rc {
    fn create(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        scheme_name: Option<&CefStringUtf16>,
        request: Option<&mut impl ImplRequest>,
    ) -> Option<ResourceHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_scheme_handler_factory_t) {
        impl_cef_scheme_handler_factory_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_scheme_handler_factory_t;
}
mod impl_cef_scheme_handler_factory_t {
    use super::*;
    pub fn init_methods<I: ImplSchemeHandlerFactory>(object: &mut _cef_scheme_handler_factory_t) {
        object.create = Some(create::<I>);
    }
    extern "C" fn create<I: ImplSchemeHandlerFactory>(
        self_: *mut _cef_scheme_handler_factory_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        scheme_name: *const _cef_string_utf16_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_resource_handler_t {
        let (arg_self_, arg_browser, arg_frame, arg_scheme_name, arg_request) =
            (self_, browser, frame, scheme_name, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_scheme_name = if arg_scheme_name.is_null() {
            None
        } else {
            Some(arg_scheme_name.into())
        };
        let arg_scheme_name = arg_scheme_name.as_ref();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplSchemeHandlerFactory::create(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_scheme_name,
            arg_request,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplSchemeHandlerFactory for SchemeHandlerFactory {
    fn create(
        &self,
        browser: Option<&mut impl ImplBrowser>,
        frame: Option<&mut impl ImplFrame>,
        scheme_name: Option<&CefStringUtf16>,
        request: Option<&mut impl ImplRequest>,
    ) -> Option<ResourceHandler> {
        unsafe {
            self.0
                .create
                .map(|f| {
                    let (arg_browser, arg_frame, arg_scheme_name, arg_request) =
                        (browser, frame, scheme_name, request);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_scheme_name = arg_scheme_name
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_scheme_name,
                        arg_request,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_scheme_handler_factory_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_scheme_handler_factory_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SchemeHandlerFactory {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_scheme_handler_factory_t> for &SchemeHandlerFactory {
    fn as_raw(self) -> *mut _cef_scheme_handler_factory_t {
        ImplSchemeHandlerFactory::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_scheme_handler_factory_t> for &mut SchemeHandlerFactory {
    fn as_raw(self) -> *mut _cef_scheme_handler_factory_t {
        ImplSchemeHandlerFactory::get_raw(self)
    }
}
impl ConvertReturnValue<SchemeHandlerFactory> for *mut _cef_scheme_handler_factory_t {
    fn as_wrapper(self) -> SchemeHandlerFactory {
        SchemeHandlerFactory(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_scheme_handler_factory_t> for SchemeHandlerFactory {
    fn into(self) -> *mut _cef_scheme_handler_factory_t {
        let object = ImplSchemeHandlerFactory::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for SchemeHandlerFactory {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_app_t] for more documentation.
#[derive(Clone)]
pub struct App(RefGuard<_cef_app_t>);
impl App {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapApp,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplApp>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapApp>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_app_t).as_wrapper()
        }
    }
}
pub trait WrapApp: ImplApp {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_app_t, Self>);
}
pub trait ImplApp: Clone + Sized + Rc {
    fn on_before_command_line_processing(
        &self,
        process_type: Option<&CefStringUtf16>,
        command_line: Option<&mut impl ImplCommandLine>,
    ) {
    }
    fn on_register_custom_schemes(&self, registrar: Option<&mut SchemeRegistrar>) {}
    fn get_resource_bundle_handler(&self) -> Option<ResourceBundleHandler> {
        Default::default()
    }
    fn get_browser_process_handler(&self) -> Option<BrowserProcessHandler> {
        Default::default()
    }
    fn get_render_process_handler(&self) -> Option<RenderProcessHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_app_t) {
        impl_cef_app_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_app_t;
}
mod impl_cef_app_t {
    use super::*;
    pub fn init_methods<I: ImplApp>(object: &mut _cef_app_t) {
        object.on_before_command_line_processing = Some(on_before_command_line_processing::<I>);
        object.on_register_custom_schemes = Some(on_register_custom_schemes::<I>);
        object.get_resource_bundle_handler = Some(get_resource_bundle_handler::<I>);
        object.get_browser_process_handler = Some(get_browser_process_handler::<I>);
        object.get_render_process_handler = Some(get_render_process_handler::<I>);
    }
    extern "C" fn on_before_command_line_processing<I: ImplApp>(
        self_: *mut _cef_app_t,
        process_type: *const _cef_string_utf16_t,
        command_line: *mut _cef_command_line_t,
    ) {
        let (arg_self_, arg_process_type, arg_command_line) = (self_, process_type, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_process_type = if arg_process_type.is_null() {
            None
        } else {
            Some(arg_process_type.into())
        };
        let arg_process_type = arg_process_type.as_ref();
        let mut arg_command_line = unsafe { arg_command_line.as_mut() }
            .map(|arg| CommandLine(unsafe { RefGuard::from_raw(arg) }));
        let arg_command_line = arg_command_line.as_mut();
        let result = ImplApp::on_before_command_line_processing(
            &arg_self_.interface,
            arg_process_type,
            arg_command_line,
        );
    }
    extern "C" fn on_register_custom_schemes<I: ImplApp>(
        self_: *mut _cef_app_t,
        registrar: *mut _cef_scheme_registrar_t,
    ) {
        let (arg_self_, arg_registrar) = (self_, registrar);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_registrar = if arg_registrar.is_null() {
            None
        } else {
            Some(SchemeRegistrar(arg_registrar))
        };
        let arg_registrar = arg_registrar.as_mut();
        let result = ImplApp::on_register_custom_schemes(&arg_self_.interface, arg_registrar);
    }
    extern "C" fn get_resource_bundle_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_resource_bundle_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplApp::get_resource_bundle_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_browser_process_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_browser_process_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplApp::get_browser_process_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_render_process_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_render_process_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplApp::get_render_process_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplApp for App {
    fn on_before_command_line_processing(
        &self,
        process_type: Option<&CefStringUtf16>,
        command_line: Option<&mut impl ImplCommandLine>,
    ) {
        unsafe {
            self.0
                .on_before_command_line_processing
                .map(|f| {
                    let (arg_process_type, arg_command_line) = (process_type, command_line);
                    let arg_self_ = self.as_raw();
                    let arg_process_type = arg_process_type
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_command_line = arg_command_line
                        .map(|arg| {
                            arg.add_ref();
                            ImplCommandLine::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_process_type, arg_command_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_register_custom_schemes(&self, registrar: Option<&mut SchemeRegistrar>) {
        unsafe {
            self.0
                .on_register_custom_schemes
                .map(|f| {
                    let arg_registrar = registrar;
                    let arg_self_ = self.as_raw();
                    let arg_registrar = arg_registrar
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_registrar);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_bundle_handler(&self) -> Option<ResourceBundleHandler> {
        unsafe {
            self.0
                .get_resource_bundle_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_browser_process_handler(&self) -> Option<BrowserProcessHandler> {
        unsafe {
            self.0
                .get_browser_process_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_render_process_handler(&self) -> Option<RenderProcessHandler> {
        unsafe {
            self.0
                .get_render_process_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_app_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_app_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for App {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_app_t> for &App {
    fn as_raw(self) -> *mut _cef_app_t {
        ImplApp::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_app_t> for &mut App {
    fn as_raw(self) -> *mut _cef_app_t {
        ImplApp::get_raw(self)
    }
}
impl ConvertReturnValue<App> for *mut _cef_app_t {
    fn as_wrapper(self) -> App {
        App(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_app_t> for App {
    fn into(self) -> *mut _cef_app_t {
        let object = ImplApp::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for App {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_urlrequest_t] for more documentation.
#[derive(Clone)]
pub struct Urlrequest(RefGuard<_cef_urlrequest_t>);
impl Urlrequest {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapUrlrequest,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplUrlrequest>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapUrlrequest>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_urlrequest_t).as_wrapper()
        }
    }
}
pub trait WrapUrlrequest: ImplUrlrequest {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_urlrequest_t, Self>);
}
pub trait ImplUrlrequest: Clone + Sized + Rc {
    fn get_request(&self) -> Option<Request> {
        Default::default()
    }
    fn get_client(&self) -> Option<UrlrequestClient> {
        Default::default()
    }
    fn get_request_status(&self) -> UrlrequestStatus {
        Default::default()
    }
    fn get_request_error(&self) -> Errorcode {
        Default::default()
    }
    fn get_response(&self) -> Option<Response> {
        Default::default()
    }
    fn response_was_cached(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_urlrequest_t) {
        impl_cef_urlrequest_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_urlrequest_t;
}
mod impl_cef_urlrequest_t {
    use super::*;
    pub fn init_methods<I: ImplUrlrequest>(object: &mut _cef_urlrequest_t) {
        object.get_request = Some(get_request::<I>);
        object.get_client = Some(get_client::<I>);
        object.get_request_status = Some(get_request_status::<I>);
        object.get_request_error = Some(get_request_error::<I>);
        object.get_response = Some(get_response::<I>);
        object.response_was_cached = Some(response_was_cached::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn get_request<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> *mut _cef_request_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUrlrequest::get_request(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_client<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> *mut _cef_urlrequest_client_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUrlrequest::get_client(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_request_status<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> cef_urlrequest_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUrlrequest::get_request_status(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_request_error<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> cef_errorcode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUrlrequest::get_request_error(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_response<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> *mut _cef_response_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUrlrequest::get_response(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn response_was_cached<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUrlrequest::response_was_cached(&arg_self_.interface);
        result.into()
    }
    extern "C" fn cancel<I: ImplUrlrequest>(self_: *mut _cef_urlrequest_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplUrlrequest::cancel(&arg_self_.interface);
    }
}
impl ImplUrlrequest for Urlrequest {
    fn get_request(&self) -> Option<Request> {
        unsafe {
            self.0
                .get_request
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_client(&self) -> Option<UrlrequestClient> {
        unsafe {
            self.0
                .get_client
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_request_status(&self) -> UrlrequestStatus {
        unsafe {
            self.0
                .get_request_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_request_error(&self) -> Errorcode {
        unsafe {
            self.0
                .get_request_error
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_response(&self) -> Option<Response> {
        unsafe {
            self.0
                .get_response
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn response_was_cached(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .response_was_cached
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn cancel(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_urlrequest_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_urlrequest_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Urlrequest {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_urlrequest_t> for &Urlrequest {
    fn as_raw(self) -> *mut _cef_urlrequest_t {
        ImplUrlrequest::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_urlrequest_t> for &mut Urlrequest {
    fn as_raw(self) -> *mut _cef_urlrequest_t {
        ImplUrlrequest::get_raw(self)
    }
}
impl ConvertReturnValue<Urlrequest> for *mut _cef_urlrequest_t {
    fn as_wrapper(self) -> Urlrequest {
        Urlrequest(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_urlrequest_t> for Urlrequest {
    fn into(self) -> *mut _cef_urlrequest_t {
        let object = ImplUrlrequest::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Urlrequest {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_urlrequest_client_t] for more documentation.
#[derive(Clone)]
pub struct UrlrequestClient(RefGuard<_cef_urlrequest_client_t>);
impl UrlrequestClient {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapUrlrequestClient,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplUrlrequestClient>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapUrlrequestClient>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_urlrequest_client_t).as_wrapper()
        }
    }
}
pub trait WrapUrlrequestClient: ImplUrlrequestClient {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_urlrequest_client_t, Self>);
}
pub trait ImplUrlrequestClient: Clone + Sized + Rc {
    fn on_request_complete(&self, request: Option<&mut impl ImplUrlrequest>) {}
    fn on_upload_progress(
        &self,
        request: Option<&mut impl ImplUrlrequest>,
        current: i64,
        total: i64,
    ) {
    }
    fn on_download_progress(
        &self,
        request: Option<&mut impl ImplUrlrequest>,
        current: i64,
        total: i64,
    ) {
    }
    fn on_download_data(
        &self,
        request: Option<&mut impl ImplUrlrequest>,
        data: *const u8,
        data_length: usize,
    ) {
    }
    fn get_auth_credentials(
        &self,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefStringUtf16>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefStringUtf16>,
        scheme: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplAuthCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_urlrequest_client_t) {
        impl_cef_urlrequest_client_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_urlrequest_client_t;
}
mod impl_cef_urlrequest_client_t {
    use super::*;
    pub fn init_methods<I: ImplUrlrequestClient>(object: &mut _cef_urlrequest_client_t) {
        object.on_request_complete = Some(on_request_complete::<I>);
        object.on_upload_progress = Some(on_upload_progress::<I>);
        object.on_download_progress = Some(on_download_progress::<I>);
        object.on_download_data = Some(on_download_data::<I>);
        object.get_auth_credentials = Some(get_auth_credentials::<I>);
    }
    extern "C" fn on_request_complete<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
    ) {
        let (arg_self_, arg_request) = (self_, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplUrlrequestClient::on_request_complete(&arg_self_.interface, arg_request);
    }
    extern "C" fn on_upload_progress<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        current: i64,
        total: i64,
    ) {
        let (arg_self_, arg_request, arg_current, arg_total) = (self_, request, current, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_current = arg_current.as_raw();
        let arg_total = arg_total.as_raw();
        let result = ImplUrlrequestClient::on_upload_progress(
            &arg_self_.interface,
            arg_request,
            arg_current,
            arg_total,
        );
    }
    extern "C" fn on_download_progress<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        current: i64,
        total: i64,
    ) {
        let (arg_self_, arg_request, arg_current, arg_total) = (self_, request, current, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_current = arg_current.as_raw();
        let arg_total = arg_total.as_raw();
        let result = ImplUrlrequestClient::on_download_progress(
            &arg_self_.interface,
            arg_request,
            arg_current,
            arg_total,
        );
    }
    extern "C" fn on_download_data<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        data: *const ::std::os::raw::c_void,
        data_length: usize,
    ) {
        let (arg_self_, arg_request, arg_data, arg_data_length) =
            (self_, request, data, data_length);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_data = arg_data as *const _;
        let arg_data_length = arg_data_length.as_raw();
        let result = ImplUrlrequestClient::on_download_data(
            &arg_self_.interface,
            arg_request,
            arg_data,
            arg_data_length,
        );
    }
    extern "C" fn get_auth_credentials<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const _cef_string_utf16_t,
        port: ::std::os::raw::c_int,
        realm: *const _cef_string_utf16_t,
        scheme: *const _cef_string_utf16_t,
        callback: *mut _cef_auth_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_is_proxy, arg_host, arg_port, arg_realm, arg_scheme, arg_callback) =
            (self_, is_proxy, host, port, realm, scheme, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_is_proxy = arg_is_proxy.as_raw();
        let arg_host = if arg_host.is_null() {
            None
        } else {
            Some(arg_host.into())
        };
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.as_raw();
        let arg_realm = if arg_realm.is_null() {
            None
        } else {
            Some(arg_realm.into())
        };
        let arg_realm = arg_realm.as_ref();
        let arg_scheme = if arg_scheme.is_null() {
            None
        } else {
            Some(arg_scheme.into())
        };
        let arg_scheme = arg_scheme.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| AuthCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplUrlrequestClient::get_auth_credentials(
            &arg_self_.interface,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_realm,
            arg_scheme,
            arg_callback,
        );
        result.into()
    }
}
impl ImplUrlrequestClient for UrlrequestClient {
    fn on_request_complete(&self, request: Option<&mut impl ImplUrlrequest>) {
        unsafe {
            self.0
                .on_request_complete
                .map(|f| {
                    let arg_request = request;
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplUrlrequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_upload_progress(
        &self,
        request: Option<&mut impl ImplUrlrequest>,
        current: i64,
        total: i64,
    ) {
        unsafe {
            self.0
                .on_upload_progress
                .map(|f| {
                    let (arg_request, arg_current, arg_total) = (request, current, total);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplUrlrequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_current = arg_current;
                    let arg_total = arg_total;
                    let result = f(arg_self_, arg_request, arg_current, arg_total);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_download_progress(
        &self,
        request: Option<&mut impl ImplUrlrequest>,
        current: i64,
        total: i64,
    ) {
        unsafe {
            self.0
                .on_download_progress
                .map(|f| {
                    let (arg_request, arg_current, arg_total) = (request, current, total);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplUrlrequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_current = arg_current;
                    let arg_total = arg_total;
                    let result = f(arg_self_, arg_request, arg_current, arg_total);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_download_data(
        &self,
        request: Option<&mut impl ImplUrlrequest>,
        data: *const u8,
        data_length: usize,
    ) {
        unsafe {
            self.0
                .on_download_data
                .map(|f| {
                    let (arg_request, arg_data, arg_data_length) = (request, data, data_length);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplUrlrequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data = arg_data as *const _;
                    let arg_data_length = arg_data_length;
                    let result = f(arg_self_, arg_request, arg_data, arg_data_length);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_auth_credentials(
        &self,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefStringUtf16>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefStringUtf16>,
        scheme: Option<&CefStringUtf16>,
        callback: Option<&mut impl ImplAuthCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_auth_credentials
                .map(|f| {
                    let (arg_is_proxy, arg_host, arg_port, arg_realm, arg_scheme, arg_callback) =
                        (is_proxy, host, port, realm, scheme, callback);
                    let arg_self_ = self.as_raw();
                    let arg_is_proxy = arg_is_proxy;
                    let arg_host = arg_host.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let arg_port = arg_port;
                    let arg_realm = arg_realm
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_scheme = arg_scheme
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplAuthCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_urlrequest_client_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_urlrequest_client_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for UrlrequestClient {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_urlrequest_client_t> for &UrlrequestClient {
    fn as_raw(self) -> *mut _cef_urlrequest_client_t {
        ImplUrlrequestClient::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_urlrequest_client_t> for &mut UrlrequestClient {
    fn as_raw(self) -> *mut _cef_urlrequest_client_t {
        ImplUrlrequestClient::get_raw(self)
    }
}
impl ConvertReturnValue<UrlrequestClient> for *mut _cef_urlrequest_client_t {
    fn as_wrapper(self) -> UrlrequestClient {
        UrlrequestClient(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_urlrequest_client_t> for UrlrequestClient {
    fn into(self) -> *mut _cef_urlrequest_client_t {
        let object = ImplUrlrequestClient::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for UrlrequestClient {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_layout_t] for more documentation.
#[derive(Clone)]
pub struct Layout(RefGuard<_cef_layout_t>);
impl Layout {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapLayout,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplLayout>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapLayout>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_layout_t).as_wrapper()
        }
    }
}
pub trait WrapLayout: ImplLayout {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_layout_t, Self>);
}
pub trait ImplLayout: Clone + Sized + Rc {
    fn as_box_layout(&self) -> Option<BoxLayout> {
        Default::default()
    }
    fn as_fill_layout(&self) -> Option<FillLayout> {
        Default::default()
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_layout_t) {
        impl_cef_layout_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_layout_t;
}
mod impl_cef_layout_t {
    use super::*;
    pub fn init_methods<I: ImplLayout>(object: &mut _cef_layout_t) {
        object.as_box_layout = Some(as_box_layout::<I>);
        object.as_fill_layout = Some(as_fill_layout::<I>);
        object.is_valid = Some(is_valid::<I>);
    }
    extern "C" fn as_box_layout<I: ImplLayout>(
        self_: *mut _cef_layout_t,
    ) -> *mut _cef_box_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplLayout::as_box_layout(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn as_fill_layout<I: ImplLayout>(
        self_: *mut _cef_layout_t,
    ) -> *mut _cef_fill_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplLayout::as_fill_layout(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_valid<I: ImplLayout>(self_: *mut _cef_layout_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplLayout::is_valid(&arg_self_.interface);
        result.into()
    }
}
impl ImplLayout for Layout {
    fn as_box_layout(&self) -> Option<BoxLayout> {
        unsafe {
            self.0
                .as_box_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_fill_layout(&self) -> Option<FillLayout> {
        unsafe {
            self.0
                .as_fill_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_layout_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Layout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_layout_t> for &Layout {
    fn as_raw(self) -> *mut _cef_layout_t {
        ImplLayout::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_layout_t> for &mut Layout {
    fn as_raw(self) -> *mut _cef_layout_t {
        ImplLayout::get_raw(self)
    }
}
impl ConvertReturnValue<Layout> for *mut _cef_layout_t {
    fn as_wrapper(self) -> Layout {
        Layout(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_layout_t> for Layout {
    fn into(self) -> *mut _cef_layout_t {
        let object = ImplLayout::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Layout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_box_layout_t] for more documentation.
#[derive(Clone)]
pub struct BoxLayout(RefGuard<_cef_box_layout_t>);
impl BoxLayout {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBoxLayout,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBoxLayout>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBoxLayout>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_box_layout_t).as_wrapper()
        }
    }
}
pub trait WrapBoxLayout: ImplBoxLayout {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_box_layout_t, Self>);
}
pub trait ImplBoxLayout: ImplLayout {
    fn set_flex_for_view(&self, view: Option<&mut impl ImplView>, flex: ::std::os::raw::c_int) {}
    fn clear_flex_for_view(&self, view: Option<&mut impl ImplView>) {}
    fn init_methods(object: &mut _cef_box_layout_t) {
        impl_cef_layout_t::init_methods::<Self>(&mut object.base);
        impl_cef_box_layout_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_box_layout_t {
        <Self as ImplLayout>::get_raw(self) as *mut _
    }
}
mod impl_cef_box_layout_t {
    use super::*;
    pub fn init_methods<I: ImplBoxLayout>(object: &mut _cef_box_layout_t) {
        object.set_flex_for_view = Some(set_flex_for_view::<I>);
        object.clear_flex_for_view = Some(clear_flex_for_view::<I>);
    }
    extern "C" fn set_flex_for_view<I: ImplBoxLayout>(
        self_: *mut _cef_box_layout_t,
        view: *mut _cef_view_t,
        flex: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_flex) = (self_, view, flex);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_flex = arg_flex.as_raw();
        let result = ImplBoxLayout::set_flex_for_view(&arg_self_.interface, arg_view, arg_flex);
    }
    extern "C" fn clear_flex_for_view<I: ImplBoxLayout>(
        self_: *mut _cef_box_layout_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplBoxLayout::clear_flex_for_view(&arg_self_.interface, arg_view);
    }
}
impl ImplLayout for BoxLayout {
    fn as_box_layout(&self) -> Option<BoxLayout> {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_box_layout()
    }
    fn as_fill_layout(&self) -> Option<FillLayout> {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_fill_layout()
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_valid()
    }
    fn get_raw(&self) -> *mut _cef_layout_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplBoxLayout for BoxLayout {
    fn set_flex_for_view(&self, view: Option<&mut impl ImplView>, flex: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_flex_for_view
                .map(|f| {
                    let (arg_view, arg_flex) = (view, flex);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_flex = arg_flex;
                    let result = f(arg_self_, arg_view, arg_flex);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_flex_for_view(&self, view: Option<&mut impl ImplView>) {
        unsafe {
            self.0
                .clear_flex_for_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_box_layout_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_box_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BoxLayout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_box_layout_t> for &BoxLayout {
    fn as_raw(self) -> *mut _cef_box_layout_t {
        ImplBoxLayout::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_box_layout_t> for &mut BoxLayout {
    fn as_raw(self) -> *mut _cef_box_layout_t {
        ImplBoxLayout::get_raw(self)
    }
}
impl ConvertReturnValue<BoxLayout> for *mut _cef_box_layout_t {
    fn as_wrapper(self) -> BoxLayout {
        BoxLayout(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_box_layout_t> for BoxLayout {
    fn into(self) -> *mut _cef_box_layout_t {
        let object = ImplBoxLayout::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for BoxLayout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_fill_layout_t] for more documentation.
#[derive(Clone)]
pub struct FillLayout(RefGuard<_cef_fill_layout_t>);
impl FillLayout {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFillLayout,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFillLayout>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFillLayout>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_fill_layout_t).as_wrapper()
        }
    }
}
pub trait WrapFillLayout: ImplFillLayout {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_fill_layout_t, Self>);
}
pub trait ImplFillLayout: ImplLayout {
    fn init_methods(object: &mut _cef_fill_layout_t) {
        impl_cef_layout_t::init_methods::<Self>(&mut object.base);
        impl_cef_fill_layout_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_fill_layout_t {
        <Self as ImplLayout>::get_raw(self) as *mut _
    }
}
mod impl_cef_fill_layout_t {
    use super::*;
    pub fn init_methods<I: ImplFillLayout>(object: &mut _cef_fill_layout_t) {}
}
impl ImplLayout for FillLayout {
    fn as_box_layout(&self) -> Option<BoxLayout> {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_box_layout()
    }
    fn as_fill_layout(&self) -> Option<FillLayout> {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_fill_layout()
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_valid()
    }
    fn get_raw(&self) -> *mut _cef_layout_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplFillLayout for FillLayout {
    fn get_raw(&self) -> *mut _cef_fill_layout_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_fill_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FillLayout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_fill_layout_t> for &FillLayout {
    fn as_raw(self) -> *mut _cef_fill_layout_t {
        ImplFillLayout::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_fill_layout_t> for &mut FillLayout {
    fn as_raw(self) -> *mut _cef_fill_layout_t {
        ImplFillLayout::get_raw(self)
    }
}
impl ConvertReturnValue<FillLayout> for *mut _cef_fill_layout_t {
    fn as_wrapper(self) -> FillLayout {
        FillLayout(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_fill_layout_t> for FillLayout {
    fn into(self) -> *mut _cef_fill_layout_t {
        let object = ImplFillLayout::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for FillLayout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_view_delegate_t] for more documentation.
#[derive(Clone)]
pub struct ViewDelegate(RefGuard<_cef_view_delegate_t>);
impl ViewDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapViewDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplViewDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapViewDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_view_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapViewDelegate: ImplViewDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_view_delegate_t, Self>);
}
pub trait ImplViewDelegate: Clone + Sized + Rc {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        Default::default()
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        Default::default()
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        Default::default()
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {}
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {}
    fn on_focus(&self, view: Option<&mut impl ImplView>) {}
    fn on_blur(&self, view: Option<&mut impl ImplView>) {}
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {}
    fn init_methods(object: &mut _cef_view_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t;
}
mod impl_cef_view_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplViewDelegate>(object: &mut _cef_view_delegate_t) {
        object.get_preferred_size = Some(get_preferred_size::<I>);
        object.get_minimum_size = Some(get_minimum_size::<I>);
        object.get_maximum_size = Some(get_maximum_size::<I>);
        object.get_height_for_width = Some(get_height_for_width::<I>);
        object.on_parent_view_changed = Some(on_parent_view_changed::<I>);
        object.on_child_view_changed = Some(on_child_view_changed::<I>);
        object.on_window_changed = Some(on_window_changed::<I>);
        object.on_layout_changed = Some(on_layout_changed::<I>);
        object.on_focus = Some(on_focus::<I>);
        object.on_blur = Some(on_blur::<I>);
        object.on_theme_changed = Some(on_theme_changed::<I>);
    }
    extern "C" fn get_preferred_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::get_preferred_size(&arg_self_.interface, arg_view);
        result.into()
    }
    extern "C" fn get_minimum_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::get_minimum_size(&arg_self_.interface, arg_view);
        result.into()
    }
    extern "C" fn get_maximum_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::get_maximum_size(&arg_self_.interface, arg_view);
        result.into()
    }
    extern "C" fn get_height_for_width<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_view, arg_width) = (self_, view, width);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_width = arg_width.as_raw();
        let result =
            ImplViewDelegate::get_height_for_width(&arg_self_.interface, arg_view, arg_width);
        result.into()
    }
    extern "C" fn on_parent_view_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
        parent: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view, arg_added, arg_parent) = (self_, view, added, parent);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_added = arg_added.as_raw();
        let mut arg_parent =
            unsafe { arg_parent.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_parent = arg_parent.as_mut();
        let result = ImplViewDelegate::on_parent_view_changed(
            &arg_self_.interface,
            arg_view,
            arg_added,
            arg_parent,
        );
    }
    extern "C" fn on_child_view_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
        child: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view, arg_added, arg_child) = (self_, view, added, child);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_added = arg_added.as_raw();
        let mut arg_child =
            unsafe { arg_child.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_child = arg_child.as_mut();
        let result = ImplViewDelegate::on_child_view_changed(
            &arg_self_.interface,
            arg_view,
            arg_added,
            arg_child,
        );
    }
    extern "C" fn on_window_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_added) = (self_, view, added);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_added = arg_added.as_raw();
        let result = ImplViewDelegate::on_window_changed(&arg_self_.interface, arg_view, arg_added);
    }
    extern "C" fn on_layout_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        new_bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_view, arg_new_bounds) = (self_, view, new_bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_new_bounds = if arg_new_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_new_bounds))
        };
        let arg_new_bounds = arg_new_bounds.as_ref().map(|arg| arg.as_ref());
        let result =
            ImplViewDelegate::on_layout_changed(&arg_self_.interface, arg_view, arg_new_bounds);
    }
    extern "C" fn on_focus<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::on_focus(&arg_self_.interface, arg_view);
    }
    extern "C" fn on_blur<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::on_blur(&arg_self_.interface, arg_view);
    }
    extern "C" fn on_theme_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::on_theme_changed(&arg_self_.interface, arg_view);
    }
}
impl ImplViewDelegate for ViewDelegate {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        unsafe {
            self.0
                .get_preferred_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        unsafe {
            self.0
                .get_minimum_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        unsafe {
            self.0
                .get_maximum_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_height_for_width
                .map(|f| {
                    let (arg_view, arg_width) = (view, width);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_width = arg_width;
                    let result = f(arg_self_, arg_view, arg_width);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
        unsafe {
            self.0
                .on_parent_view_changed
                .map(|f| {
                    let (arg_view, arg_added, arg_parent) = (view, added, parent);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_added = arg_added;
                    let arg_parent = arg_parent
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view, arg_added, arg_parent);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
        unsafe {
            self.0
                .on_child_view_changed
                .map(|f| {
                    let (arg_view, arg_added, arg_child) = (view, added, child);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_added = arg_added;
                    let arg_child = arg_child
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view, arg_added, arg_child);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_window_changed
                .map(|f| {
                    let (arg_view, arg_added) = (view, added);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_added = arg_added;
                    let result = f(arg_self_, arg_view, arg_added);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {
        unsafe {
            self.0
                .on_layout_changed
                .map(|f| {
                    let (arg_view, arg_new_bounds) = (view, new_bounds);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_new_bounds = arg_new_bounds.cloned().map(|arg| arg.into());
                    let arg_new_bounds = arg_new_bounds
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_view, arg_new_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_focus(&self, view: Option<&mut impl ImplView>) {
        unsafe {
            self.0
                .on_focus
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_blur(&self, view: Option<&mut impl ImplView>) {
        unsafe {
            self.0
                .on_blur
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {
        unsafe {
            self.0
                .on_theme_changed
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_view_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ViewDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_view_delegate_t> for &ViewDelegate {
    fn as_raw(self) -> *mut _cef_view_delegate_t {
        ImplViewDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_view_delegate_t> for &mut ViewDelegate {
    fn as_raw(self) -> *mut _cef_view_delegate_t {
        ImplViewDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<ViewDelegate> for *mut _cef_view_delegate_t {
    fn as_wrapper(self) -> ViewDelegate {
        ViewDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_view_delegate_t> for ViewDelegate {
    fn into(self) -> *mut _cef_view_delegate_t {
        let object = ImplViewDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ViewDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_view_t] for more documentation.
#[derive(Clone)]
pub struct View(RefGuard<_cef_view_t>);
impl View {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapView,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplView>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapView>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_view_t).as_wrapper()
        }
    }
}
pub trait WrapView: ImplView {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_view_t, Self>);
}
pub trait ImplView: Clone + Sized + Rc {
    fn as_browser_view(&self) -> Option<BrowserView> {
        Default::default()
    }
    fn as_button(&self) -> Option<Button> {
        Default::default()
    }
    fn as_panel(&self) -> Option<Panel> {
        Default::default()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        Default::default()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        Default::default()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        Default::default()
    }
    fn get_window(&self) -> Option<Window> {
        Default::default()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {}
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {}
    fn get_parent_view(&self) -> Option<View> {
        Default::default()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        Default::default()
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {}
    fn get_bounds(&self) -> Rect {
        Default::default()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        Default::default()
    }
    fn set_size(&self, size: Option<&Size>) {}
    fn get_size(&self) -> Size {
        Default::default()
    }
    fn set_position(&self, position: Option<&Point>) {}
    fn get_position(&self) -> Point {
        Default::default()
    }
    fn set_insets(&self, insets: Option<&Insets>) {}
    fn get_insets(&self) -> Insets {
        Default::default()
    }
    fn get_preferred_size(&self) -> Size {
        Default::default()
    }
    fn size_to_preferred_size(&self) {}
    fn get_minimum_size(&self) -> Size {
        Default::default()
    }
    fn get_maximum_size(&self) -> Size {
        Default::default()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn invalidate_layout(&self) {}
    fn set_visible(&self, visible: ::std::os::raw::c_int) {}
    fn is_visible(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {}
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {}
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn request_focus(&self) {}
    fn set_background_color(&self, color: u32) {}
    fn get_background_color(&self) -> cef_color_t {
        Default::default()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        Default::default()
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_view_t) {
        impl_cef_view_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_view_t;
}
mod impl_cef_view_t {
    use super::*;
    pub fn init_methods<I: ImplView>(object: &mut _cef_view_t) {
        object.as_browser_view = Some(as_browser_view::<I>);
        object.as_button = Some(as_button::<I>);
        object.as_panel = Some(as_panel::<I>);
        object.as_scroll_view = Some(as_scroll_view::<I>);
        object.as_textfield = Some(as_textfield::<I>);
        object.get_type_string = Some(get_type_string::<I>);
        object.to_string = Some(to_string::<I>);
        object.is_valid = Some(is_valid::<I>);
        object.is_attached = Some(is_attached::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_delegate = Some(get_delegate::<I>);
        object.get_window = Some(get_window::<I>);
        object.get_id = Some(get_id::<I>);
        object.set_id = Some(set_id::<I>);
        object.get_group_id = Some(get_group_id::<I>);
        object.set_group_id = Some(set_group_id::<I>);
        object.get_parent_view = Some(get_parent_view::<I>);
        object.get_view_for_id = Some(get_view_for_id::<I>);
        object.set_bounds = Some(set_bounds::<I>);
        object.get_bounds = Some(get_bounds::<I>);
        object.get_bounds_in_screen = Some(get_bounds_in_screen::<I>);
        object.set_size = Some(set_size::<I>);
        object.get_size = Some(get_size::<I>);
        object.set_position = Some(set_position::<I>);
        object.get_position = Some(get_position::<I>);
        object.set_insets = Some(set_insets::<I>);
        object.get_insets = Some(get_insets::<I>);
        object.get_preferred_size = Some(get_preferred_size::<I>);
        object.size_to_preferred_size = Some(size_to_preferred_size::<I>);
        object.get_minimum_size = Some(get_minimum_size::<I>);
        object.get_maximum_size = Some(get_maximum_size::<I>);
        object.get_height_for_width = Some(get_height_for_width::<I>);
        object.invalidate_layout = Some(invalidate_layout::<I>);
        object.set_visible = Some(set_visible::<I>);
        object.is_visible = Some(is_visible::<I>);
        object.is_drawn = Some(is_drawn::<I>);
        object.set_enabled = Some(set_enabled::<I>);
        object.is_enabled = Some(is_enabled::<I>);
        object.set_focusable = Some(set_focusable::<I>);
        object.is_focusable = Some(is_focusable::<I>);
        object.is_accessibility_focusable = Some(is_accessibility_focusable::<I>);
        object.has_focus = Some(has_focus::<I>);
        object.request_focus = Some(request_focus::<I>);
        object.set_background_color = Some(set_background_color::<I>);
        object.get_background_color = Some(get_background_color::<I>);
        object.get_theme_color = Some(get_theme_color::<I>);
        object.convert_point_to_screen = Some(convert_point_to_screen::<I>);
        object.convert_point_from_screen = Some(convert_point_from_screen::<I>);
        object.convert_point_to_window = Some(convert_point_to_window::<I>);
        object.convert_point_from_window = Some(convert_point_from_window::<I>);
        object.convert_point_to_view = Some(convert_point_to_view::<I>);
        object.convert_point_from_view = Some(convert_point_from_view::<I>);
    }
    extern "C" fn as_browser_view<I: ImplView>(
        self_: *mut _cef_view_t,
    ) -> *mut _cef_browser_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::as_browser_view(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn as_button<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_button_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::as_button(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn as_panel<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_panel_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::as_panel(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn as_scroll_view<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_scroll_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::as_scroll_view(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn as_textfield<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_textfield_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::as_textfield(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_type_string<I: ImplView>(
        self_: *mut _cef_view_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_type_string(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn to_string<I: ImplView>(
        self_: *mut _cef_view_t,
        include_children: ::std::os::raw::c_int,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_include_children) = (self_, include_children);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_include_children = arg_include_children.as_raw();
        let result = ImplView::to_string(&arg_self_.interface, arg_include_children);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_valid<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_attached<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::is_attached(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplView>(
        self_: *mut _cef_view_t,
        that: *mut _cef_view_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that =
            unsafe { arg_that.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplView::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn get_delegate<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_view_delegate_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_delegate(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_window<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_window_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_window(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_id<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_id(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_id<I: ImplView>(self_: *mut _cef_view_t, id: ::std::os::raw::c_int) {
        let (arg_self_, arg_id) = (self_, id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_id = arg_id.as_raw();
        let result = ImplView::set_id(&arg_self_.interface, arg_id);
    }
    extern "C" fn get_group_id<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_group_id(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_group_id<I: ImplView>(
        self_: *mut _cef_view_t,
        group_id: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_group_id) = (self_, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_group_id = arg_group_id.as_raw();
        let result = ImplView::set_group_id(&arg_self_.interface, arg_group_id);
    }
    extern "C" fn get_parent_view<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_parent_view(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_view_for_id<I: ImplView>(
        self_: *mut _cef_view_t,
        id: ::std::os::raw::c_int,
    ) -> *mut _cef_view_t {
        let (arg_self_, arg_id) = (self_, id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_id = arg_id.as_raw();
        let result = ImplView::get_view_for_id(&arg_self_.interface, arg_id);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_bounds<I: ImplView>(self_: *mut _cef_view_t, bounds: *const _cef_rect_t) {
        let (arg_self_, arg_bounds) = (self_, bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bounds = if arg_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_bounds))
        };
        let arg_bounds = arg_bounds.as_ref().map(|arg| arg.as_ref());
        let result = ImplView::set_bounds(&arg_self_.interface, arg_bounds);
    }
    extern "C" fn get_bounds<I: ImplView>(self_: *mut _cef_view_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_bounds(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_bounds_in_screen<I: ImplView>(self_: *mut _cef_view_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_bounds_in_screen(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_size<I: ImplView>(self_: *mut _cef_view_t, size: *const _cef_size_t) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_size))
        };
        let arg_size = arg_size.as_ref().map(|arg| arg.as_ref());
        let result = ImplView::set_size(&arg_self_.interface, arg_size);
    }
    extern "C" fn get_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_position<I: ImplView>(
        self_: *mut _cef_view_t,
        position: *const _cef_point_t,
    ) {
        let (arg_self_, arg_position) = (self_, position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_position = if arg_position.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_position))
        };
        let arg_position = arg_position.as_ref().map(|arg| arg.as_ref());
        let result = ImplView::set_position(&arg_self_.interface, arg_position);
    }
    extern "C" fn get_position<I: ImplView>(self_: *mut _cef_view_t) -> _cef_point_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_position(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_insets<I: ImplView>(self_: *mut _cef_view_t, insets: *const _cef_insets_t) {
        let (arg_self_, arg_insets) = (self_, insets);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_insets = if arg_insets.is_null() {
            None
        } else {
            Some(WrapParamRef::<Insets>::from(arg_insets))
        };
        let arg_insets = arg_insets.as_ref().map(|arg| arg.as_ref());
        let result = ImplView::set_insets(&arg_self_.interface, arg_insets);
    }
    extern "C" fn get_insets<I: ImplView>(self_: *mut _cef_view_t) -> _cef_insets_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_insets(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_preferred_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_preferred_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn size_to_preferred_size<I: ImplView>(self_: *mut _cef_view_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::size_to_preferred_size(&arg_self_.interface);
    }
    extern "C" fn get_minimum_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_minimum_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_maximum_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_maximum_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_height_for_width<I: ImplView>(
        self_: *mut _cef_view_t,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_width) = (self_, width);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_width = arg_width.as_raw();
        let result = ImplView::get_height_for_width(&arg_self_.interface, arg_width);
        result.into()
    }
    extern "C" fn invalidate_layout<I: ImplView>(self_: *mut _cef_view_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::invalidate_layout(&arg_self_.interface);
    }
    extern "C" fn set_visible<I: ImplView>(
        self_: *mut _cef_view_t,
        visible: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_visible) = (self_, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visible = arg_visible.as_raw();
        let result = ImplView::set_visible(&arg_self_.interface, arg_visible);
    }
    extern "C" fn is_visible<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::is_visible(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_drawn<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::is_drawn(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_enabled<I: ImplView>(
        self_: *mut _cef_view_t,
        enabled: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_enabled) = (self_, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_enabled = arg_enabled.as_raw();
        let result = ImplView::set_enabled(&arg_self_.interface, arg_enabled);
    }
    extern "C" fn is_enabled<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::is_enabled(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_focusable<I: ImplView>(
        self_: *mut _cef_view_t,
        focusable: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_focusable) = (self_, focusable);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_focusable = arg_focusable.as_raw();
        let result = ImplView::set_focusable(&arg_self_.interface, arg_focusable);
    }
    extern "C" fn is_focusable<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::is_focusable(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_accessibility_focusable<I: ImplView>(
        self_: *mut _cef_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::is_accessibility_focusable(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_focus<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::has_focus(&arg_self_.interface);
        result.into()
    }
    extern "C" fn request_focus<I: ImplView>(self_: *mut _cef_view_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::request_focus(&arg_self_.interface);
    }
    extern "C" fn set_background_color<I: ImplView>(self_: *mut _cef_view_t, color: u32) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let result = ImplView::set_background_color(&arg_self_.interface, arg_color);
    }
    extern "C" fn get_background_color<I: ImplView>(self_: *mut _cef_view_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplView::get_background_color(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_theme_color<I: ImplView>(
        self_: *mut _cef_view_t,
        color_id: ::std::os::raw::c_int,
    ) -> u32 {
        let (arg_self_, arg_color_id) = (self_, color_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color_id = arg_color_id.as_raw();
        let result = ImplView::get_theme_color(&arg_self_.interface, arg_color_id);
        result.into()
    }
    extern "C" fn convert_point_to_screen<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplView::convert_point_to_screen(&arg_self_.interface, arg_point);
        result.into()
    }
    extern "C" fn convert_point_from_screen<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplView::convert_point_from_screen(&arg_self_.interface, arg_point);
        result.into()
    }
    extern "C" fn convert_point_to_window<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplView::convert_point_to_window(&arg_self_.interface, arg_point);
        result.into()
    }
    extern "C" fn convert_point_from_window<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplView::convert_point_from_window(&arg_self_.interface, arg_point);
        result.into()
    }
    extern "C" fn convert_point_to_view<I: ImplView>(
        self_: *mut _cef_view_t,
        view: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_view, arg_point) = (self_, view, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplView::convert_point_to_view(&arg_self_.interface, arg_view, arg_point);
        result.into()
    }
    extern "C" fn convert_point_from_view<I: ImplView>(
        self_: *mut _cef_view_t,
        view: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_view, arg_point) = (self_, view, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplView::convert_point_from_view(&arg_self_.interface, arg_view, arg_point);
        result.into()
    }
}
impl ImplView for View {
    fn as_browser_view(&self) -> Option<BrowserView> {
        unsafe {
            self.0
                .as_browser_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_button(&self) -> Option<Button> {
        unsafe {
            self.0
                .as_button
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_panel(&self) -> Option<Panel> {
        unsafe {
            self.0
                .as_panel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        unsafe {
            self.0
                .as_scroll_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_textfield(&self) -> Option<Textfield> {
        unsafe {
            self.0
                .as_textfield
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_type_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .to_string
                .map(|f| {
                    let arg_include_children = include_children;
                    let arg_self_ = self.as_raw();
                    let arg_include_children = arg_include_children;
                    let result = f(arg_self_, arg_include_children);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_attached
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        unsafe {
            self.0
                .get_delegate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_window(&self) -> Option<Window> {
        unsafe {
            self.0
                .get_window
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.as_raw();
                    let arg_id = arg_id;
                    let result = f(arg_self_, arg_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_group_id
                .map(|f| {
                    let arg_group_id = group_id;
                    let arg_self_ = self.as_raw();
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_parent_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_parent_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        unsafe {
            self.0
                .get_view_for_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.as_raw();
                    let arg_id = arg_id;
                    let result = f(arg_self_, arg_id);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        unsafe {
            self.0
                .set_bounds
                .map(|f| {
                    let arg_bounds = bounds;
                    let arg_self_ = self.as_raw();
                    let arg_bounds = arg_bounds.cloned().map(|arg| arg.into());
                    let arg_bounds = arg_bounds
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_bounds_in_screen(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_size(&self, size: Option<&Size>) {
        unsafe {
            self.0
                .set_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size(&self) -> Size {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_position(&self, position: Option<&Point>) {
        unsafe {
            self.0
                .set_position
                .map(|f| {
                    let arg_position = position;
                    let arg_self_ = self.as_raw();
                    let arg_position = arg_position.cloned().map(|arg| arg.into());
                    let arg_position = arg_position
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_position);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_position(&self) -> Point {
        unsafe {
            self.0
                .get_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        unsafe {
            self.0
                .set_insets
                .map(|f| {
                    let arg_insets = insets;
                    let arg_self_ = self.as_raw();
                    let arg_insets = arg_insets.cloned().map(|arg| arg.into());
                    let arg_insets = arg_insets
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_insets);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_insets(&self) -> Insets {
        unsafe {
            self.0
                .get_insets
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_preferred_size(&self) -> Size {
        unsafe {
            self.0
                .get_preferred_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn size_to_preferred_size(&self) {
        unsafe {
            self.0
                .size_to_preferred_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_minimum_size(&self) -> Size {
        unsafe {
            self.0
                .get_minimum_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_maximum_size(&self) -> Size {
        unsafe {
            self.0
                .get_maximum_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_height_for_width
                .map(|f| {
                    let arg_width = width;
                    let arg_self_ = self.as_raw();
                    let arg_width = arg_width;
                    let result = f(arg_self_, arg_width);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn invalidate_layout(&self) {
        unsafe {
            self.0
                .invalidate_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_visible
                .map(|f| {
                    let arg_visible = visible;
                    let arg_self_ = self.as_raw();
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_drawn
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_enabled
                .map(|f| {
                    let arg_enabled = enabled;
                    let arg_self_ = self.as_raw();
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_focusable
                .map(|f| {
                    let arg_focusable = focusable;
                    let arg_self_ = self.as_raw();
                    let arg_focusable = arg_focusable;
                    let result = f(arg_self_, arg_focusable);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_focusable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_accessibility_focusable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_focus
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn request_focus(&self) {
        unsafe {
            self.0
                .request_focus
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_background_color(&self, color: u32) {
        unsafe {
            self.0
                .set_background_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_background_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_background_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        unsafe {
            self.0
                .get_theme_color
                .map(|f| {
                    let arg_color_id = color_id;
                    let arg_self_ = self.as_raw();
                    let arg_color_id = arg_color_id;
                    let result = f(arg_self_, arg_color_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_screen
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_screen
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_window
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_window
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_view
                .map(|f| {
                    let (arg_view, arg_point) = (view, point);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_view
                .map(|f| {
                    let (arg_view, arg_point) = (view, point);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for View {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_view_t> for &View {
    fn as_raw(self) -> *mut _cef_view_t {
        ImplView::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_view_t> for &mut View {
    fn as_raw(self) -> *mut _cef_view_t {
        ImplView::get_raw(self)
    }
}
impl ConvertReturnValue<View> for *mut _cef_view_t {
    fn as_wrapper(self) -> View {
        View(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_view_t> for View {
    fn into(self) -> *mut _cef_view_t {
        let object = ImplView::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for View {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_button_t] for more documentation.
#[derive(Clone)]
pub struct Button(RefGuard<_cef_button_t>);
impl Button {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapButton,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplButton>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapButton>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_button_t).as_wrapper()
        }
    }
}
pub trait WrapButton: ImplButton {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_button_t, Self>);
}
pub trait ImplButton: ImplView {
    fn as_label_button(&self) -> Option<LabelButton> {
        Default::default()
    }
    fn set_state(&self, state: ButtonState) {}
    fn get_state(&self) -> ButtonState {
        Default::default()
    }
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int) {}
    fn set_tooltip_text(&self, tooltip_text: Option<&CefStringUtf16>) {}
    fn set_accessible_name(&self, name: Option<&CefStringUtf16>) {}
    fn init_methods(object: &mut _cef_button_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_button_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_button_t {
        <Self as ImplView>::get_raw(self) as *mut _
    }
}
mod impl_cef_button_t {
    use super::*;
    pub fn init_methods<I: ImplButton>(object: &mut _cef_button_t) {
        object.as_label_button = Some(as_label_button::<I>);
        object.set_state = Some(set_state::<I>);
        object.get_state = Some(get_state::<I>);
        object.set_ink_drop_enabled = Some(set_ink_drop_enabled::<I>);
        object.set_tooltip_text = Some(set_tooltip_text::<I>);
        object.set_accessible_name = Some(set_accessible_name::<I>);
    }
    extern "C" fn as_label_button<I: ImplButton>(
        self_: *mut _cef_button_t,
    ) -> *mut _cef_label_button_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplButton::as_label_button(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_state<I: ImplButton>(self_: *mut _cef_button_t, state: cef_button_state_t) {
        let (arg_self_, arg_state) = (self_, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_state = arg_state.as_raw();
        let result = ImplButton::set_state(&arg_self_.interface, arg_state);
    }
    extern "C" fn get_state<I: ImplButton>(self_: *mut _cef_button_t) -> cef_button_state_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplButton::get_state(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_ink_drop_enabled<I: ImplButton>(
        self_: *mut _cef_button_t,
        enabled: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_enabled) = (self_, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_enabled = arg_enabled.as_raw();
        let result = ImplButton::set_ink_drop_enabled(&arg_self_.interface, arg_enabled);
    }
    extern "C" fn set_tooltip_text<I: ImplButton>(
        self_: *mut _cef_button_t,
        tooltip_text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_tooltip_text) = (self_, tooltip_text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_tooltip_text = if arg_tooltip_text.is_null() {
            None
        } else {
            Some(arg_tooltip_text.into())
        };
        let arg_tooltip_text = arg_tooltip_text.as_ref();
        let result = ImplButton::set_tooltip_text(&arg_self_.interface, arg_tooltip_text);
    }
    extern "C" fn set_accessible_name<I: ImplButton>(
        self_: *mut _cef_button_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplButton::set_accessible_name(&arg_self_.interface, arg_name);
    }
}
impl ImplView for Button {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplButton for Button {
    fn as_label_button(&self) -> Option<LabelButton> {
        unsafe {
            self.0
                .as_label_button
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_state(&self, state: ButtonState) {
        unsafe {
            self.0
                .set_state
                .map(|f| {
                    let arg_state = state;
                    let arg_self_ = self.as_raw();
                    let arg_state = arg_state.as_raw();
                    let result = f(arg_self_, arg_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_state(&self) -> ButtonState {
        unsafe {
            self.0
                .get_state
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_ink_drop_enabled
                .map(|f| {
                    let arg_enabled = enabled;
                    let arg_self_ = self.as_raw();
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_tooltip_text(&self, tooltip_text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_tooltip_text
                .map(|f| {
                    let arg_tooltip_text = tooltip_text;
                    let arg_self_ = self.as_raw();
                    let arg_tooltip_text = arg_tooltip_text
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_tooltip_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accessible_name(&self, name: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_accessible_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_button_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Button {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_button_t> for &Button {
    fn as_raw(self) -> *mut _cef_button_t {
        ImplButton::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_button_t> for &mut Button {
    fn as_raw(self) -> *mut _cef_button_t {
        ImplButton::get_raw(self)
    }
}
impl ConvertReturnValue<Button> for *mut _cef_button_t {
    fn as_wrapper(self) -> Button {
        Button(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_button_t> for Button {
    fn into(self) -> *mut _cef_button_t {
        let object = ImplButton::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Button {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_button_delegate_t] for more documentation.
#[derive(Clone)]
pub struct ButtonDelegate(RefGuard<_cef_button_delegate_t>);
impl ButtonDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapButtonDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplButtonDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapButtonDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_button_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapButtonDelegate: ImplButtonDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_button_delegate_t, Self>);
}
pub trait ImplButtonDelegate: ImplViewDelegate {
    fn on_button_pressed(&self, button: Option<&mut impl ImplButton>) {}
    fn on_button_state_changed(&self, button: Option<&mut impl ImplButton>) {}
    fn init_methods(object: &mut _cef_button_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_button_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_button_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self) as *mut _
    }
}
mod impl_cef_button_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplButtonDelegate>(object: &mut _cef_button_delegate_t) {
        object.on_button_pressed = Some(on_button_pressed::<I>);
        object.on_button_state_changed = Some(on_button_state_changed::<I>);
    }
    extern "C" fn on_button_pressed<I: ImplButtonDelegate>(
        self_: *mut _cef_button_delegate_t,
        button: *mut _cef_button_t,
    ) {
        let (arg_self_, arg_button) = (self_, button);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_button =
            unsafe { arg_button.as_mut() }.map(|arg| Button(unsafe { RefGuard::from_raw(arg) }));
        let arg_button = arg_button.as_mut();
        let result = ImplButtonDelegate::on_button_pressed(&arg_self_.interface, arg_button);
    }
    extern "C" fn on_button_state_changed<I: ImplButtonDelegate>(
        self_: *mut _cef_button_delegate_t,
        button: *mut _cef_button_t,
    ) {
        let (arg_self_, arg_button) = (self_, button);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_button =
            unsafe { arg_button.as_mut() }.map(|arg| Button(unsafe { RefGuard::from_raw(arg) }));
        let arg_button = arg_button.as_mut();
        let result = ImplButtonDelegate::on_button_state_changed(&arg_self_.interface, arg_button);
    }
}
impl ImplViewDelegate for ButtonDelegate {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplButtonDelegate for ButtonDelegate {
    fn on_button_pressed(&self, button: Option<&mut impl ImplButton>) {
        unsafe {
            self.0
                .on_button_pressed
                .map(|f| {
                    let arg_button = button;
                    let arg_self_ = self.as_raw();
                    let arg_button = arg_button
                        .map(|arg| {
                            arg.add_ref();
                            ImplButton::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_button);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_button_state_changed(&self, button: Option<&mut impl ImplButton>) {
        unsafe {
            self.0
                .on_button_state_changed
                .map(|f| {
                    let arg_button = button;
                    let arg_self_ = self.as_raw();
                    let arg_button = arg_button
                        .map(|arg| {
                            arg.add_ref();
                            ImplButton::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_button);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_button_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_button_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ButtonDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_button_delegate_t> for &ButtonDelegate {
    fn as_raw(self) -> *mut _cef_button_delegate_t {
        ImplButtonDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_button_delegate_t> for &mut ButtonDelegate {
    fn as_raw(self) -> *mut _cef_button_delegate_t {
        ImplButtonDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<ButtonDelegate> for *mut _cef_button_delegate_t {
    fn as_wrapper(self) -> ButtonDelegate {
        ButtonDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_button_delegate_t> for ButtonDelegate {
    fn into(self) -> *mut _cef_button_delegate_t {
        let object = ImplButtonDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ButtonDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_label_button_t] for more documentation.
#[derive(Clone)]
pub struct LabelButton(RefGuard<_cef_label_button_t>);
impl LabelButton {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapLabelButton,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplLabelButton>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapLabelButton>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_label_button_t).as_wrapper()
        }
    }
}
pub trait WrapLabelButton: ImplLabelButton {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_label_button_t, Self>);
}
pub trait ImplLabelButton: ImplButton {
    fn as_menu_button(&self) -> Option<MenuButton> {
        Default::default()
    }
    fn set_text(&self, text: Option<&CefStringUtf16>) {}
    fn get_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_image(&self, button_state: ButtonState, image: Option<&mut impl ImplImage>) {}
    fn get_image(&self, button_state: ButtonState) -> Option<Image> {
        Default::default()
    }
    fn set_text_color(&self, for_state: ButtonState, color: u32) {}
    fn set_enabled_text_colors(&self, color: u32) {}
    fn set_font_list(&self, font_list: Option<&CefStringUtf16>) {}
    fn set_horizontal_alignment(&self, alignment: HorizontalAlignment) {}
    fn set_minimum_size(&self, size: Option<&Size>) {}
    fn set_maximum_size(&self, size: Option<&Size>) {}
    fn init_methods(object: &mut _cef_label_button_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_button_t::init_methods::<Self>(&mut object.base);
        impl_cef_label_button_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_label_button_t {
        <Self as ImplButton>::get_raw(self) as *mut _
    }
}
mod impl_cef_label_button_t {
    use super::*;
    pub fn init_methods<I: ImplLabelButton>(object: &mut _cef_label_button_t) {
        object.as_menu_button = Some(as_menu_button::<I>);
        object.set_text = Some(set_text::<I>);
        object.get_text = Some(get_text::<I>);
        object.set_image = Some(set_image::<I>);
        object.get_image = Some(get_image::<I>);
        object.set_text_color = Some(set_text_color::<I>);
        object.set_enabled_text_colors = Some(set_enabled_text_colors::<I>);
        object.set_font_list = Some(set_font_list::<I>);
        object.set_horizontal_alignment = Some(set_horizontal_alignment::<I>);
        object.set_minimum_size = Some(set_minimum_size::<I>);
        object.set_maximum_size = Some(set_maximum_size::<I>);
    }
    extern "C" fn as_menu_button<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
    ) -> *mut _cef_menu_button_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplLabelButton::as_menu_button(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_text<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let result = ImplLabelButton::set_text(&arg_self_.interface, arg_text);
    }
    extern "C" fn get_text<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplLabelButton::get_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_image<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        button_state: cef_button_state_t,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_button_state, arg_image) = (self_, button_state, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button_state = arg_button_state.as_raw();
        let mut arg_image =
            unsafe { arg_image.as_mut() }.map(|arg| Image(unsafe { RefGuard::from_raw(arg) }));
        let arg_image = arg_image.as_mut();
        let result = ImplLabelButton::set_image(&arg_self_.interface, arg_button_state, arg_image);
    }
    extern "C" fn get_image<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        button_state: cef_button_state_t,
    ) -> *mut _cef_image_t {
        let (arg_self_, arg_button_state) = (self_, button_state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button_state = arg_button_state.as_raw();
        let result = ImplLabelButton::get_image(&arg_self_.interface, arg_button_state);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_text_color<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        for_state: cef_button_state_t,
        color: u32,
    ) {
        let (arg_self_, arg_for_state, arg_color) = (self_, for_state, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_for_state = arg_for_state.as_raw();
        let arg_color = arg_color.as_raw();
        let result =
            ImplLabelButton::set_text_color(&arg_self_.interface, arg_for_state, arg_color);
    }
    extern "C" fn set_enabled_text_colors<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let result = ImplLabelButton::set_enabled_text_colors(&arg_self_.interface, arg_color);
    }
    extern "C" fn set_font_list<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        font_list: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_font_list) = (self_, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_font_list = if arg_font_list.is_null() {
            None
        } else {
            Some(arg_font_list.into())
        };
        let arg_font_list = arg_font_list.as_ref();
        let result = ImplLabelButton::set_font_list(&arg_self_.interface, arg_font_list);
    }
    extern "C" fn set_horizontal_alignment<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        alignment: cef_horizontal_alignment_t,
    ) {
        let (arg_self_, arg_alignment) = (self_, alignment);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_alignment = arg_alignment.as_raw();
        let result = ImplLabelButton::set_horizontal_alignment(&arg_self_.interface, arg_alignment);
    }
    extern "C" fn set_minimum_size<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_size))
        };
        let arg_size = arg_size.as_ref().map(|arg| arg.as_ref());
        let result = ImplLabelButton::set_minimum_size(&arg_self_.interface, arg_size);
    }
    extern "C" fn set_maximum_size<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_size))
        };
        let arg_size = arg_size.as_ref().map(|arg| arg.as_ref());
        let result = ImplLabelButton::set_maximum_size(&arg_self_.interface, arg_size);
    }
}
impl ImplView for LabelButton {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplButton for LabelButton {
    fn as_label_button(&self) -> Option<LabelButton> {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_label_button()
    }
    fn set_state(&self, state: ButtonState) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_state(state)
    }
    fn get_state(&self) -> ButtonState {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_state()
    }
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_ink_drop_enabled(enabled)
    }
    fn set_tooltip_text(&self, tooltip_text: Option<&CefStringUtf16>) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_tooltip_text(tooltip_text)
    }
    fn set_accessible_name(&self, name: Option<&CefStringUtf16>) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_accessible_name(name)
    }
    fn get_raw(&self) -> *mut _cef_button_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplLabelButton for LabelButton {
    fn as_menu_button(&self) -> Option<MenuButton> {
        unsafe {
            self.0
                .as_menu_button
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_text(&self, text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_image(&self, button_state: ButtonState, image: Option<&mut impl ImplImage>) {
        unsafe {
            self.0
                .set_image
                .map(|f| {
                    let (arg_button_state, arg_image) = (button_state, image);
                    let arg_self_ = self.as_raw();
                    let arg_button_state = arg_button_state.as_raw();
                    let arg_image = arg_image
                        .map(|arg| {
                            arg.add_ref();
                            ImplImage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_button_state, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_image(&self, button_state: ButtonState) -> Option<Image> {
        unsafe {
            self.0
                .get_image
                .map(|f| {
                    let arg_button_state = button_state;
                    let arg_self_ = self.as_raw();
                    let arg_button_state = arg_button_state.as_raw();
                    let result = f(arg_self_, arg_button_state);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_text_color(&self, for_state: ButtonState, color: u32) {
        unsafe {
            self.0
                .set_text_color
                .map(|f| {
                    let (arg_for_state, arg_color) = (for_state, color);
                    let arg_self_ = self.as_raw();
                    let arg_for_state = arg_for_state.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_for_state, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_enabled_text_colors(&self, color: u32) {
        unsafe {
            self.0
                .set_enabled_text_colors
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_font_list(&self, font_list: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_font_list
                .map(|f| {
                    let arg_font_list = font_list;
                    let arg_self_ = self.as_raw();
                    let arg_font_list = arg_font_list
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_horizontal_alignment(&self, alignment: HorizontalAlignment) {
        unsafe {
            self.0
                .set_horizontal_alignment
                .map(|f| {
                    let arg_alignment = alignment;
                    let arg_self_ = self.as_raw();
                    let arg_alignment = arg_alignment.as_raw();
                    let result = f(arg_self_, arg_alignment);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_minimum_size(&self, size: Option<&Size>) {
        unsafe {
            self.0
                .set_minimum_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_maximum_size(&self, size: Option<&Size>) {
        unsafe {
            self.0
                .set_maximum_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_label_button_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_label_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LabelButton {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_label_button_t> for &LabelButton {
    fn as_raw(self) -> *mut _cef_label_button_t {
        ImplLabelButton::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_label_button_t> for &mut LabelButton {
    fn as_raw(self) -> *mut _cef_label_button_t {
        ImplLabelButton::get_raw(self)
    }
}
impl ConvertReturnValue<LabelButton> for *mut _cef_label_button_t {
    fn as_wrapper(self) -> LabelButton {
        LabelButton(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_label_button_t> for LabelButton {
    fn into(self) -> *mut _cef_label_button_t {
        let object = ImplLabelButton::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for LabelButton {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_menu_button_pressed_lock_t] for more documentation.
#[derive(Clone)]
pub struct MenuButtonPressedLock(RefGuard<_cef_menu_button_pressed_lock_t>);
impl MenuButtonPressedLock {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMenuButtonPressedLock,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMenuButtonPressedLock>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMenuButtonPressedLock>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_menu_button_pressed_lock_t).as_wrapper()
        }
    }
}
pub trait WrapMenuButtonPressedLock: ImplMenuButtonPressedLock {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_menu_button_pressed_lock_t, Self>);
}
pub trait ImplMenuButtonPressedLock: Clone + Sized + Rc {
    fn init_methods(object: &mut _cef_menu_button_pressed_lock_t) {
        impl_cef_menu_button_pressed_lock_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_menu_button_pressed_lock_t;
}
mod impl_cef_menu_button_pressed_lock_t {
    use super::*;
    pub fn init_methods<I: ImplMenuButtonPressedLock>(
        object: &mut _cef_menu_button_pressed_lock_t,
    ) {
    }
}
impl ImplMenuButtonPressedLock for MenuButtonPressedLock {
    fn get_raw(&self) -> *mut _cef_menu_button_pressed_lock_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_menu_button_pressed_lock_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButtonPressedLock {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_pressed_lock_t> for &MenuButtonPressedLock {
    fn as_raw(self) -> *mut _cef_menu_button_pressed_lock_t {
        ImplMenuButtonPressedLock::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_button_pressed_lock_t> for &mut MenuButtonPressedLock {
    fn as_raw(self) -> *mut _cef_menu_button_pressed_lock_t {
        ImplMenuButtonPressedLock::get_raw(self)
    }
}
impl ConvertReturnValue<MenuButtonPressedLock> for *mut _cef_menu_button_pressed_lock_t {
    fn as_wrapper(self) -> MenuButtonPressedLock {
        MenuButtonPressedLock(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_button_pressed_lock_t> for MenuButtonPressedLock {
    fn into(self) -> *mut _cef_menu_button_pressed_lock_t {
        let object = ImplMenuButtonPressedLock::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MenuButtonPressedLock {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_menu_button_delegate_t] for more documentation.
#[derive(Clone)]
pub struct MenuButtonDelegate(RefGuard<_cef_menu_button_delegate_t>);
impl MenuButtonDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMenuButtonDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMenuButtonDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMenuButtonDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_menu_button_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapMenuButtonDelegate: ImplMenuButtonDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_menu_button_delegate_t, Self>);
}
pub trait ImplMenuButtonDelegate: ImplButtonDelegate {
    fn on_menu_button_pressed(
        &self,
        menu_button: Option<&mut impl ImplMenuButton>,
        screen_point: Option<&Point>,
        button_pressed_lock: Option<&mut impl ImplMenuButtonPressedLock>,
    ) {
    }
    fn init_methods(object: &mut _cef_menu_button_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_button_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_menu_button_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_menu_button_delegate_t {
        <Self as ImplButtonDelegate>::get_raw(self) as *mut _
    }
}
mod impl_cef_menu_button_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplMenuButtonDelegate>(object: &mut _cef_menu_button_delegate_t) {
        object.on_menu_button_pressed = Some(on_menu_button_pressed::<I>);
    }
    extern "C" fn on_menu_button_pressed<I: ImplMenuButtonDelegate>(
        self_: *mut _cef_menu_button_delegate_t,
        menu_button: *mut _cef_menu_button_t,
        screen_point: *const _cef_point_t,
        button_pressed_lock: *mut _cef_menu_button_pressed_lock_t,
    ) {
        let (arg_self_, arg_menu_button, arg_screen_point, arg_button_pressed_lock) =
            (self_, menu_button, screen_point, button_pressed_lock);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_button = unsafe { arg_menu_button.as_mut() }
            .map(|arg| MenuButton(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_button = arg_menu_button.as_mut();
        let arg_screen_point = if arg_screen_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_screen_point))
        };
        let arg_screen_point = arg_screen_point.as_ref().map(|arg| arg.as_ref());
        let mut arg_button_pressed_lock = unsafe { arg_button_pressed_lock.as_mut() }
            .map(|arg| MenuButtonPressedLock(unsafe { RefGuard::from_raw(arg) }));
        let arg_button_pressed_lock = arg_button_pressed_lock.as_mut();
        let result = ImplMenuButtonDelegate::on_menu_button_pressed(
            &arg_self_.interface,
            arg_menu_button,
            arg_screen_point,
            arg_button_pressed_lock,
        );
    }
}
impl ImplViewDelegate for MenuButtonDelegate {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplButtonDelegate for MenuButtonDelegate {
    fn on_button_pressed(&self, button: Option<&mut impl ImplButton>) {
        ButtonDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_button_pressed(button)
    }
    fn on_button_state_changed(&self, button: Option<&mut impl ImplButton>) {
        ButtonDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_button_state_changed(button)
    }
    fn get_raw(&self) -> *mut _cef_button_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplMenuButtonDelegate for MenuButtonDelegate {
    fn on_menu_button_pressed(
        &self,
        menu_button: Option<&mut impl ImplMenuButton>,
        screen_point: Option<&Point>,
        button_pressed_lock: Option<&mut impl ImplMenuButtonPressedLock>,
    ) {
        unsafe {
            self.0
                .on_menu_button_pressed
                .map(|f| {
                    let (arg_menu_button, arg_screen_point, arg_button_pressed_lock) =
                        (menu_button, screen_point, button_pressed_lock);
                    let arg_self_ = self.as_raw();
                    let arg_menu_button = arg_menu_button
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuButton::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                    let arg_screen_point = arg_screen_point
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_button_pressed_lock = arg_button_pressed_lock
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuButtonPressedLock::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_menu_button,
                        arg_screen_point,
                        arg_button_pressed_lock,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_button_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_menu_button_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButtonDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_delegate_t> for &MenuButtonDelegate {
    fn as_raw(self) -> *mut _cef_menu_button_delegate_t {
        ImplMenuButtonDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_button_delegate_t> for &mut MenuButtonDelegate {
    fn as_raw(self) -> *mut _cef_menu_button_delegate_t {
        ImplMenuButtonDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<MenuButtonDelegate> for *mut _cef_menu_button_delegate_t {
    fn as_wrapper(self) -> MenuButtonDelegate {
        MenuButtonDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_button_delegate_t> for MenuButtonDelegate {
    fn into(self) -> *mut _cef_menu_button_delegate_t {
        let object = ImplMenuButtonDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MenuButtonDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_menu_button_t] for more documentation.
#[derive(Clone)]
pub struct MenuButton(RefGuard<_cef_menu_button_t>);
impl MenuButton {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMenuButton,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMenuButton>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMenuButton>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_menu_button_t).as_wrapper()
        }
    }
}
pub trait WrapMenuButton: ImplMenuButton {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_menu_button_t, Self>);
}
pub trait ImplMenuButton: ImplLabelButton {
    fn show_menu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    ) {
    }
    fn trigger_menu(&self) {}
    fn init_methods(object: &mut _cef_menu_button_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base.base.base);
        impl_cef_button_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_label_button_t::init_methods::<Self>(&mut object.base);
        impl_cef_menu_button_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_menu_button_t {
        <Self as ImplLabelButton>::get_raw(self) as *mut _
    }
}
mod impl_cef_menu_button_t {
    use super::*;
    pub fn init_methods<I: ImplMenuButton>(object: &mut _cef_menu_button_t) {
        object.show_menu = Some(show_menu::<I>);
        object.trigger_menu = Some(trigger_menu::<I>);
    }
    extern "C" fn show_menu<I: ImplMenuButton>(
        self_: *mut _cef_menu_button_t,
        menu_model: *mut _cef_menu_model_t,
        screen_point: *const _cef_point_t,
        anchor_position: cef_menu_anchor_position_t,
    ) {
        let (arg_self_, arg_menu_model, arg_screen_point, arg_anchor_position) =
            (self_, menu_model, screen_point, anchor_position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_screen_point = if arg_screen_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_screen_point))
        };
        let arg_screen_point = arg_screen_point.as_ref().map(|arg| arg.as_ref());
        let arg_anchor_position = arg_anchor_position.as_raw();
        let result = ImplMenuButton::show_menu(
            &arg_self_.interface,
            arg_menu_model,
            arg_screen_point,
            arg_anchor_position,
        );
    }
    extern "C" fn trigger_menu<I: ImplMenuButton>(self_: *mut _cef_menu_button_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplMenuButton::trigger_menu(&arg_self_.interface);
    }
}
impl ImplView for MenuButton {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplButton for MenuButton {
    fn as_label_button(&self) -> Option<LabelButton> {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_label_button()
    }
    fn set_state(&self, state: ButtonState) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_state(state)
    }
    fn get_state(&self) -> ButtonState {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_state()
    }
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_ink_drop_enabled(enabled)
    }
    fn set_tooltip_text(&self, tooltip_text: Option<&CefStringUtf16>) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_tooltip_text(tooltip_text)
    }
    fn set_accessible_name(&self, name: Option<&CefStringUtf16>) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_accessible_name(name)
    }
    fn get_raw(&self) -> *mut _cef_button_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplLabelButton for MenuButton {
    fn as_menu_button(&self) -> Option<MenuButton> {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_menu_button()
    }
    fn set_text(&self, text: Option<&CefStringUtf16>) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_text(text)
    }
    fn get_text(&self) -> Option<CefStringUtf16> {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_text()
    }
    fn set_image(&self, button_state: ButtonState, image: Option<&mut impl ImplImage>) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_image(button_state, image)
    }
    fn get_image(&self, button_state: ButtonState) -> Option<Image> {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_image(button_state)
    }
    fn set_text_color(&self, for_state: ButtonState, color: u32) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_text_color(for_state, color)
    }
    fn set_enabled_text_colors(&self, color: u32) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled_text_colors(color)
    }
    fn set_font_list(&self, font_list: Option<&CefStringUtf16>) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_font_list(font_list)
    }
    fn set_horizontal_alignment(&self, alignment: HorizontalAlignment) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_horizontal_alignment(alignment)
    }
    fn set_minimum_size(&self, size: Option<&Size>) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_minimum_size(size)
    }
    fn set_maximum_size(&self, size: Option<&Size>) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_maximum_size(size)
    }
    fn get_raw(&self) -> *mut _cef_label_button_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplMenuButton for MenuButton {
    fn show_menu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe {
            self.0
                .show_menu
                .map(|f| {
                    let (arg_menu_model, arg_screen_point, arg_anchor_position) =
                        (menu_model, screen_point, anchor_position);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                    let arg_screen_point = arg_screen_point
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_anchor_position = arg_anchor_position.as_raw();
                    let result = f(
                        arg_self_,
                        arg_menu_model,
                        arg_screen_point,
                        arg_anchor_position,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn trigger_menu(&self) {
        unsafe {
            self.0
                .trigger_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_button_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_menu_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButton {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_t> for &MenuButton {
    fn as_raw(self) -> *mut _cef_menu_button_t {
        ImplMenuButton::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_button_t> for &mut MenuButton {
    fn as_raw(self) -> *mut _cef_menu_button_t {
        ImplMenuButton::get_raw(self)
    }
}
impl ConvertReturnValue<MenuButton> for *mut _cef_menu_button_t {
    fn as_wrapper(self) -> MenuButton {
        MenuButton(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_button_t> for MenuButton {
    fn into(self) -> *mut _cef_menu_button_t {
        let object = ImplMenuButton::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for MenuButton {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_textfield_delegate_t] for more documentation.
#[derive(Clone)]
pub struct TextfieldDelegate(RefGuard<_cef_textfield_delegate_t>);
impl TextfieldDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapTextfieldDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplTextfieldDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapTextfieldDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_textfield_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapTextfieldDelegate: ImplTextfieldDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_textfield_delegate_t, Self>);
}
pub trait ImplTextfieldDelegate: ImplViewDelegate {
    fn on_key_event(
        &self,
        textfield: Option<&mut impl ImplTextfield>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_after_user_action(&self, textfield: Option<&mut impl ImplTextfield>) {}
    fn init_methods(object: &mut _cef_textfield_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_textfield_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_textfield_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self) as *mut _
    }
}
mod impl_cef_textfield_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplTextfieldDelegate>(object: &mut _cef_textfield_delegate_t) {
        object.on_key_event = Some(on_key_event::<I>);
        object.on_after_user_action = Some(on_after_user_action::<I>);
    }
    extern "C" fn on_key_event<I: ImplTextfieldDelegate>(
        self_: *mut _cef_textfield_delegate_t,
        textfield: *mut _cef_textfield_t,
        event: *const _cef_key_event_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_textfield, arg_event) = (self_, textfield, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_textfield = unsafe { arg_textfield.as_mut() }
            .map(|arg| Textfield(unsafe { RefGuard::from_raw(arg) }));
        let arg_textfield = arg_textfield.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let result =
            ImplTextfieldDelegate::on_key_event(&arg_self_.interface, arg_textfield, arg_event);
        result.into()
    }
    extern "C" fn on_after_user_action<I: ImplTextfieldDelegate>(
        self_: *mut _cef_textfield_delegate_t,
        textfield: *mut _cef_textfield_t,
    ) {
        let (arg_self_, arg_textfield) = (self_, textfield);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_textfield = unsafe { arg_textfield.as_mut() }
            .map(|arg| Textfield(unsafe { RefGuard::from_raw(arg) }));
        let arg_textfield = arg_textfield.as_mut();
        let result =
            ImplTextfieldDelegate::on_after_user_action(&arg_self_.interface, arg_textfield);
    }
}
impl ImplViewDelegate for TextfieldDelegate {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplTextfieldDelegate for TextfieldDelegate {
    fn on_key_event(
        &self,
        textfield: Option<&mut impl ImplTextfield>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_textfield, arg_event) = (textfield, event);
                    let arg_self_ = self.as_raw();
                    let arg_textfield = arg_textfield
                        .map(|arg| {
                            arg.add_ref();
                            ImplTextfield::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_textfield, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_after_user_action(&self, textfield: Option<&mut impl ImplTextfield>) {
        unsafe {
            self.0
                .on_after_user_action
                .map(|f| {
                    let arg_textfield = textfield;
                    let arg_self_ = self.as_raw();
                    let arg_textfield = arg_textfield
                        .map(|arg| {
                            arg.add_ref();
                            ImplTextfield::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_textfield);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_textfield_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_textfield_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for TextfieldDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_textfield_delegate_t> for &TextfieldDelegate {
    fn as_raw(self) -> *mut _cef_textfield_delegate_t {
        ImplTextfieldDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_textfield_delegate_t> for &mut TextfieldDelegate {
    fn as_raw(self) -> *mut _cef_textfield_delegate_t {
        ImplTextfieldDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<TextfieldDelegate> for *mut _cef_textfield_delegate_t {
    fn as_wrapper(self) -> TextfieldDelegate {
        TextfieldDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_textfield_delegate_t> for TextfieldDelegate {
    fn into(self) -> *mut _cef_textfield_delegate_t {
        let object = ImplTextfieldDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for TextfieldDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_textfield_t] for more documentation.
#[derive(Clone)]
pub struct Textfield(RefGuard<_cef_textfield_t>);
impl Textfield {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapTextfield,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplTextfield>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapTextfield>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_textfield_t).as_wrapper()
        }
    }
}
pub trait WrapTextfield: ImplTextfield {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_textfield_t, Self>);
}
pub trait ImplTextfield: ImplView {
    fn set_password_input(&self, password_input: ::std::os::raw::c_int) {}
    fn is_password_input(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn set_read_only(&self, read_only: ::std::os::raw::c_int) {}
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_text(&self, text: Option<&CefStringUtf16>) {}
    fn append_text(&self, text: Option<&CefStringUtf16>) {}
    fn insert_or_replace_text(&self, text: Option<&CefStringUtf16>) {}
    fn has_selection(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_selected_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn select_all(&self, reversed: ::std::os::raw::c_int) {}
    fn clear_selection(&self) {}
    fn get_selected_range(&self) -> Range {
        Default::default()
    }
    fn select_range(&self, range: Option<&Range>) {}
    fn get_cursor_position(&self) -> usize {
        Default::default()
    }
    fn set_text_color(&self, color: u32) {}
    fn get_text_color(&self) -> cef_color_t {
        Default::default()
    }
    fn set_selection_text_color(&self, color: u32) {}
    fn get_selection_text_color(&self) -> cef_color_t {
        Default::default()
    }
    fn set_selection_background_color(&self, color: u32) {}
    fn get_selection_background_color(&self) -> cef_color_t {
        Default::default()
    }
    fn set_font_list(&self, font_list: Option<&CefStringUtf16>) {}
    fn apply_text_color(&self, color: u32, range: Option<&Range>) {}
    fn apply_text_style(
        &self,
        style: TextStyle,
        add: ::std::os::raw::c_int,
        range: Option<&Range>,
    ) {
    }
    fn is_command_enabled(&self, command_id: TextFieldCommands) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn execute_command(&self, command_id: TextFieldCommands) {}
    fn clear_edit_history(&self) {}
    fn set_placeholder_text(&self, text: Option<&CefStringUtf16>) {}
    fn get_placeholder_text(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_placeholder_text_color(&self, color: u32) {}
    fn set_accessible_name(&self, name: Option<&CefStringUtf16>) {}
    fn init_methods(object: &mut _cef_textfield_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_textfield_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_textfield_t {
        <Self as ImplView>::get_raw(self) as *mut _
    }
}
mod impl_cef_textfield_t {
    use super::*;
    pub fn init_methods<I: ImplTextfield>(object: &mut _cef_textfield_t) {
        object.set_password_input = Some(set_password_input::<I>);
        object.is_password_input = Some(is_password_input::<I>);
        object.set_read_only = Some(set_read_only::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.get_text = Some(get_text::<I>);
        object.set_text = Some(set_text::<I>);
        object.append_text = Some(append_text::<I>);
        object.insert_or_replace_text = Some(insert_or_replace_text::<I>);
        object.has_selection = Some(has_selection::<I>);
        object.get_selected_text = Some(get_selected_text::<I>);
        object.select_all = Some(select_all::<I>);
        object.clear_selection = Some(clear_selection::<I>);
        object.get_selected_range = Some(get_selected_range::<I>);
        object.select_range = Some(select_range::<I>);
        object.get_cursor_position = Some(get_cursor_position::<I>);
        object.set_text_color = Some(set_text_color::<I>);
        object.get_text_color = Some(get_text_color::<I>);
        object.set_selection_text_color = Some(set_selection_text_color::<I>);
        object.get_selection_text_color = Some(get_selection_text_color::<I>);
        object.set_selection_background_color = Some(set_selection_background_color::<I>);
        object.get_selection_background_color = Some(get_selection_background_color::<I>);
        object.set_font_list = Some(set_font_list::<I>);
        object.apply_text_color = Some(apply_text_color::<I>);
        object.apply_text_style = Some(apply_text_style::<I>);
        object.is_command_enabled = Some(is_command_enabled::<I>);
        object.execute_command = Some(execute_command::<I>);
        object.clear_edit_history = Some(clear_edit_history::<I>);
        object.set_placeholder_text = Some(set_placeholder_text::<I>);
        object.get_placeholder_text = Some(get_placeholder_text::<I>);
        object.set_placeholder_text_color = Some(set_placeholder_text_color::<I>);
        object.set_accessible_name = Some(set_accessible_name::<I>);
    }
    extern "C" fn set_password_input<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        password_input: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_password_input) = (self_, password_input);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_password_input = arg_password_input.as_raw();
        let result = ImplTextfield::set_password_input(&arg_self_.interface, arg_password_input);
    }
    extern "C" fn is_password_input<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::is_password_input(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_read_only<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        read_only: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_read_only) = (self_, read_only);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_read_only = arg_read_only.as_raw();
        let result = ImplTextfield::set_read_only(&arg_self_.interface, arg_read_only);
    }
    extern "C" fn is_read_only<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::is_read_only(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let result = ImplTextfield::set_text(&arg_self_.interface, arg_text);
    }
    extern "C" fn append_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let result = ImplTextfield::append_text(&arg_self_.interface, arg_text);
    }
    extern "C" fn insert_or_replace_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let result = ImplTextfield::insert_or_replace_text(&arg_self_.interface, arg_text);
    }
    extern "C" fn has_selection<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::has_selection(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_selected_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_selected_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn select_all<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        reversed: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_reversed) = (self_, reversed);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_reversed = arg_reversed.as_raw();
        let result = ImplTextfield::select_all(&arg_self_.interface, arg_reversed);
    }
    extern "C" fn clear_selection<I: ImplTextfield>(self_: *mut _cef_textfield_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::clear_selection(&arg_self_.interface);
    }
    extern "C" fn get_selected_range<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> _cef_range_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_selected_range(&arg_self_.interface);
        result.into()
    }
    extern "C" fn select_range<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_range) = (self_, range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_range = if arg_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_range))
        };
        let arg_range = arg_range.as_ref().map(|arg| arg.as_ref());
        let result = ImplTextfield::select_range(&arg_self_.interface, arg_range);
    }
    extern "C" fn get_cursor_position<I: ImplTextfield>(self_: *mut _cef_textfield_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_cursor_position(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_text_color<I: ImplTextfield>(self_: *mut _cef_textfield_t, color: u32) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let result = ImplTextfield::set_text_color(&arg_self_.interface, arg_color);
    }
    extern "C" fn get_text_color<I: ImplTextfield>(self_: *mut _cef_textfield_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_text_color(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_selection_text_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let result = ImplTextfield::set_selection_text_color(&arg_self_.interface, arg_color);
    }
    extern "C" fn get_selection_text_color<I: ImplTextfield>(self_: *mut _cef_textfield_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_selection_text_color(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_selection_background_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let result = ImplTextfield::set_selection_background_color(&arg_self_.interface, arg_color);
    }
    extern "C" fn get_selection_background_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_selection_background_color(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_font_list<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        font_list: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_font_list) = (self_, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_font_list = if arg_font_list.is_null() {
            None
        } else {
            Some(arg_font_list.into())
        };
        let arg_font_list = arg_font_list.as_ref();
        let result = ImplTextfield::set_font_list(&arg_self_.interface, arg_font_list);
    }
    extern "C" fn apply_text_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
        range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_color, arg_range) = (self_, color, range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let arg_range = if arg_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_range))
        };
        let arg_range = arg_range.as_ref().map(|arg| arg.as_ref());
        let result = ImplTextfield::apply_text_color(&arg_self_.interface, arg_color, arg_range);
    }
    extern "C" fn apply_text_style<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        style: cef_text_style_t,
        add: ::std::os::raw::c_int,
        range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_style, arg_add, arg_range) = (self_, style, add, range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_style = arg_style.as_raw();
        let arg_add = arg_add.as_raw();
        let arg_range = if arg_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range>::from(arg_range))
        };
        let arg_range = arg_range.as_ref().map(|arg| arg.as_ref());
        let result =
            ImplTextfield::apply_text_style(&arg_self_.interface, arg_style, arg_add, arg_range);
    }
    extern "C" fn is_command_enabled<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        command_id: cef_text_field_commands_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplTextfield::is_command_enabled(&arg_self_.interface, arg_command_id);
        result.into()
    }
    extern "C" fn execute_command<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        command_id: cef_text_field_commands_t,
    ) {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplTextfield::execute_command(&arg_self_.interface, arg_command_id);
    }
    extern "C" fn clear_edit_history<I: ImplTextfield>(self_: *mut _cef_textfield_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::clear_edit_history(&arg_self_.interface);
    }
    extern "C" fn set_placeholder_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_ref();
        let result = ImplTextfield::set_placeholder_text(&arg_self_.interface, arg_text);
    }
    extern "C" fn get_placeholder_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplTextfield::get_placeholder_text(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_placeholder_text_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let result = ImplTextfield::set_placeholder_text_color(&arg_self_.interface, arg_color);
    }
    extern "C" fn set_accessible_name<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let result = ImplTextfield::set_accessible_name(&arg_self_.interface, arg_name);
    }
}
impl ImplView for Textfield {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplTextfield for Textfield {
    fn set_password_input(&self, password_input: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_password_input
                .map(|f| {
                    let arg_password_input = password_input;
                    let arg_self_ = self.as_raw();
                    let arg_password_input = arg_password_input;
                    let result = f(arg_self_, arg_password_input);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_password_input(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_password_input
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_read_only(&self, read_only: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_read_only
                .map(|f| {
                    let arg_read_only = read_only;
                    let arg_self_ = self.as_raw();
                    let arg_read_only = arg_read_only;
                    let result = f(arg_self_, arg_read_only);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_text(&self, text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_text(&self, text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .append_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn insert_or_replace_text(&self, text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .insert_or_replace_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_selection(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_selection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_selected_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_selected_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn select_all(&self, reversed: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .select_all
                .map(|f| {
                    let arg_reversed = reversed;
                    let arg_self_ = self.as_raw();
                    let arg_reversed = arg_reversed;
                    let result = f(arg_self_, arg_reversed);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_selection(&self) {
        unsafe {
            self.0
                .clear_selection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selected_range(&self) -> Range {
        unsafe {
            self.0
                .get_selected_range
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn select_range(&self, range: Option<&Range>) {
        unsafe {
            self.0
                .select_range
                .map(|f| {
                    let arg_range = range;
                    let arg_self_ = self.as_raw();
                    let arg_range = arg_range.cloned().map(|arg| arg.into());
                    let arg_range = arg_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_range);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_cursor_position(&self) -> usize {
        unsafe {
            self.0
                .get_cursor_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_text_color(&self, color: u32) {
        unsafe {
            self.0
                .set_text_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_text_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_text_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_selection_text_color(&self, color: u32) {
        unsafe {
            self.0
                .set_selection_text_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_text_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_selection_text_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_selection_background_color(&self, color: u32) {
        unsafe {
            self.0
                .set_selection_background_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_background_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_selection_background_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_font_list(&self, font_list: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_font_list
                .map(|f| {
                    let arg_font_list = font_list;
                    let arg_self_ = self.as_raw();
                    let arg_font_list = arg_font_list
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn apply_text_color(&self, color: u32, range: Option<&Range>) {
        unsafe {
            self.0
                .apply_text_color
                .map(|f| {
                    let (arg_color, arg_range) = (color, range);
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let arg_range = arg_range.cloned().map(|arg| arg.into());
                    let arg_range = arg_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_color, arg_range);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn apply_text_style(
        &self,
        style: TextStyle,
        add: ::std::os::raw::c_int,
        range: Option<&Range>,
    ) {
        unsafe {
            self.0
                .apply_text_style
                .map(|f| {
                    let (arg_style, arg_add, arg_range) = (style, add, range);
                    let arg_self_ = self.as_raw();
                    let arg_style = arg_style.as_raw();
                    let arg_add = arg_add;
                    let arg_range = arg_range.cloned().map(|arg| arg.into());
                    let arg_range = arg_range
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_style, arg_add, arg_range);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_command_enabled(&self, command_id: TextFieldCommands) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_command_enabled
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id.as_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn execute_command(&self, command_id: TextFieldCommands) {
        unsafe {
            self.0
                .execute_command
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id.as_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_edit_history(&self) {
        unsafe {
            self.0
                .clear_edit_history
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_placeholder_text(&self, text: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_placeholder_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_placeholder_text(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_placeholder_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_placeholder_text_color(&self, color: u32) {
        unsafe {
            self.0
                .set_placeholder_text_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accessible_name(&self, name: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_accessible_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_textfield_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_textfield_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Textfield {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_textfield_t> for &Textfield {
    fn as_raw(self) -> *mut _cef_textfield_t {
        ImplTextfield::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_textfield_t> for &mut Textfield {
    fn as_raw(self) -> *mut _cef_textfield_t {
        ImplTextfield::get_raw(self)
    }
}
impl ConvertReturnValue<Textfield> for *mut _cef_textfield_t {
    fn as_wrapper(self) -> Textfield {
        Textfield(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_textfield_t> for Textfield {
    fn into(self) -> *mut _cef_textfield_t {
        let object = ImplTextfield::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Textfield {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_browser_view_delegate_t] for more documentation.
#[derive(Clone)]
pub struct BrowserViewDelegate(RefGuard<_cef_browser_view_delegate_t>);
impl BrowserViewDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBrowserViewDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBrowserViewDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBrowserViewDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_browser_view_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapBrowserViewDelegate: ImplBrowserViewDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_browser_view_delegate_t, Self>);
}
pub trait ImplBrowserViewDelegate: ImplViewDelegate {
    fn on_browser_created(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        browser: Option<&mut impl ImplBrowser>,
    ) {
    }
    fn on_browser_destroyed(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        browser: Option<&mut impl ImplBrowser>,
    ) {
    }
    fn get_delegate_for_popup_browser_view(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        settings: Option<&BrowserSettings>,
        client: Option<&mut impl ImplClient>,
        is_devtools: ::std::os::raw::c_int,
    ) -> Option<BrowserViewDelegate> {
        Default::default()
    }
    fn on_popup_browser_view_created(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        popup_browser_view: Option<&mut impl ImplBrowserView>,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_chrome_toolbar_type(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
    ) -> ChromeToolbarType {
        Default::default()
    }
    fn use_frameless_window_for_picture_in_picture(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_gesture_command(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        gesture_command: GestureCommand,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_browser_runtime_style(&self) -> RuntimeStyle {
        Default::default()
    }
    fn init_methods(object: &mut _cef_browser_view_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_browser_view_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_browser_view_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self) as *mut _
    }
}
mod impl_cef_browser_view_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserViewDelegate>(object: &mut _cef_browser_view_delegate_t) {
        object.on_browser_created = Some(on_browser_created::<I>);
        object.on_browser_destroyed = Some(on_browser_destroyed::<I>);
        object.get_delegate_for_popup_browser_view = Some(get_delegate_for_popup_browser_view::<I>);
        object.on_popup_browser_view_created = Some(on_popup_browser_view_created::<I>);
        object.get_chrome_toolbar_type = Some(get_chrome_toolbar_type::<I>);
        object.use_frameless_window_for_picture_in_picture =
            Some(use_frameless_window_for_picture_in_picture::<I>);
        object.on_gesture_command = Some(on_gesture_command::<I>);
        object.get_browser_runtime_style = Some(get_browser_runtime_style::<I>);
    }
    extern "C" fn on_browser_created<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser_view, arg_browser) = (self_, browser_view, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplBrowserViewDelegate::on_browser_created(
            &arg_self_.interface,
            arg_browser_view,
            arg_browser,
        );
    }
    extern "C" fn on_browser_destroyed<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser_view, arg_browser) = (self_, browser_view, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let result = ImplBrowserViewDelegate::on_browser_destroyed(
            &arg_self_.interface,
            arg_browser_view,
            arg_browser,
        );
    }
    extern "C" fn get_delegate_for_popup_browser_view<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        settings: *const _cef_browser_settings_t,
        client: *mut _cef_client_t,
        is_devtools: ::std::os::raw::c_int,
    ) -> *mut _cef_browser_view_delegate_t {
        let (arg_self_, arg_browser_view, arg_settings, arg_client, arg_is_devtools) =
            (self_, browser_view, settings, client, is_devtools);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BrowserSettings>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_ref().map(|arg| arg.as_ref());
        let mut arg_client =
            unsafe { arg_client.as_mut() }.map(|arg| Client(unsafe { RefGuard::from_raw(arg) }));
        let arg_client = arg_client.as_mut();
        let arg_is_devtools = arg_is_devtools.as_raw();
        let result = ImplBrowserViewDelegate::get_delegate_for_popup_browser_view(
            &arg_self_.interface,
            arg_browser_view,
            arg_settings,
            arg_client,
            arg_is_devtools,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_popup_browser_view_created<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        popup_browser_view: *mut _cef_browser_view_t,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view, arg_popup_browser_view, arg_is_devtools) =
            (self_, browser_view, popup_browser_view, is_devtools);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let mut arg_popup_browser_view = unsafe { arg_popup_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_popup_browser_view = arg_popup_browser_view.as_mut();
        let arg_is_devtools = arg_is_devtools.as_raw();
        let result = ImplBrowserViewDelegate::on_popup_browser_view_created(
            &arg_self_.interface,
            arg_browser_view,
            arg_popup_browser_view,
            arg_is_devtools,
        );
        result.into()
    }
    extern "C" fn get_chrome_toolbar_type<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
    ) -> cef_chrome_toolbar_type_t {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let result = ImplBrowserViewDelegate::get_chrome_toolbar_type(
            &arg_self_.interface,
            arg_browser_view,
        );
        result.into()
    }
    extern "C" fn use_frameless_window_for_picture_in_picture<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let result = ImplBrowserViewDelegate::use_frameless_window_for_picture_in_picture(
            &arg_self_.interface,
            arg_browser_view,
        );
        result.into()
    }
    extern "C" fn on_gesture_command<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        gesture_command: cef_gesture_command_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view, arg_gesture_command) =
            (self_, browser_view, gesture_command);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let arg_gesture_command = arg_gesture_command.as_raw();
        let result = ImplBrowserViewDelegate::on_gesture_command(
            &arg_self_.interface,
            arg_browser_view,
            arg_gesture_command,
        );
        result.into()
    }
    extern "C" fn get_browser_runtime_style<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserViewDelegate::get_browser_runtime_style(&arg_self_.interface);
        result.into()
    }
}
impl ImplViewDelegate for BrowserViewDelegate {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplBrowserViewDelegate for BrowserViewDelegate {
    fn on_browser_created(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        browser: Option<&mut impl ImplBrowser>,
    ) {
        unsafe {
            self.0
                .on_browser_created
                .map(|f| {
                    let (arg_browser_view, arg_browser) = (browser_view, browser);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser_view, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_browser_destroyed(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        browser: Option<&mut impl ImplBrowser>,
    ) {
        unsafe {
            self.0
                .on_browser_destroyed
                .map(|f| {
                    let (arg_browser_view, arg_browser) = (browser_view, browser);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser_view, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_delegate_for_popup_browser_view(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        settings: Option<&BrowserSettings>,
        client: Option<&mut impl ImplClient>,
        is_devtools: ::std::os::raw::c_int,
    ) -> Option<BrowserViewDelegate> {
        unsafe {
            self.0
                .get_delegate_for_popup_browser_view
                .map(|f| {
                    let (arg_browser_view, arg_settings, arg_client, arg_is_devtools) =
                        (browser_view, settings, client, is_devtools);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_client = arg_client
                        .map(|arg| {
                            arg.add_ref();
                            ImplClient::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_devtools = arg_is_devtools;
                    let result = f(
                        arg_self_,
                        arg_browser_view,
                        arg_settings,
                        arg_client,
                        arg_is_devtools,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_popup_browser_view_created(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        popup_browser_view: Option<&mut impl ImplBrowserView>,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_popup_browser_view_created
                .map(|f| {
                    let (arg_browser_view, arg_popup_browser_view, arg_is_devtools) =
                        (browser_view, popup_browser_view, is_devtools);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_popup_browser_view = arg_popup_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_devtools = arg_is_devtools;
                    let result = f(
                        arg_self_,
                        arg_browser_view,
                        arg_popup_browser_view,
                        arg_is_devtools,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_chrome_toolbar_type(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
    ) -> ChromeToolbarType {
        unsafe {
            self.0
                .get_chrome_toolbar_type
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser_view);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn use_frameless_window_for_picture_in_picture(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .use_frameless_window_for_picture_in_picture
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser_view);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_gesture_command(
        &self,
        browser_view: Option<&mut impl ImplBrowserView>,
        gesture_command: GestureCommand,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_gesture_command
                .map(|f| {
                    let (arg_browser_view, arg_gesture_command) = (browser_view, gesture_command);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_gesture_command = arg_gesture_command.as_raw();
                    let result = f(arg_self_, arg_browser_view, arg_gesture_command);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_browser_runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_browser_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_browser_view_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserViewDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_view_delegate_t> for &BrowserViewDelegate {
    fn as_raw(self) -> *mut _cef_browser_view_delegate_t {
        ImplBrowserViewDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_view_delegate_t> for &mut BrowserViewDelegate {
    fn as_raw(self) -> *mut _cef_browser_view_delegate_t {
        ImplBrowserViewDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserViewDelegate> for *mut _cef_browser_view_delegate_t {
    fn as_wrapper(self) -> BrowserViewDelegate {
        BrowserViewDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_view_delegate_t> for BrowserViewDelegate {
    fn into(self) -> *mut _cef_browser_view_delegate_t {
        let object = ImplBrowserViewDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for BrowserViewDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_browser_view_t] for more documentation.
#[derive(Clone)]
pub struct BrowserView(RefGuard<_cef_browser_view_t>);
impl BrowserView {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBrowserView,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBrowserView>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBrowserView>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_browser_view_t).as_wrapper()
        }
    }
}
pub trait WrapBrowserView: ImplBrowserView {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_browser_view_t, Self>);
}
pub trait ImplBrowserView: ImplView {
    fn get_browser(&self) -> Option<Browser> {
        Default::default()
    }
    fn get_chrome_toolbar(&self) -> Option<View> {
        Default::default()
    }
    fn set_prefer_accelerators(&self, prefer_accelerators: ::std::os::raw::c_int) {}
    fn get_runtime_style(&self) -> RuntimeStyle {
        Default::default()
    }
    fn init_methods(object: &mut _cef_browser_view_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_browser_view_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_browser_view_t {
        <Self as ImplView>::get_raw(self) as *mut _
    }
}
mod impl_cef_browser_view_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserView>(object: &mut _cef_browser_view_t) {
        object.get_browser = Some(get_browser::<I>);
        object.get_chrome_toolbar = Some(get_chrome_toolbar::<I>);
        object.set_prefer_accelerators = Some(set_prefer_accelerators::<I>);
        object.get_runtime_style = Some(get_runtime_style::<I>);
    }
    extern "C" fn get_browser<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
    ) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserView::get_browser(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_chrome_toolbar<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
    ) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserView::get_chrome_toolbar(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_prefer_accelerators<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
        prefer_accelerators: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_prefer_accelerators) = (self_, prefer_accelerators);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_prefer_accelerators = arg_prefer_accelerators.as_raw();
        let result =
            ImplBrowserView::set_prefer_accelerators(&arg_self_.interface, arg_prefer_accelerators);
    }
    extern "C" fn get_runtime_style<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserView::get_runtime_style(&arg_self_.interface);
        result.into()
    }
}
impl ImplView for BrowserView {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplBrowserView for BrowserView {
    fn get_browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_chrome_toolbar(&self) -> Option<View> {
        unsafe {
            self.0
                .get_chrome_toolbar
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_prefer_accelerators(&self, prefer_accelerators: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_prefer_accelerators
                .map(|f| {
                    let arg_prefer_accelerators = prefer_accelerators;
                    let arg_self_ = self.as_raw();
                    let arg_prefer_accelerators = arg_prefer_accelerators;
                    let result = f(arg_self_, arg_prefer_accelerators);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_view_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_browser_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserView {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_view_t> for &BrowserView {
    fn as_raw(self) -> *mut _cef_browser_view_t {
        ImplBrowserView::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_view_t> for &mut BrowserView {
    fn as_raw(self) -> *mut _cef_browser_view_t {
        ImplBrowserView::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserView> for *mut _cef_browser_view_t {
    fn as_wrapper(self) -> BrowserView {
        BrowserView(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_view_t> for BrowserView {
    fn into(self) -> *mut _cef_browser_view_t {
        let object = ImplBrowserView::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for BrowserView {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_scroll_view_t] for more documentation.
#[derive(Clone)]
pub struct ScrollView(RefGuard<_cef_scroll_view_t>);
impl ScrollView {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapScrollView,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplScrollView>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapScrollView>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_scroll_view_t).as_wrapper()
        }
    }
}
pub trait WrapScrollView: ImplScrollView {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_scroll_view_t, Self>);
}
pub trait ImplScrollView: ImplView {
    fn set_content_view(&self, view: Option<&mut impl ImplView>) {}
    fn get_content_view(&self) -> Option<View> {
        Default::default()
    }
    fn get_visible_content_rect(&self) -> Rect {
        Default::default()
    }
    fn has_horizontal_scrollbar(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_horizontal_scrollbar_height(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn has_vertical_scrollbar(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_vertical_scrollbar_width(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_scroll_view_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_scroll_view_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_scroll_view_t {
        <Self as ImplView>::get_raw(self) as *mut _
    }
}
mod impl_cef_scroll_view_t {
    use super::*;
    pub fn init_methods<I: ImplScrollView>(object: &mut _cef_scroll_view_t) {
        object.set_content_view = Some(set_content_view::<I>);
        object.get_content_view = Some(get_content_view::<I>);
        object.get_visible_content_rect = Some(get_visible_content_rect::<I>);
        object.has_horizontal_scrollbar = Some(has_horizontal_scrollbar::<I>);
        object.get_horizontal_scrollbar_height = Some(get_horizontal_scrollbar_height::<I>);
        object.has_vertical_scrollbar = Some(has_vertical_scrollbar::<I>);
        object.get_vertical_scrollbar_width = Some(get_vertical_scrollbar_width::<I>);
    }
    extern "C" fn set_content_view<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplScrollView::set_content_view(&arg_self_.interface, arg_view);
    }
    extern "C" fn get_content_view<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplScrollView::get_content_view(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_visible_content_rect<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplScrollView::get_visible_content_rect(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_horizontal_scrollbar<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplScrollView::has_horizontal_scrollbar(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_horizontal_scrollbar_height<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplScrollView::get_horizontal_scrollbar_height(&arg_self_.interface);
        result.into()
    }
    extern "C" fn has_vertical_scrollbar<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplScrollView::has_vertical_scrollbar(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_vertical_scrollbar_width<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplScrollView::get_vertical_scrollbar_width(&arg_self_.interface);
        result.into()
    }
}
impl ImplView for ScrollView {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplScrollView for ScrollView {
    fn set_content_view(&self, view: Option<&mut impl ImplView>) {
        unsafe {
            self.0
                .set_content_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_content_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_content_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_visible_content_rect(&self) -> Rect {
        unsafe {
            self.0
                .get_visible_content_rect
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_horizontal_scrollbar(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_horizontal_scrollbar
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_horizontal_scrollbar_height(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_horizontal_scrollbar_height
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn has_vertical_scrollbar(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_vertical_scrollbar
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_vertical_scrollbar_width(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_vertical_scrollbar_width
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_scroll_view_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_scroll_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ScrollView {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_scroll_view_t> for &ScrollView {
    fn as_raw(self) -> *mut _cef_scroll_view_t {
        ImplScrollView::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_scroll_view_t> for &mut ScrollView {
    fn as_raw(self) -> *mut _cef_scroll_view_t {
        ImplScrollView::get_raw(self)
    }
}
impl ConvertReturnValue<ScrollView> for *mut _cef_scroll_view_t {
    fn as_wrapper(self) -> ScrollView {
        ScrollView(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_scroll_view_t> for ScrollView {
    fn into(self) -> *mut _cef_scroll_view_t {
        let object = ImplScrollView::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for ScrollView {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_display_t] for more documentation.
#[derive(Clone)]
pub struct Display(RefGuard<_cef_display_t>);
impl Display {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDisplay,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDisplay>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDisplay>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_display_t).as_wrapper()
        }
    }
}
pub trait WrapDisplay: ImplDisplay {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_display_t, Self>);
}
pub trait ImplDisplay: Clone + Sized + Rc {
    fn get_id(&self) -> i64 {
        Default::default()
    }
    fn get_device_scale_factor(&self) -> f32 {
        Default::default()
    }
    fn convert_point_to_pixels(&self, point: Option<&mut Point>) {}
    fn convert_point_from_pixels(&self, point: Option<&mut Point>) {}
    fn get_bounds(&self) -> Rect {
        Default::default()
    }
    fn get_work_area(&self) -> Rect {
        Default::default()
    }
    fn get_rotation(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_display_t) {
        impl_cef_display_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_display_t;
}
mod impl_cef_display_t {
    use super::*;
    pub fn init_methods<I: ImplDisplay>(object: &mut _cef_display_t) {
        object.get_id = Some(get_id::<I>);
        object.get_device_scale_factor = Some(get_device_scale_factor::<I>);
        object.convert_point_to_pixels = Some(convert_point_to_pixels::<I>);
        object.convert_point_from_pixels = Some(convert_point_from_pixels::<I>);
        object.get_bounds = Some(get_bounds::<I>);
        object.get_work_area = Some(get_work_area::<I>);
        object.get_rotation = Some(get_rotation::<I>);
    }
    extern "C" fn get_id<I: ImplDisplay>(self_: *mut _cef_display_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDisplay::get_id(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_device_scale_factor<I: ImplDisplay>(self_: *mut _cef_display_t) -> f32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDisplay::get_device_scale_factor(&arg_self_.interface);
        result.into()
    }
    extern "C" fn convert_point_to_pixels<I: ImplDisplay>(
        self_: *mut _cef_display_t,
        point: *mut _cef_point_t,
    ) {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplDisplay::convert_point_to_pixels(&arg_self_.interface, arg_point);
    }
    extern "C" fn convert_point_from_pixels<I: ImplDisplay>(
        self_: *mut _cef_display_t,
        point: *mut _cef_point_t,
    ) {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = if arg_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_point))
        };
        let arg_point = arg_point.as_mut().map(|arg| arg.as_mut());
        let result = ImplDisplay::convert_point_from_pixels(&arg_self_.interface, arg_point);
    }
    extern "C" fn get_bounds<I: ImplDisplay>(self_: *mut _cef_display_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDisplay::get_bounds(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_work_area<I: ImplDisplay>(self_: *mut _cef_display_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDisplay::get_work_area(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_rotation<I: ImplDisplay>(
        self_: *mut _cef_display_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplDisplay::get_rotation(&arg_self_.interface);
        result.into()
    }
}
impl ImplDisplay for Display {
    fn get_id(&self) -> i64 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_device_scale_factor(&self) -> f32 {
        unsafe {
            self.0
                .get_device_scale_factor
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_pixels(&self, point: Option<&mut Point>) {
        unsafe {
            self.0
                .convert_point_to_pixels
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_from_pixels(&self, point: Option<&mut Point>) {
        unsafe {
            self.0
                .convert_point_from_pixels
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_work_area(&self) -> Rect {
        unsafe {
            self.0
                .get_work_area
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_rotation(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_rotation
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_display_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_display_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Display {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_display_t> for &Display {
    fn as_raw(self) -> *mut _cef_display_t {
        ImplDisplay::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_display_t> for &mut Display {
    fn as_raw(self) -> *mut _cef_display_t {
        ImplDisplay::get_raw(self)
    }
}
impl ConvertReturnValue<Display> for *mut _cef_display_t {
    fn as_wrapper(self) -> Display {
        Display(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_display_t> for Display {
    fn into(self) -> *mut _cef_display_t {
        let object = ImplDisplay::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Display {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_overlay_controller_t] for more documentation.
#[derive(Clone)]
pub struct OverlayController(RefGuard<_cef_overlay_controller_t>);
impl OverlayController {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapOverlayController,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplOverlayController>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapOverlayController>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_overlay_controller_t).as_wrapper()
        }
    }
}
pub trait WrapOverlayController: ImplOverlayController {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_overlay_controller_t, Self>);
}
pub trait ImplOverlayController: Clone + Sized + Rc {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_same(&self, that: Option<&mut impl ImplOverlayController>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_contents_view(&self) -> Option<View> {
        Default::default()
    }
    fn get_window(&self) -> Option<Window> {
        Default::default()
    }
    fn get_docking_mode(&self) -> DockingMode {
        Default::default()
    }
    fn destroy(&self) {}
    fn set_bounds(&self, bounds: Option<&Rect>) {}
    fn get_bounds(&self) -> Rect {
        Default::default()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        Default::default()
    }
    fn set_size(&self, size: Option<&Size>) {}
    fn get_size(&self) -> Size {
        Default::default()
    }
    fn set_position(&self, position: Option<&Point>) {}
    fn get_position(&self) -> Point {
        Default::default()
    }
    fn set_insets(&self, insets: Option<&Insets>) {}
    fn get_insets(&self) -> Insets {
        Default::default()
    }
    fn size_to_preferred_size(&self) {}
    fn set_visible(&self, visible: ::std::os::raw::c_int) {}
    fn is_visible(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_overlay_controller_t) {
        impl_cef_overlay_controller_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_overlay_controller_t;
}
mod impl_cef_overlay_controller_t {
    use super::*;
    pub fn init_methods<I: ImplOverlayController>(object: &mut _cef_overlay_controller_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_contents_view = Some(get_contents_view::<I>);
        object.get_window = Some(get_window::<I>);
        object.get_docking_mode = Some(get_docking_mode::<I>);
        object.destroy = Some(destroy::<I>);
        object.set_bounds = Some(set_bounds::<I>);
        object.get_bounds = Some(get_bounds::<I>);
        object.get_bounds_in_screen = Some(get_bounds_in_screen::<I>);
        object.set_size = Some(set_size::<I>);
        object.get_size = Some(get_size::<I>);
        object.set_position = Some(set_position::<I>);
        object.get_position = Some(get_position::<I>);
        object.set_insets = Some(set_insets::<I>);
        object.get_insets = Some(get_insets::<I>);
        object.size_to_preferred_size = Some(size_to_preferred_size::<I>);
        object.set_visible = Some(set_visible::<I>);
        object.is_visible = Some(is_visible::<I>);
        object.is_drawn = Some(is_drawn::<I>);
    }
    extern "C" fn is_valid<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::is_valid(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_same<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        that: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_that = unsafe { arg_that.as_mut() }
            .map(|arg| OverlayController(unsafe { RefGuard::from_raw(arg) }));
        let arg_that = arg_that.as_mut();
        let result = ImplOverlayController::is_same(&arg_self_.interface, arg_that);
        result.into()
    }
    extern "C" fn get_contents_view<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_contents_view(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_window<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> *mut _cef_window_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_window(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_docking_mode<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> cef_docking_mode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_docking_mode(&arg_self_.interface);
        result.into()
    }
    extern "C" fn destroy<I: ImplOverlayController>(self_: *mut _cef_overlay_controller_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::destroy(&arg_self_.interface);
    }
    extern "C" fn set_bounds<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_bounds) = (self_, bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bounds = if arg_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_bounds))
        };
        let arg_bounds = arg_bounds.as_ref().map(|arg| arg.as_ref());
        let result = ImplOverlayController::set_bounds(&arg_self_.interface, arg_bounds);
    }
    extern "C" fn get_bounds<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_bounds(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_bounds_in_screen<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_bounds_in_screen(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_size<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_size))
        };
        let arg_size = arg_size.as_ref().map(|arg| arg.as_ref());
        let result = ImplOverlayController::set_size(&arg_self_.interface, arg_size);
    }
    extern "C" fn get_size<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_size(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_position<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        position: *const _cef_point_t,
    ) {
        let (arg_self_, arg_position) = (self_, position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_position = if arg_position.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_position))
        };
        let arg_position = arg_position.as_ref().map(|arg| arg.as_ref());
        let result = ImplOverlayController::set_position(&arg_self_.interface, arg_position);
    }
    extern "C" fn get_position<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_point_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_position(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_insets<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        insets: *const _cef_insets_t,
    ) {
        let (arg_self_, arg_insets) = (self_, insets);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_insets = if arg_insets.is_null() {
            None
        } else {
            Some(WrapParamRef::<Insets>::from(arg_insets))
        };
        let arg_insets = arg_insets.as_ref().map(|arg| arg.as_ref());
        let result = ImplOverlayController::set_insets(&arg_self_.interface, arg_insets);
    }
    extern "C" fn get_insets<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_insets_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::get_insets(&arg_self_.interface);
        result.into()
    }
    extern "C" fn size_to_preferred_size<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::size_to_preferred_size(&arg_self_.interface);
    }
    extern "C" fn set_visible<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        visible: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_visible) = (self_, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visible = arg_visible.as_raw();
        let result = ImplOverlayController::set_visible(&arg_self_.interface, arg_visible);
    }
    extern "C" fn is_visible<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::is_visible(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_drawn<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplOverlayController::is_drawn(&arg_self_.interface);
        result.into()
    }
}
impl ImplOverlayController for OverlayController {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut impl ImplOverlayController>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplOverlayController::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_contents_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_contents_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_window(&self) -> Option<Window> {
        unsafe {
            self.0
                .get_window
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_docking_mode(&self) -> DockingMode {
        unsafe {
            self.0
                .get_docking_mode
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn destroy(&self) {
        unsafe {
            self.0
                .destroy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        unsafe {
            self.0
                .set_bounds
                .map(|f| {
                    let arg_bounds = bounds;
                    let arg_self_ = self.as_raw();
                    let arg_bounds = arg_bounds.cloned().map(|arg| arg.into());
                    let arg_bounds = arg_bounds
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_bounds_in_screen(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_size(&self, size: Option<&Size>) {
        unsafe {
            self.0
                .set_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size(&self) -> Size {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_position(&self, position: Option<&Point>) {
        unsafe {
            self.0
                .set_position
                .map(|f| {
                    let arg_position = position;
                    let arg_self_ = self.as_raw();
                    let arg_position = arg_position.cloned().map(|arg| arg.into());
                    let arg_position = arg_position
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_position);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_position(&self) -> Point {
        unsafe {
            self.0
                .get_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        unsafe {
            self.0
                .set_insets
                .map(|f| {
                    let arg_insets = insets;
                    let arg_self_ = self.as_raw();
                    let arg_insets = arg_insets.cloned().map(|arg| arg.into());
                    let arg_insets = arg_insets
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_insets);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_insets(&self) -> Insets {
        unsafe {
            self.0
                .get_insets
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn size_to_preferred_size(&self) {
        unsafe {
            self.0
                .size_to_preferred_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_visible
                .map(|f| {
                    let arg_visible = visible;
                    let arg_self_ = self.as_raw();
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_drawn
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_overlay_controller_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_overlay_controller_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for OverlayController {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_overlay_controller_t> for &OverlayController {
    fn as_raw(self) -> *mut _cef_overlay_controller_t {
        ImplOverlayController::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_overlay_controller_t> for &mut OverlayController {
    fn as_raw(self) -> *mut _cef_overlay_controller_t {
        ImplOverlayController::get_raw(self)
    }
}
impl ConvertReturnValue<OverlayController> for *mut _cef_overlay_controller_t {
    fn as_wrapper(self) -> OverlayController {
        OverlayController(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_overlay_controller_t> for OverlayController {
    fn into(self) -> *mut _cef_overlay_controller_t {
        let object = ImplOverlayController::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for OverlayController {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_panel_delegate_t] for more documentation.
#[derive(Clone)]
pub struct PanelDelegate(RefGuard<_cef_panel_delegate_t>);
impl PanelDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPanelDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPanelDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPanelDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_panel_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapPanelDelegate: ImplPanelDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_panel_delegate_t, Self>);
}
pub trait ImplPanelDelegate: ImplViewDelegate {
    fn init_methods(object: &mut _cef_panel_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_panel_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_panel_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self) as *mut _
    }
}
mod impl_cef_panel_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplPanelDelegate>(object: &mut _cef_panel_delegate_t) {}
}
impl ImplViewDelegate for PanelDelegate {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplPanelDelegate for PanelDelegate {
    fn get_raw(&self) -> *mut _cef_panel_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_panel_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PanelDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_panel_delegate_t> for &PanelDelegate {
    fn as_raw(self) -> *mut _cef_panel_delegate_t {
        ImplPanelDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_panel_delegate_t> for &mut PanelDelegate {
    fn as_raw(self) -> *mut _cef_panel_delegate_t {
        ImplPanelDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<PanelDelegate> for *mut _cef_panel_delegate_t {
    fn as_wrapper(self) -> PanelDelegate {
        PanelDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_panel_delegate_t> for PanelDelegate {
    fn into(self) -> *mut _cef_panel_delegate_t {
        let object = ImplPanelDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for PanelDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_panel_t] for more documentation.
#[derive(Clone)]
pub struct Panel(RefGuard<_cef_panel_t>);
impl Panel {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPanel,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPanel>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPanel>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_panel_t).as_wrapper()
        }
    }
}
pub trait WrapPanel: ImplPanel {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_panel_t, Self>);
}
pub trait ImplPanel: ImplView {
    fn as_window(&self) -> Option<Window> {
        Default::default()
    }
    fn set_to_fill_layout(&self) -> Option<FillLayout> {
        Default::default()
    }
    fn set_to_box_layout(&self, settings: Option<&BoxLayoutSettings>) -> Option<BoxLayout> {
        Default::default()
    }
    fn get_layout(&self) -> Option<Layout> {
        Default::default()
    }
    fn layout(&self) {}
    fn add_child_view(&self, view: Option<&mut impl ImplView>) {}
    fn add_child_view_at(&self, view: Option<&mut impl ImplView>, index: ::std::os::raw::c_int) {}
    fn reorder_child_view(&self, view: Option<&mut impl ImplView>, index: ::std::os::raw::c_int) {}
    fn remove_child_view(&self, view: Option<&mut impl ImplView>) {}
    fn remove_all_child_views(&self) {}
    fn get_child_view_count(&self) -> usize {
        Default::default()
    }
    fn get_child_view_at(&self, index: ::std::os::raw::c_int) -> Option<View> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_panel_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_panel_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_panel_t {
        <Self as ImplView>::get_raw(self) as *mut _
    }
}
mod impl_cef_panel_t {
    use super::*;
    pub fn init_methods<I: ImplPanel>(object: &mut _cef_panel_t) {
        object.as_window = Some(as_window::<I>);
        object.set_to_fill_layout = Some(set_to_fill_layout::<I>);
        object.set_to_box_layout = Some(set_to_box_layout::<I>);
        object.get_layout = Some(get_layout::<I>);
        object.layout = Some(layout::<I>);
        object.add_child_view = Some(add_child_view::<I>);
        object.add_child_view_at = Some(add_child_view_at::<I>);
        object.reorder_child_view = Some(reorder_child_view::<I>);
        object.remove_child_view = Some(remove_child_view::<I>);
        object.remove_all_child_views = Some(remove_all_child_views::<I>);
        object.get_child_view_count = Some(get_child_view_count::<I>);
        object.get_child_view_at = Some(get_child_view_at::<I>);
    }
    extern "C" fn as_window<I: ImplPanel>(self_: *mut _cef_panel_t) -> *mut _cef_window_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPanel::as_window(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_to_fill_layout<I: ImplPanel>(
        self_: *mut _cef_panel_t,
    ) -> *mut _cef_fill_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPanel::set_to_fill_layout(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_to_box_layout<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        settings: *const _cef_box_layout_settings_t,
    ) -> *mut _cef_box_layout_t {
        let (arg_self_, arg_settings) = (self_, settings);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BoxLayoutSettings>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_ref().map(|arg| arg.as_ref());
        let result = ImplPanel::set_to_box_layout(&arg_self_.interface, arg_settings);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_layout<I: ImplPanel>(self_: *mut _cef_panel_t) -> *mut _cef_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPanel::get_layout(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn layout<I: ImplPanel>(self_: *mut _cef_panel_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPanel::layout(&arg_self_.interface);
    }
    extern "C" fn add_child_view<I: ImplPanel>(self_: *mut _cef_panel_t, view: *mut _cef_view_t) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplPanel::add_child_view(&arg_self_.interface, arg_view);
    }
    extern "C" fn add_child_view_at<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        view: *mut _cef_view_t,
        index: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_index) = (self_, view, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_index = arg_index.as_raw();
        let result = ImplPanel::add_child_view_at(&arg_self_.interface, arg_view, arg_index);
    }
    extern "C" fn reorder_child_view<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        view: *mut _cef_view_t,
        index: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_index) = (self_, view, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_index = arg_index.as_raw();
        let result = ImplPanel::reorder_child_view(&arg_self_.interface, arg_view, arg_index);
    }
    extern "C" fn remove_child_view<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplPanel::remove_child_view(&arg_self_.interface, arg_view);
    }
    extern "C" fn remove_all_child_views<I: ImplPanel>(self_: *mut _cef_panel_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPanel::remove_all_child_views(&arg_self_.interface);
    }
    extern "C" fn get_child_view_count<I: ImplPanel>(self_: *mut _cef_panel_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplPanel::get_child_view_count(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_child_view_at<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        index: ::std::os::raw::c_int,
    ) -> *mut _cef_view_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let result = ImplPanel::get_child_view_at(&arg_self_.interface, arg_index);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplView for Panel {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplPanel for Panel {
    fn as_window(&self) -> Option<Window> {
        unsafe {
            self.0
                .as_window
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_to_fill_layout(&self) -> Option<FillLayout> {
        unsafe {
            self.0
                .set_to_fill_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_to_box_layout(&self, settings: Option<&BoxLayoutSettings>) -> Option<BoxLayout> {
        unsafe {
            self.0
                .set_to_box_layout
                .map(|f| {
                    let arg_settings = settings;
                    let arg_self_ = self.as_raw();
                    let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_settings);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_layout(&self) -> Option<Layout> {
        unsafe {
            self.0
                .get_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn layout(&self) {
        unsafe {
            self.0
                .layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_child_view(&self, view: Option<&mut impl ImplView>) {
        unsafe {
            self.0
                .add_child_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_child_view_at(&self, view: Option<&mut impl ImplView>, index: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .add_child_view_at
                .map(|f| {
                    let (arg_view, arg_index) = (view, index);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_view, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reorder_child_view(&self, view: Option<&mut impl ImplView>, index: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .reorder_child_view
                .map(|f| {
                    let (arg_view, arg_index) = (view, index);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_view, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_child_view(&self, view: Option<&mut impl ImplView>) {
        unsafe {
            self.0
                .remove_child_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_all_child_views(&self) {
        unsafe {
            self.0
                .remove_all_child_views
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_child_view_count(&self) -> usize {
        unsafe {
            self.0
                .get_child_view_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_child_view_at(&self, index: ::std::os::raw::c_int) -> Option<View> {
        unsafe {
            self.0
                .get_child_view_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_panel_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_panel_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Panel {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_panel_t> for &Panel {
    fn as_raw(self) -> *mut _cef_panel_t {
        ImplPanel::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_panel_t> for &mut Panel {
    fn as_raw(self) -> *mut _cef_panel_t {
        ImplPanel::get_raw(self)
    }
}
impl ConvertReturnValue<Panel> for *mut _cef_panel_t {
    fn as_wrapper(self) -> Panel {
        Panel(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_panel_t> for Panel {
    fn into(self) -> *mut _cef_panel_t {
        let object = ImplPanel::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Panel {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_window_delegate_t] for more documentation.
#[derive(Clone)]
pub struct WindowDelegate(RefGuard<_cef_window_delegate_t>);
impl WindowDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapWindowDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplWindowDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapWindowDelegate>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_window_delegate_t).as_wrapper()
        }
    }
}
pub trait WrapWindowDelegate: ImplWindowDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_window_delegate_t, Self>);
}
pub trait ImplWindowDelegate: ImplPanelDelegate {
    fn on_window_created(&self, window: Option<&mut impl ImplWindow>) {}
    fn on_window_closing(&self, window: Option<&mut impl ImplWindow>) {}
    fn on_window_destroyed(&self, window: Option<&mut impl ImplWindow>) {}
    fn on_window_activation_changed(
        &self,
        window: Option<&mut impl ImplWindow>,
        active: ::std::os::raw::c_int,
    ) {
    }
    fn on_window_bounds_changed(
        &self,
        window: Option<&mut impl ImplWindow>,
        new_bounds: Option<&Rect>,
    ) {
    }
    fn on_window_fullscreen_transition(
        &self,
        window: Option<&mut impl ImplWindow>,
        is_completed: ::std::os::raw::c_int,
    ) {
    }
    fn get_parent_window(
        &self,
        window: Option<&mut impl ImplWindow>,
        is_menu: Option<&mut ::std::os::raw::c_int>,
        can_activate_menu: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<Window> {
        Default::default()
    }
    fn is_window_modal_dialog(
        &self,
        window: Option<&mut impl ImplWindow>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_initial_bounds(&self, window: Option<&mut impl ImplWindow>) -> Rect {
        Default::default()
    }
    fn get_initial_show_state(&self, window: Option<&mut impl ImplWindow>) -> ShowState {
        Default::default()
    }
    fn is_frameless(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn with_standard_window_buttons(
        &self,
        window: Option<&mut impl ImplWindow>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_titlebar_height(
        &self,
        window: Option<&mut impl ImplWindow>,
        titlebar_height: Option<&mut f32>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn accepts_first_mouse(&self, window: Option<&mut impl ImplWindow>) -> State {
        Default::default()
    }
    fn can_resize(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn can_maximize(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn can_minimize(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn can_close(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_accelerator(
        &self,
        window: Option<&mut impl ImplWindow>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_key_event(
        &self,
        window: Option<&mut impl ImplWindow>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn on_theme_colors_changed(
        &self,
        window: Option<&mut impl ImplWindow>,
        chrome_theme: ::std::os::raw::c_int,
    ) {
    }
    fn get_window_runtime_style(&self) -> RuntimeStyle {
        Default::default()
    }
    fn get_linux_window_properties(
        &self,
        window: Option<&mut impl ImplWindow>,
        properties: Option<&mut LinuxWindowProperties>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_window_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_panel_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_window_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_window_delegate_t {
        <Self as ImplPanelDelegate>::get_raw(self) as *mut _
    }
}
mod impl_cef_window_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplWindowDelegate>(object: &mut _cef_window_delegate_t) {
        object.on_window_created = Some(on_window_created::<I>);
        object.on_window_closing = Some(on_window_closing::<I>);
        object.on_window_destroyed = Some(on_window_destroyed::<I>);
        object.on_window_activation_changed = Some(on_window_activation_changed::<I>);
        object.on_window_bounds_changed = Some(on_window_bounds_changed::<I>);
        object.on_window_fullscreen_transition = Some(on_window_fullscreen_transition::<I>);
        object.get_parent_window = Some(get_parent_window::<I>);
        object.is_window_modal_dialog = Some(is_window_modal_dialog::<I>);
        object.get_initial_bounds = Some(get_initial_bounds::<I>);
        object.get_initial_show_state = Some(get_initial_show_state::<I>);
        object.is_frameless = Some(is_frameless::<I>);
        object.with_standard_window_buttons = Some(with_standard_window_buttons::<I>);
        object.get_titlebar_height = Some(get_titlebar_height::<I>);
        object.accepts_first_mouse = Some(accepts_first_mouse::<I>);
        object.can_resize = Some(can_resize::<I>);
        object.can_maximize = Some(can_maximize::<I>);
        object.can_minimize = Some(can_minimize::<I>);
        object.can_close = Some(can_close::<I>);
        object.on_accelerator = Some(on_accelerator::<I>);
        object.on_key_event = Some(on_key_event::<I>);
        object.on_theme_colors_changed = Some(on_theme_colors_changed::<I>);
        object.get_window_runtime_style = Some(get_window_runtime_style::<I>);
        object.get_linux_window_properties = Some(get_linux_window_properties::<I>);
    }
    extern "C" fn on_window_created<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::on_window_created(&arg_self_.interface, arg_window);
    }
    extern "C" fn on_window_closing<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::on_window_closing(&arg_self_.interface, arg_window);
    }
    extern "C" fn on_window_destroyed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::on_window_destroyed(&arg_self_.interface, arg_window);
    }
    extern "C" fn on_window_activation_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        active: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_active) = (self_, window, active);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_active = arg_active.as_raw();
        let result = ImplWindowDelegate::on_window_activation_changed(
            &arg_self_.interface,
            arg_window,
            arg_active,
        );
    }
    extern "C" fn on_window_bounds_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        new_bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_window, arg_new_bounds) = (self_, window, new_bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_new_bounds = if arg_new_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect>::from(arg_new_bounds))
        };
        let arg_new_bounds = arg_new_bounds.as_ref().map(|arg| arg.as_ref());
        let result = ImplWindowDelegate::on_window_bounds_changed(
            &arg_self_.interface,
            arg_window,
            arg_new_bounds,
        );
    }
    extern "C" fn on_window_fullscreen_transition<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        is_completed: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_is_completed) = (self_, window, is_completed);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_is_completed = arg_is_completed.as_raw();
        let result = ImplWindowDelegate::on_window_fullscreen_transition(
            &arg_self_.interface,
            arg_window,
            arg_is_completed,
        );
    }
    extern "C" fn get_parent_window<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        is_menu: *mut ::std::os::raw::c_int,
        can_activate_menu: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_window_t {
        let (arg_self_, arg_window, arg_is_menu, arg_can_activate_menu) =
            (self_, window, is_menu, can_activate_menu);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let mut arg_is_menu = if arg_is_menu.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(arg_is_menu))
        };
        let arg_is_menu = arg_is_menu.as_mut().map(|arg| arg.as_mut());
        let mut arg_can_activate_menu = if arg_can_activate_menu.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int>::from(
                arg_can_activate_menu,
            ))
        };
        let arg_can_activate_menu = arg_can_activate_menu.as_mut().map(|arg| arg.as_mut());
        let result = ImplWindowDelegate::get_parent_window(
            &arg_self_.interface,
            arg_window,
            arg_is_menu,
            arg_can_activate_menu,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_window_modal_dialog<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::is_window_modal_dialog(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn get_initial_bounds<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> _cef_rect_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::get_initial_bounds(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn get_initial_show_state<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> cef_show_state_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::get_initial_show_state(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn is_frameless<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::is_frameless(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn with_standard_window_buttons<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result =
            ImplWindowDelegate::with_standard_window_buttons(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn get_titlebar_height<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        titlebar_height: *mut f32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_titlebar_height) = (self_, window, titlebar_height);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let mut arg_titlebar_height = if arg_titlebar_height.is_null() {
            None
        } else {
            Some(WrapParamRef::<f32>::from(arg_titlebar_height))
        };
        let arg_titlebar_height = arg_titlebar_height.as_mut().map(|arg| arg.as_mut());
        let result = ImplWindowDelegate::get_titlebar_height(
            &arg_self_.interface,
            arg_window,
            arg_titlebar_height,
        );
        result.into()
    }
    extern "C" fn accepts_first_mouse<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> cef_state_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::accepts_first_mouse(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn can_resize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::can_resize(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn can_maximize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::can_maximize(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn can_minimize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::can_minimize(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn can_close<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::can_close(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn on_accelerator<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_command_id) = (self_, window, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_command_id = arg_command_id.as_raw();
        let result =
            ImplWindowDelegate::on_accelerator(&arg_self_.interface, arg_window, arg_command_id);
        result.into()
    }
    extern "C" fn on_key_event<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        event: *const _cef_key_event_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_event) = (self_, window, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let result = ImplWindowDelegate::on_key_event(&arg_self_.interface, arg_window, arg_event);
        result.into()
    }
    extern "C" fn on_theme_colors_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        chrome_theme: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_chrome_theme) = (self_, window, chrome_theme);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_chrome_theme = arg_chrome_theme.as_raw();
        let result = ImplWindowDelegate::on_theme_colors_changed(
            &arg_self_.interface,
            arg_window,
            arg_chrome_theme,
        );
    }
    extern "C" fn get_window_runtime_style<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindowDelegate::get_window_runtime_style(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_linux_window_properties<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        properties: *mut _cef_linux_window_properties_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_properties) = (self_, window, properties);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let mut arg_properties = if arg_properties.is_null() {
            None
        } else {
            Some(WrapParamRef::<LinuxWindowProperties>::from(arg_properties))
        };
        let arg_properties = arg_properties.as_mut().map(|arg| arg.as_mut());
        let result = ImplWindowDelegate::get_linux_window_properties(
            &arg_self_.interface,
            arg_window,
            arg_properties,
        );
        result.into()
    }
}
impl ImplViewDelegate for WindowDelegate {
    fn get_preferred_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size(&self, view: Option<&mut impl ImplView>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width(
        &self,
        view: Option<&mut impl ImplView>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut impl ImplView>,
        added: ::std::os::raw::c_int,
        child: Option<&mut impl ImplView>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut impl ImplView>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut impl ImplView>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut impl ImplView>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplPanelDelegate for WindowDelegate {
    fn get_raw(&self) -> *mut _cef_panel_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplWindowDelegate for WindowDelegate {
    fn on_window_created(&self, window: Option<&mut impl ImplWindow>) {
        unsafe {
            self.0
                .on_window_created
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_closing(&self, window: Option<&mut impl ImplWindow>) {
        unsafe {
            self.0
                .on_window_closing
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_destroyed(&self, window: Option<&mut impl ImplWindow>) {
        unsafe {
            self.0
                .on_window_destroyed
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_activation_changed(
        &self,
        window: Option<&mut impl ImplWindow>,
        active: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_window_activation_changed
                .map(|f| {
                    let (arg_window, arg_active) = (window, active);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_active = arg_active;
                    let result = f(arg_self_, arg_window, arg_active);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_bounds_changed(
        &self,
        window: Option<&mut impl ImplWindow>,
        new_bounds: Option<&Rect>,
    ) {
        unsafe {
            self.0
                .on_window_bounds_changed
                .map(|f| {
                    let (arg_window, arg_new_bounds) = (window, new_bounds);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_new_bounds = arg_new_bounds.cloned().map(|arg| arg.into());
                    let arg_new_bounds = arg_new_bounds
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_window, arg_new_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_fullscreen_transition(
        &self,
        window: Option<&mut impl ImplWindow>,
        is_completed: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_window_fullscreen_transition
                .map(|f| {
                    let (arg_window, arg_is_completed) = (window, is_completed);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_completed = arg_is_completed;
                    let result = f(arg_self_, arg_window, arg_is_completed);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_parent_window(
        &self,
        window: Option<&mut impl ImplWindow>,
        is_menu: Option<&mut ::std::os::raw::c_int>,
        can_activate_menu: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<Window> {
        unsafe {
            self.0
                .get_parent_window
                .map(|f| {
                    let (arg_window, arg_is_menu, arg_can_activate_menu) =
                        (window, is_menu, can_activate_menu);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_menu = arg_is_menu
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_can_activate_menu = arg_can_activate_menu
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window, arg_is_menu, arg_can_activate_menu);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_window_modal_dialog(
        &self,
        window: Option<&mut impl ImplWindow>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_window_modal_dialog
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_initial_bounds(&self, window: Option<&mut impl ImplWindow>) -> Rect {
        unsafe {
            self.0
                .get_initial_bounds
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_initial_show_state(&self, window: Option<&mut impl ImplWindow>) -> ShowState {
        unsafe {
            self.0
                .get_initial_show_state
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_frameless(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_frameless
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn with_standard_window_buttons(
        &self,
        window: Option<&mut impl ImplWindow>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .with_standard_window_buttons
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_titlebar_height(
        &self,
        window: Option<&mut impl ImplWindow>,
        titlebar_height: Option<&mut f32>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_titlebar_height
                .map(|f| {
                    let (arg_window, arg_titlebar_height) = (window, titlebar_height);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_titlebar_height = arg_titlebar_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window, arg_titlebar_height);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn accepts_first_mouse(&self, window: Option<&mut impl ImplWindow>) -> State {
        unsafe {
            self.0
                .accepts_first_mouse
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn can_resize(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_resize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn can_maximize(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_maximize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn can_minimize(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_minimize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn can_close(&self, window: Option<&mut impl ImplWindow>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_close
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_accelerator(
        &self,
        window: Option<&mut impl ImplWindow>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_accelerator
                .map(|f| {
                    let (arg_window, arg_command_id) = (window, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_window, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_key_event(
        &self,
        window: Option<&mut impl ImplWindow>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_window, arg_event) = (window, event);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_window, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn on_theme_colors_changed(
        &self,
        window: Option<&mut impl ImplWindow>,
        chrome_theme: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_theme_colors_changed
                .map(|f| {
                    let (arg_window, arg_chrome_theme) = (window, chrome_theme);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_chrome_theme = arg_chrome_theme;
                    let result = f(arg_self_, arg_window, arg_chrome_theme);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_window_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_linux_window_properties(
        &self,
        window: Option<&mut impl ImplWindow>,
        properties: Option<&mut LinuxWindowProperties>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_linux_window_properties
                .map(|f| {
                    let (arg_window, arg_properties) = (window, properties);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_properties = arg_properties.cloned().map(|arg| arg.into());
                    let arg_properties = arg_properties
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window, arg_properties);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_window_delegate_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_window_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for WindowDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_window_delegate_t> for &WindowDelegate {
    fn as_raw(self) -> *mut _cef_window_delegate_t {
        ImplWindowDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_window_delegate_t> for &mut WindowDelegate {
    fn as_raw(self) -> *mut _cef_window_delegate_t {
        ImplWindowDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<WindowDelegate> for *mut _cef_window_delegate_t {
    fn as_wrapper(self) -> WindowDelegate {
        WindowDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_window_delegate_t> for WindowDelegate {
    fn into(self) -> *mut _cef_window_delegate_t {
        let object = ImplWindowDelegate::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for WindowDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [_cef_window_t] for more documentation.
#[derive(Clone)]
pub struct Window(RefGuard<_cef_window_t>);
impl Window {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapWindow,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplWindow>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapWindow>::wrap_rc(&mut (*object).interface, object);
            (object as *mut _cef_window_t).as_wrapper()
        }
    }
}
pub trait WrapWindow: ImplWindow {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_window_t, Self>);
}
pub trait ImplWindow: ImplPanel {
    fn show(&self) {}
    fn show_as_browser_modal_dialog(&self, browser_view: Option<&mut impl ImplBrowserView>) {}
    fn hide(&self) {}
    fn center_window(&self, size: Option<&Size>) {}
    fn close(&self) {}
    fn is_closed(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn activate(&self) {}
    fn deactivate(&self) {}
    fn is_active(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn bring_to_top(&self) {}
    fn set_always_on_top(&self, on_top: ::std::os::raw::c_int) {}
    fn is_always_on_top(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn maximize(&self) {}
    fn minimize(&self) {}
    fn restore(&self) {}
    fn set_fullscreen(&self, fullscreen: ::std::os::raw::c_int) {}
    fn is_maximized(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_minimized(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn is_fullscreen(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn get_focused_view(&self) -> Option<View> {
        Default::default()
    }
    fn set_title(&self, title: Option<&CefStringUtf16>) {}
    fn get_title(&self) -> Option<CefStringUtf16> {
        Default::default()
    }
    fn set_window_icon(&self, image: Option<&mut impl ImplImage>) {}
    fn get_window_icon(&self) -> Option<Image> {
        Default::default()
    }
    fn set_window_app_icon(&self, image: Option<&mut impl ImplImage>) {}
    fn get_window_app_icon(&self) -> Option<Image> {
        Default::default()
    }
    fn add_overlay_view(
        &self,
        view: Option<&mut impl ImplView>,
        docking_mode: DockingMode,
        can_activate: ::std::os::raw::c_int,
    ) -> Option<OverlayController> {
        Default::default()
    }
    fn show_menu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    ) {
    }
    fn cancel_menu(&self) {}
    fn get_display(&self) -> Option<Display> {
        Default::default()
    }
    fn get_client_area_bounds_in_screen(&self) -> Rect {
        Default::default()
    }
    fn set_draggable_regions(&self, regions_count: usize, regions: Option<&DraggableRegion>) {}
    fn get_window_handle(&self) -> ::std::os::raw::c_ulong {
        Default::default()
    }
    fn send_key_press(&self, key_code: ::std::os::raw::c_int, event_flags: u32) {}
    fn send_mouse_move(&self, screen_x: ::std::os::raw::c_int, screen_y: ::std::os::raw::c_int) {}
    fn send_mouse_events(
        &self,
        button: MouseButtonType,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    ) {
    }
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    ) {
    }
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int) {}
    fn remove_all_accelerators(&self) {}
    fn set_theme_color(&self, color_id: ::std::os::raw::c_int, color: u32) {}
    fn theme_changed(&self) {}
    fn get_runtime_style(&self) -> RuntimeStyle {
        Default::default()
    }
    fn init_methods(object: &mut _cef_window_t) {
        impl_cef_view_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_panel_t::init_methods::<Self>(&mut object.base);
        impl_cef_window_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_window_t {
        <Self as ImplPanel>::get_raw(self) as *mut _
    }
}
mod impl_cef_window_t {
    use super::*;
    pub fn init_methods<I: ImplWindow>(object: &mut _cef_window_t) {
        object.show = Some(show::<I>);
        object.show_as_browser_modal_dialog = Some(show_as_browser_modal_dialog::<I>);
        object.hide = Some(hide::<I>);
        object.center_window = Some(center_window::<I>);
        object.close = Some(close::<I>);
        object.is_closed = Some(is_closed::<I>);
        object.activate = Some(activate::<I>);
        object.deactivate = Some(deactivate::<I>);
        object.is_active = Some(is_active::<I>);
        object.bring_to_top = Some(bring_to_top::<I>);
        object.set_always_on_top = Some(set_always_on_top::<I>);
        object.is_always_on_top = Some(is_always_on_top::<I>);
        object.maximize = Some(maximize::<I>);
        object.minimize = Some(minimize::<I>);
        object.restore = Some(restore::<I>);
        object.set_fullscreen = Some(set_fullscreen::<I>);
        object.is_maximized = Some(is_maximized::<I>);
        object.is_minimized = Some(is_minimized::<I>);
        object.is_fullscreen = Some(is_fullscreen::<I>);
        object.get_focused_view = Some(get_focused_view::<I>);
        object.set_title = Some(set_title::<I>);
        object.get_title = Some(get_title::<I>);
        object.set_window_icon = Some(set_window_icon::<I>);
        object.get_window_icon = Some(get_window_icon::<I>);
        object.set_window_app_icon = Some(set_window_app_icon::<I>);
        object.get_window_app_icon = Some(get_window_app_icon::<I>);
        object.add_overlay_view = Some(add_overlay_view::<I>);
        object.show_menu = Some(show_menu::<I>);
        object.cancel_menu = Some(cancel_menu::<I>);
        object.get_display = Some(get_display::<I>);
        object.get_client_area_bounds_in_screen = Some(get_client_area_bounds_in_screen::<I>);
        object.set_draggable_regions = Some(set_draggable_regions::<I>);
        object.get_window_handle = Some(get_window_handle::<I>);
        object.send_key_press = Some(send_key_press::<I>);
        object.send_mouse_move = Some(send_mouse_move::<I>);
        object.send_mouse_events = Some(send_mouse_events::<I>);
        object.set_accelerator = Some(set_accelerator::<I>);
        object.remove_accelerator = Some(remove_accelerator::<I>);
        object.remove_all_accelerators = Some(remove_all_accelerators::<I>);
        object.set_theme_color = Some(set_theme_color::<I>);
        object.theme_changed = Some(theme_changed::<I>);
        object.get_runtime_style = Some(get_runtime_style::<I>);
    }
    extern "C" fn show<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::show(&arg_self_.interface);
    }
    extern "C" fn show_as_browser_modal_dialog<I: ImplWindow>(
        self_: *mut _cef_window_t,
        browser_view: *mut _cef_browser_view_t,
    ) {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let result =
            ImplWindow::show_as_browser_modal_dialog(&arg_self_.interface, arg_browser_view);
    }
    extern "C" fn hide<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::hide(&arg_self_.interface);
    }
    extern "C" fn center_window<I: ImplWindow>(
        self_: *mut _cef_window_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size>::from(arg_size))
        };
        let arg_size = arg_size.as_ref().map(|arg| arg.as_ref());
        let result = ImplWindow::center_window(&arg_self_.interface, arg_size);
    }
    extern "C" fn close<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::close(&arg_self_.interface);
    }
    extern "C" fn is_closed<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::is_closed(&arg_self_.interface);
        result.into()
    }
    extern "C" fn activate<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::activate(&arg_self_.interface);
    }
    extern "C" fn deactivate<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::deactivate(&arg_self_.interface);
    }
    extern "C" fn is_active<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::is_active(&arg_self_.interface);
        result.into()
    }
    extern "C" fn bring_to_top<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::bring_to_top(&arg_self_.interface);
    }
    extern "C" fn set_always_on_top<I: ImplWindow>(
        self_: *mut _cef_window_t,
        on_top: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_on_top) = (self_, on_top);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_on_top = arg_on_top.as_raw();
        let result = ImplWindow::set_always_on_top(&arg_self_.interface, arg_on_top);
    }
    extern "C" fn is_always_on_top<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::is_always_on_top(&arg_self_.interface);
        result.into()
    }
    extern "C" fn maximize<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::maximize(&arg_self_.interface);
    }
    extern "C" fn minimize<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::minimize(&arg_self_.interface);
    }
    extern "C" fn restore<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::restore(&arg_self_.interface);
    }
    extern "C" fn set_fullscreen<I: ImplWindow>(
        self_: *mut _cef_window_t,
        fullscreen: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_fullscreen) = (self_, fullscreen);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_fullscreen = arg_fullscreen.as_raw();
        let result = ImplWindow::set_fullscreen(&arg_self_.interface, arg_fullscreen);
    }
    extern "C" fn is_maximized<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::is_maximized(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_minimized<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::is_minimized(&arg_self_.interface);
        result.into()
    }
    extern "C" fn is_fullscreen<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::is_fullscreen(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_focused_view<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_focused_view(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_title<I: ImplWindow>(
        self_: *mut _cef_window_t,
        title: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_title) = (self_, title);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_title = if arg_title.is_null() {
            None
        } else {
            Some(arg_title.into())
        };
        let arg_title = arg_title.as_ref();
        let result = ImplWindow::set_title(&arg_self_.interface, arg_title);
    }
    extern "C" fn get_title<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_title(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_window_icon<I: ImplWindow>(
        self_: *mut _cef_window_t,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_image) = (self_, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_image =
            unsafe { arg_image.as_mut() }.map(|arg| Image(unsafe { RefGuard::from_raw(arg) }));
        let arg_image = arg_image.as_mut();
        let result = ImplWindow::set_window_icon(&arg_self_.interface, arg_image);
    }
    extern "C" fn get_window_icon<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_image_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_window_icon(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn set_window_app_icon<I: ImplWindow>(
        self_: *mut _cef_window_t,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_image) = (self_, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_image =
            unsafe { arg_image.as_mut() }.map(|arg| Image(unsafe { RefGuard::from_raw(arg) }));
        let arg_image = arg_image.as_mut();
        let result = ImplWindow::set_window_app_icon(&arg_self_.interface, arg_image);
    }
    extern "C" fn get_window_app_icon<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> *mut _cef_image_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_window_app_icon(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn add_overlay_view<I: ImplWindow>(
        self_: *mut _cef_window_t,
        view: *mut _cef_view_t,
        docking_mode: cef_docking_mode_t,
        can_activate: ::std::os::raw::c_int,
    ) -> *mut _cef_overlay_controller_t {
        let (arg_self_, arg_view, arg_docking_mode, arg_can_activate) =
            (self_, view, docking_mode, can_activate);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_docking_mode = arg_docking_mode.as_raw();
        let arg_can_activate = arg_can_activate.as_raw();
        let result = ImplWindow::add_overlay_view(
            &arg_self_.interface,
            arg_view,
            arg_docking_mode,
            arg_can_activate,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn show_menu<I: ImplWindow>(
        self_: *mut _cef_window_t,
        menu_model: *mut _cef_menu_model_t,
        screen_point: *const _cef_point_t,
        anchor_position: cef_menu_anchor_position_t,
    ) {
        let (arg_self_, arg_menu_model, arg_screen_point, arg_anchor_position) =
            (self_, menu_model, screen_point, anchor_position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_screen_point = if arg_screen_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point>::from(arg_screen_point))
        };
        let arg_screen_point = arg_screen_point.as_ref().map(|arg| arg.as_ref());
        let arg_anchor_position = arg_anchor_position.as_raw();
        let result = ImplWindow::show_menu(
            &arg_self_.interface,
            arg_menu_model,
            arg_screen_point,
            arg_anchor_position,
        );
    }
    extern "C" fn cancel_menu<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::cancel_menu(&arg_self_.interface);
    }
    extern "C" fn get_display<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_display_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_display(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_client_area_bounds_in_screen<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_client_area_bounds_in_screen(&arg_self_.interface);
        result.into()
    }
    extern "C" fn set_draggable_regions<I: ImplWindow>(
        self_: *mut _cef_window_t,
        regions_count: usize,
        regions: *const _cef_draggable_region_t,
    ) {
        let (arg_self_, arg_regions_count, arg_regions) = (self_, regions_count, regions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_regions_count = arg_regions_count.as_raw();
        let arg_regions = if arg_regions.is_null() {
            None
        } else {
            Some(WrapParamRef::<DraggableRegion>::from(arg_regions))
        };
        let arg_regions = arg_regions.as_ref().map(|arg| arg.as_ref());
        let result =
            ImplWindow::set_draggable_regions(&arg_self_.interface, arg_regions_count, arg_regions);
    }
    extern "C" fn get_window_handle<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> ::std::os::raw::c_ulong {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_window_handle(&arg_self_.interface);
        result.into()
    }
    extern "C" fn send_key_press<I: ImplWindow>(
        self_: *mut _cef_window_t,
        key_code: ::std::os::raw::c_int,
        event_flags: u32,
    ) {
        let (arg_self_, arg_key_code, arg_event_flags) = (self_, key_code, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key_code = arg_key_code.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        let result =
            ImplWindow::send_key_press(&arg_self_.interface, arg_key_code, arg_event_flags);
    }
    extern "C" fn send_mouse_move<I: ImplWindow>(
        self_: *mut _cef_window_t,
        screen_x: ::std::os::raw::c_int,
        screen_y: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_screen_x, arg_screen_y) = (self_, screen_x, screen_y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_screen_x = arg_screen_x.as_raw();
        let arg_screen_y = arg_screen_y.as_raw();
        let result = ImplWindow::send_mouse_move(&arg_self_.interface, arg_screen_x, arg_screen_y);
    }
    extern "C" fn send_mouse_events<I: ImplWindow>(
        self_: *mut _cef_window_t,
        button: cef_mouse_button_type_t,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_button, arg_mouse_down, arg_mouse_up) =
            (self_, button, mouse_down, mouse_up);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button = arg_button.as_raw();
        let arg_mouse_down = arg_mouse_down.as_raw();
        let arg_mouse_up = arg_mouse_up.as_raw();
        let result = ImplWindow::send_mouse_events(
            &arg_self_.interface,
            arg_button,
            arg_mouse_down,
            arg_mouse_up,
        );
    }
    extern "C" fn set_accelerator<I: ImplWindow>(
        self_: *mut _cef_window_t,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
            arg_high_priority,
        ) = (
            self_,
            command_id,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
            high_priority,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_key_code = arg_key_code.as_raw();
        let arg_shift_pressed = arg_shift_pressed.as_raw();
        let arg_ctrl_pressed = arg_ctrl_pressed.as_raw();
        let arg_alt_pressed = arg_alt_pressed.as_raw();
        let arg_high_priority = arg_high_priority.as_raw();
        let result = ImplWindow::set_accelerator(
            &arg_self_.interface,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
            arg_high_priority,
        );
    }
    extern "C" fn remove_accelerator<I: ImplWindow>(
        self_: *mut _cef_window_t,
        command_id: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let result = ImplWindow::remove_accelerator(&arg_self_.interface, arg_command_id);
    }
    extern "C" fn remove_all_accelerators<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::remove_all_accelerators(&arg_self_.interface);
    }
    extern "C" fn set_theme_color<I: ImplWindow>(
        self_: *mut _cef_window_t,
        color_id: ::std::os::raw::c_int,
        color: u32,
    ) {
        let (arg_self_, arg_color_id, arg_color) = (self_, color_id, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color_id = arg_color_id.as_raw();
        let arg_color = arg_color.as_raw();
        let result = ImplWindow::set_theme_color(&arg_self_.interface, arg_color_id, arg_color);
    }
    extern "C" fn theme_changed<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::theme_changed(&arg_self_.interface);
    }
    extern "C" fn get_runtime_style<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindow::get_runtime_style(&arg_self_.interface);
        result.into()
    }
}
impl ImplView for Window {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string(&self) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> Option<CefStringUtf16> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same(&self, that: Option<&mut impl ImplView>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate(&self) -> Option<ViewDelegate> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window(&self) -> Option<Window> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view(&self) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut impl ImplView>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplPanel for Window {
    fn as_window(&self) -> Option<Window> {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_window()
    }
    fn set_to_fill_layout(&self) -> Option<FillLayout> {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_to_fill_layout()
    }
    fn set_to_box_layout(&self, settings: Option<&BoxLayoutSettings>) -> Option<BoxLayout> {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_to_box_layout(settings)
    }
    fn get_layout(&self) -> Option<Layout> {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_layout()
    }
    fn layout(&self) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).layout()
    }
    fn add_child_view(&self, view: Option<&mut impl ImplView>) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .add_child_view(view)
    }
    fn add_child_view_at(&self, view: Option<&mut impl ImplView>, index: ::std::os::raw::c_int) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .add_child_view_at(view, index)
    }
    fn reorder_child_view(&self, view: Option<&mut impl ImplView>, index: ::std::os::raw::c_int) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .reorder_child_view(view, index)
    }
    fn remove_child_view(&self, view: Option<&mut impl ImplView>) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .remove_child_view(view)
    }
    fn remove_all_child_views(&self) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .remove_all_child_views()
    }
    fn get_child_view_count(&self) -> usize {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_child_view_count()
    }
    fn get_child_view_at(&self, index: ::std::os::raw::c_int) -> Option<View> {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_child_view_at(index)
    }
    fn get_raw(&self) -> *mut _cef_panel_t {
        unsafe { RefGuard::as_raw(&self.0) as *mut _ }
    }
}
impl ImplWindow for Window {
    fn show(&self) {
        unsafe {
            self.0
                .show
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn show_as_browser_modal_dialog(&self, browser_view: Option<&mut impl ImplBrowserView>) {
        unsafe {
            self.0
                .show_as_browser_modal_dialog
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn hide(&self) {
        unsafe {
            self.0
                .hide
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn center_window(&self, size: Option<&Size>) {
        unsafe {
            self.0
                .center_window
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn close(&self) {
        unsafe {
            self.0
                .close
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_closed(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_closed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn activate(&self) {
        unsafe {
            self.0
                .activate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn deactivate(&self) {
        unsafe {
            self.0
                .deactivate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_active(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_active
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn bring_to_top(&self) {
        unsafe {
            self.0
                .bring_to_top
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_always_on_top(&self, on_top: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_always_on_top
                .map(|f| {
                    let arg_on_top = on_top;
                    let arg_self_ = self.as_raw();
                    let arg_on_top = arg_on_top;
                    let result = f(arg_self_, arg_on_top);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_always_on_top(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_always_on_top
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn maximize(&self) {
        unsafe {
            self.0
                .maximize
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn minimize(&self) {
        unsafe {
            self.0
                .minimize
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn restore(&self) {
        unsafe {
            self.0
                .restore
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fullscreen(&self, fullscreen: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_fullscreen
                .map(|f| {
                    let arg_fullscreen = fullscreen;
                    let arg_self_ = self.as_raw();
                    let arg_fullscreen = arg_fullscreen;
                    let result = f(arg_self_, arg_fullscreen);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_maximized(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_maximized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_minimized(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_minimized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn is_fullscreen(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fullscreen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_focused_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_focused_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_title(&self, title: Option<&CefStringUtf16>) {
        unsafe {
            self.0
                .set_title
                .map(|f| {
                    let arg_title = title;
                    let arg_self_ = self.as_raw();
                    let arg_title = arg_title
                        .map(|arg| arg.as_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_title);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_title(&self) -> Option<CefStringUtf16> {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_window_icon(&self, image: Option<&mut impl ImplImage>) {
        unsafe {
            self.0
                .set_window_icon
                .map(|f| {
                    let arg_image = image;
                    let arg_self_ = self.as_raw();
                    let arg_image = arg_image
                        .map(|arg| {
                            arg.add_ref();
                            ImplImage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_icon(&self) -> Option<Image> {
        unsafe {
            self.0
                .get_window_icon
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_window_app_icon(&self, image: Option<&mut impl ImplImage>) {
        unsafe {
            self.0
                .set_window_app_icon
                .map(|f| {
                    let arg_image = image;
                    let arg_self_ = self.as_raw();
                    let arg_image = arg_image
                        .map(|arg| {
                            arg.add_ref();
                            ImplImage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_app_icon(&self) -> Option<Image> {
        unsafe {
            self.0
                .get_window_app_icon
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn add_overlay_view(
        &self,
        view: Option<&mut impl ImplView>,
        docking_mode: DockingMode,
        can_activate: ::std::os::raw::c_int,
    ) -> Option<OverlayController> {
        unsafe {
            self.0
                .add_overlay_view
                .map(|f| {
                    let (arg_view, arg_docking_mode, arg_can_activate) =
                        (view, docking_mode, can_activate);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_docking_mode = arg_docking_mode.as_raw();
                    let arg_can_activate = arg_can_activate;
                    let result = f(arg_self_, arg_view, arg_docking_mode, arg_can_activate);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn show_menu(
        &self,
        menu_model: Option<&mut impl ImplMenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe {
            self.0
                .show_menu
                .map(|f| {
                    let (arg_menu_model, arg_screen_point, arg_anchor_position) =
                        (menu_model, screen_point, anchor_position);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                    let arg_screen_point = arg_screen_point
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_anchor_position = arg_anchor_position.as_raw();
                    let result = f(
                        arg_self_,
                        arg_menu_model,
                        arg_screen_point,
                        arg_anchor_position,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel_menu(&self) {
        unsafe {
            self.0
                .cancel_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_display(&self) -> Option<Display> {
        unsafe {
            self.0
                .get_display
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.as_wrapper())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_client_area_bounds_in_screen(&self) -> Rect {
        unsafe {
            self.0
                .get_client_area_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn set_draggable_regions(&self, regions_count: usize, regions: Option<&DraggableRegion>) {
        unsafe {
            self.0
                .set_draggable_regions
                .map(|f| {
                    let (arg_regions_count, arg_regions) = (regions_count, regions);
                    let arg_self_ = self.as_raw();
                    let arg_regions_count = arg_regions_count;
                    let arg_regions = arg_regions.cloned().map(|arg| arg.into());
                    let arg_regions = arg_regions
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_regions_count, arg_regions);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_handle(&self) -> ::std::os::raw::c_ulong {
        unsafe {
            self.0
                .get_window_handle
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn send_key_press(&self, key_code: ::std::os::raw::c_int, event_flags: u32) {
        unsafe {
            self.0
                .send_key_press
                .map(|f| {
                    let (arg_key_code, arg_event_flags) = (key_code, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_key_code = arg_key_code;
                    let arg_event_flags = arg_event_flags;
                    let result = f(arg_self_, arg_key_code, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_move(&self, screen_x: ::std::os::raw::c_int, screen_y: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .send_mouse_move
                .map(|f| {
                    let (arg_screen_x, arg_screen_y) = (screen_x, screen_y);
                    let arg_self_ = self.as_raw();
                    let arg_screen_x = arg_screen_x;
                    let arg_screen_y = arg_screen_y;
                    let result = f(arg_self_, arg_screen_x, arg_screen_y);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_events(
        &self,
        button: MouseButtonType,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_events
                .map(|f| {
                    let (arg_button, arg_mouse_down, arg_mouse_up) = (button, mouse_down, mouse_up);
                    let arg_self_ = self.as_raw();
                    let arg_button = arg_button.as_raw();
                    let arg_mouse_down = arg_mouse_down;
                    let arg_mouse_up = arg_mouse_up;
                    let result = f(arg_self_, arg_button, arg_mouse_down, arg_mouse_up);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                        arg_high_priority,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                        high_priority,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_key_code = arg_key_code;
                    let arg_shift_pressed = arg_shift_pressed;
                    let arg_ctrl_pressed = arg_ctrl_pressed;
                    let arg_alt_pressed = arg_alt_pressed;
                    let arg_high_priority = arg_high_priority;
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                        arg_high_priority,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .remove_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_all_accelerators(&self) {
        unsafe {
            self.0
                .remove_all_accelerators
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_theme_color(&self, color_id: ::std::os::raw::c_int, color: u32) {
        unsafe {
            self.0
                .set_theme_color
                .map(|f| {
                    let (arg_color_id, arg_color) = (color_id, color);
                    let arg_self_ = self.as_raw();
                    let arg_color_id = arg_color_id;
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color_id, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn theme_changed(&self) {
        unsafe {
            self.0
                .theme_changed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_window_t {
        unsafe { RefGuard::as_raw(&self.0) }
    }
}
impl Rc for _cef_window_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Window {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_window_t> for &Window {
    fn as_raw(self) -> *mut _cef_window_t {
        ImplWindow::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_window_t> for &mut Window {
    fn as_raw(self) -> *mut _cef_window_t {
        ImplWindow::get_raw(self)
    }
}
impl ConvertReturnValue<Window> for *mut _cef_window_t {
    fn as_wrapper(self) -> Window {
        Window(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_window_t> for Window {
    fn into(self) -> *mut _cef_window_t {
        let object = ImplWindow::get_raw(&self);
        std::mem::forget(self);
        object
    }
}
impl Default for Window {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [cef_content_setting_types_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContentSettingTypes(cef_content_setting_types_t);
impl AsRef<cef_content_setting_types_t> for ContentSettingTypes {
    fn as_ref(&self) -> &cef_content_setting_types_t {
        &self.0
    }
}
impl AsMut<cef_content_setting_types_t> for ContentSettingTypes {
    fn as_mut(&mut self) -> &mut cef_content_setting_types_t {
        &mut self.0
    }
}
impl From<cef_content_setting_types_t> for ContentSettingTypes {
    fn from(value: cef_content_setting_types_t) -> Self {
        Self(value)
    }
}
impl Into<cef_content_setting_types_t> for ContentSettingTypes {
    fn into(self) -> cef_content_setting_types_t {
        self.0
    }
}
impl Default for ContentSettingTypes {
    fn default() -> Self {
        Self(cef_content_setting_types_t::CEF_CONTENT_SETTING_TYPE_COOKIES)
    }
}

/// See [cef_content_setting_values_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContentSettingValues(cef_content_setting_values_t);
impl AsRef<cef_content_setting_values_t> for ContentSettingValues {
    fn as_ref(&self) -> &cef_content_setting_values_t {
        &self.0
    }
}
impl AsMut<cef_content_setting_values_t> for ContentSettingValues {
    fn as_mut(&mut self) -> &mut cef_content_setting_values_t {
        &mut self.0
    }
}
impl From<cef_content_setting_values_t> for ContentSettingValues {
    fn from(value: cef_content_setting_values_t) -> Self {
        Self(value)
    }
}
impl Into<cef_content_setting_values_t> for ContentSettingValues {
    fn into(self) -> cef_content_setting_values_t {
        self.0
    }
}
impl Default for ContentSettingValues {
    fn default() -> Self {
        Self(cef_content_setting_values_t::CEF_CONTENT_SETTING_VALUE_DEFAULT)
    }
}

/// See [cef_color_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorType(cef_color_type_t);
impl AsRef<cef_color_type_t> for ColorType {
    fn as_ref(&self) -> &cef_color_type_t {
        &self.0
    }
}
impl AsMut<cef_color_type_t> for ColorType {
    fn as_mut(&mut self) -> &mut cef_color_type_t {
        &mut self.0
    }
}
impl From<cef_color_type_t> for ColorType {
    fn from(value: cef_color_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_color_type_t> for ColorType {
    fn into(self) -> cef_color_type_t {
        self.0
    }
}
impl Default for ColorType {
    fn default() -> Self {
        Self(cef_color_type_t::CEF_COLOR_TYPE_RGBA_8888)
    }
}

/// See [cef_runtime_style_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct RuntimeStyle(cef_runtime_style_t);
impl AsRef<cef_runtime_style_t> for RuntimeStyle {
    fn as_ref(&self) -> &cef_runtime_style_t {
        &self.0
    }
}
impl AsMut<cef_runtime_style_t> for RuntimeStyle {
    fn as_mut(&mut self) -> &mut cef_runtime_style_t {
        &mut self.0
    }
}
impl From<cef_runtime_style_t> for RuntimeStyle {
    fn from(value: cef_runtime_style_t) -> Self {
        Self(value)
    }
}
impl Into<cef_runtime_style_t> for RuntimeStyle {
    fn into(self) -> cef_runtime_style_t {
        self.0
    }
}
impl Default for RuntimeStyle {
    fn default() -> Self {
        Self(cef_runtime_style_t::CEF_RUNTIME_STYLE_DEFAULT)
    }
}

/// See [cef_log_severity_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LogSeverity(cef_log_severity_t);
impl AsRef<cef_log_severity_t> for LogSeverity {
    fn as_ref(&self) -> &cef_log_severity_t {
        &self.0
    }
}
impl AsMut<cef_log_severity_t> for LogSeverity {
    fn as_mut(&mut self) -> &mut cef_log_severity_t {
        &mut self.0
    }
}
impl From<cef_log_severity_t> for LogSeverity {
    fn from(value: cef_log_severity_t) -> Self {
        Self(value)
    }
}
impl Into<cef_log_severity_t> for LogSeverity {
    fn into(self) -> cef_log_severity_t {
        self.0
    }
}
impl Default for LogSeverity {
    fn default() -> Self {
        Self(cef_log_severity_t::LOGSEVERITY_DEFAULT)
    }
}

/// See [cef_log_items_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LogItems(cef_log_items_t);
impl AsRef<cef_log_items_t> for LogItems {
    fn as_ref(&self) -> &cef_log_items_t {
        &self.0
    }
}
impl AsMut<cef_log_items_t> for LogItems {
    fn as_mut(&mut self) -> &mut cef_log_items_t {
        &mut self.0
    }
}
impl From<cef_log_items_t> for LogItems {
    fn from(value: cef_log_items_t) -> Self {
        Self(value)
    }
}
impl Into<cef_log_items_t> for LogItems {
    fn into(self) -> cef_log_items_t {
        self.0
    }
}
impl Default for LogItems {
    fn default() -> Self {
        Self(cef_log_items_t::LOG_ITEMS_DEFAULT)
    }
}

/// See [cef_state_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct State(cef_state_t);
impl AsRef<cef_state_t> for State {
    fn as_ref(&self) -> &cef_state_t {
        &self.0
    }
}
impl AsMut<cef_state_t> for State {
    fn as_mut(&mut self) -> &mut cef_state_t {
        &mut self.0
    }
}
impl From<cef_state_t> for State {
    fn from(value: cef_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_state_t> for State {
    fn into(self) -> cef_state_t {
        self.0
    }
}
impl Default for State {
    fn default() -> Self {
        Self(cef_state_t::STATE_DEFAULT)
    }
}

/// See [cef_return_value_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ReturnValue(cef_return_value_t);
impl AsRef<cef_return_value_t> for ReturnValue {
    fn as_ref(&self) -> &cef_return_value_t {
        &self.0
    }
}
impl AsMut<cef_return_value_t> for ReturnValue {
    fn as_mut(&mut self) -> &mut cef_return_value_t {
        &mut self.0
    }
}
impl From<cef_return_value_t> for ReturnValue {
    fn from(value: cef_return_value_t) -> Self {
        Self(value)
    }
}
impl Into<cef_return_value_t> for ReturnValue {
    fn into(self) -> cef_return_value_t {
        self.0
    }
}
impl Default for ReturnValue {
    fn default() -> Self {
        Self(cef_return_value_t::RV_CANCEL)
    }
}

/// See [cef_cookie_priority_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CookiePriority(cef_cookie_priority_t);
impl AsRef<cef_cookie_priority_t> for CookiePriority {
    fn as_ref(&self) -> &cef_cookie_priority_t {
        &self.0
    }
}
impl AsMut<cef_cookie_priority_t> for CookiePriority {
    fn as_mut(&mut self) -> &mut cef_cookie_priority_t {
        &mut self.0
    }
}
impl From<cef_cookie_priority_t> for CookiePriority {
    fn from(value: cef_cookie_priority_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cookie_priority_t> for CookiePriority {
    fn into(self) -> cef_cookie_priority_t {
        self.0
    }
}
impl Default for CookiePriority {
    fn default() -> Self {
        Self(cef_cookie_priority_t::CEF_COOKIE_PRIORITY_LOW)
    }
}

/// See [cef_cookie_same_site_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CookieSameSite(cef_cookie_same_site_t);
impl AsRef<cef_cookie_same_site_t> for CookieSameSite {
    fn as_ref(&self) -> &cef_cookie_same_site_t {
        &self.0
    }
}
impl AsMut<cef_cookie_same_site_t> for CookieSameSite {
    fn as_mut(&mut self) -> &mut cef_cookie_same_site_t {
        &mut self.0
    }
}
impl From<cef_cookie_same_site_t> for CookieSameSite {
    fn from(value: cef_cookie_same_site_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cookie_same_site_t> for CookieSameSite {
    fn into(self) -> cef_cookie_same_site_t {
        self.0
    }
}
impl Default for CookieSameSite {
    fn default() -> Self {
        Self(cef_cookie_same_site_t::CEF_COOKIE_SAME_SITE_UNSPECIFIED)
    }
}

/// See [cef_termination_status_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TerminationStatus(cef_termination_status_t);
impl AsRef<cef_termination_status_t> for TerminationStatus {
    fn as_ref(&self) -> &cef_termination_status_t {
        &self.0
    }
}
impl AsMut<cef_termination_status_t> for TerminationStatus {
    fn as_mut(&mut self) -> &mut cef_termination_status_t {
        &mut self.0
    }
}
impl From<cef_termination_status_t> for TerminationStatus {
    fn from(value: cef_termination_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_termination_status_t> for TerminationStatus {
    fn into(self) -> cef_termination_status_t {
        self.0
    }
}
impl Default for TerminationStatus {
    fn default() -> Self {
        Self(cef_termination_status_t::TS_ABNORMAL_TERMINATION)
    }
}

/// See [cef_path_key_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PathKey(cef_path_key_t);
impl AsRef<cef_path_key_t> for PathKey {
    fn as_ref(&self) -> &cef_path_key_t {
        &self.0
    }
}
impl AsMut<cef_path_key_t> for PathKey {
    fn as_mut(&mut self) -> &mut cef_path_key_t {
        &mut self.0
    }
}
impl From<cef_path_key_t> for PathKey {
    fn from(value: cef_path_key_t) -> Self {
        Self(value)
    }
}
impl Into<cef_path_key_t> for PathKey {
    fn into(self) -> cef_path_key_t {
        self.0
    }
}
impl Default for PathKey {
    fn default() -> Self {
        Self(cef_path_key_t::PK_DIR_CURRENT)
    }
}

/// See [cef_storage_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StorageType(cef_storage_type_t);
impl AsRef<cef_storage_type_t> for StorageType {
    fn as_ref(&self) -> &cef_storage_type_t {
        &self.0
    }
}
impl AsMut<cef_storage_type_t> for StorageType {
    fn as_mut(&mut self) -> &mut cef_storage_type_t {
        &mut self.0
    }
}
impl From<cef_storage_type_t> for StorageType {
    fn from(value: cef_storage_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_storage_type_t> for StorageType {
    fn into(self) -> cef_storage_type_t {
        self.0
    }
}
impl Default for StorageType {
    fn default() -> Self {
        Self(cef_storage_type_t::ST_LOCALSTORAGE)
    }
}

/// See [cef_errorcode_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Errorcode(cef_errorcode_t);
impl AsRef<cef_errorcode_t> for Errorcode {
    fn as_ref(&self) -> &cef_errorcode_t {
        &self.0
    }
}
impl AsMut<cef_errorcode_t> for Errorcode {
    fn as_mut(&mut self) -> &mut cef_errorcode_t {
        &mut self.0
    }
}
impl From<cef_errorcode_t> for Errorcode {
    fn from(value: cef_errorcode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_errorcode_t> for Errorcode {
    fn into(self) -> cef_errorcode_t {
        self.0
    }
}
impl Default for Errorcode {
    fn default() -> Self {
        Self(cef_errorcode_t::ERR_NONE)
    }
}

/// See [cef_cert_status_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CertStatus(cef_cert_status_t);
impl AsRef<cef_cert_status_t> for CertStatus {
    fn as_ref(&self) -> &cef_cert_status_t {
        &self.0
    }
}
impl AsMut<cef_cert_status_t> for CertStatus {
    fn as_mut(&mut self) -> &mut cef_cert_status_t {
        &mut self.0
    }
}
impl From<cef_cert_status_t> for CertStatus {
    fn from(value: cef_cert_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cert_status_t> for CertStatus {
    fn into(self) -> cef_cert_status_t {
        self.0
    }
}
impl Default for CertStatus {
    fn default() -> Self {
        Self(cef_cert_status_t::CERT_STATUS_NONE)
    }
}

/// See [cef_resultcode_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Resultcode(cef_resultcode_t);
impl AsRef<cef_resultcode_t> for Resultcode {
    fn as_ref(&self) -> &cef_resultcode_t {
        &self.0
    }
}
impl AsMut<cef_resultcode_t> for Resultcode {
    fn as_mut(&mut self) -> &mut cef_resultcode_t {
        &mut self.0
    }
}
impl From<cef_resultcode_t> for Resultcode {
    fn from(value: cef_resultcode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_resultcode_t> for Resultcode {
    fn into(self) -> cef_resultcode_t {
        self.0
    }
}
impl Default for Resultcode {
    fn default() -> Self {
        Self(cef_resultcode_t::CEF_RESULT_CODE_NORMAL_EXIT)
    }
}

/// See [cef_window_open_disposition_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct WindowOpenDisposition(cef_window_open_disposition_t);
impl AsRef<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn as_ref(&self) -> &cef_window_open_disposition_t {
        &self.0
    }
}
impl AsMut<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn as_mut(&mut self) -> &mut cef_window_open_disposition_t {
        &mut self.0
    }
}
impl From<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn from(value: cef_window_open_disposition_t) -> Self {
        Self(value)
    }
}
impl Into<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn into(self) -> cef_window_open_disposition_t {
        self.0
    }
}
impl Default for WindowOpenDisposition {
    fn default() -> Self {
        Self(cef_window_open_disposition_t::CEF_WOD_UNKNOWN)
    }
}

/// See [cef_drag_operations_mask_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DragOperationsMask(cef_drag_operations_mask_t);
impl AsRef<cef_drag_operations_mask_t> for DragOperationsMask {
    fn as_ref(&self) -> &cef_drag_operations_mask_t {
        &self.0
    }
}
impl AsMut<cef_drag_operations_mask_t> for DragOperationsMask {
    fn as_mut(&mut self) -> &mut cef_drag_operations_mask_t {
        &mut self.0
    }
}
impl From<cef_drag_operations_mask_t> for DragOperationsMask {
    fn from(value: cef_drag_operations_mask_t) -> Self {
        Self(value)
    }
}
impl Into<cef_drag_operations_mask_t> for DragOperationsMask {
    fn into(self) -> cef_drag_operations_mask_t {
        self.0
    }
}
impl Default for DragOperationsMask {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [cef_text_input_mode_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextInputMode(cef_text_input_mode_t);
impl AsRef<cef_text_input_mode_t> for TextInputMode {
    fn as_ref(&self) -> &cef_text_input_mode_t {
        &self.0
    }
}
impl AsMut<cef_text_input_mode_t> for TextInputMode {
    fn as_mut(&mut self) -> &mut cef_text_input_mode_t {
        &mut self.0
    }
}
impl From<cef_text_input_mode_t> for TextInputMode {
    fn from(value: cef_text_input_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_text_input_mode_t> for TextInputMode {
    fn into(self) -> cef_text_input_mode_t {
        self.0
    }
}
impl Default for TextInputMode {
    fn default() -> Self {
        Self(cef_text_input_mode_t::CEF_TEXT_INPUT_MODE_DEFAULT)
    }
}

/// See [cef_v8_propertyattribute_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct V8Propertyattribute(cef_v8_propertyattribute_t);
impl AsRef<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn as_ref(&self) -> &cef_v8_propertyattribute_t {
        &self.0
    }
}
impl AsMut<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn as_mut(&mut self) -> &mut cef_v8_propertyattribute_t {
        &mut self.0
    }
}
impl From<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn from(value: cef_v8_propertyattribute_t) -> Self {
        Self(value)
    }
}
impl Into<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn into(self) -> cef_v8_propertyattribute_t {
        self.0
    }
}
impl Default for V8Propertyattribute {
    fn default() -> Self {
        Self(cef_v8_propertyattribute_t::V8_PROPERTY_ATTRIBUTE_NONE)
    }
}

/// See [cef_postdataelement_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PostdataelementType(cef_postdataelement_type_t);
impl AsRef<cef_postdataelement_type_t> for PostdataelementType {
    fn as_ref(&self) -> &cef_postdataelement_type_t {
        &self.0
    }
}
impl AsMut<cef_postdataelement_type_t> for PostdataelementType {
    fn as_mut(&mut self) -> &mut cef_postdataelement_type_t {
        &mut self.0
    }
}
impl From<cef_postdataelement_type_t> for PostdataelementType {
    fn from(value: cef_postdataelement_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_postdataelement_type_t> for PostdataelementType {
    fn into(self) -> cef_postdataelement_type_t {
        self.0
    }
}
impl Default for PostdataelementType {
    fn default() -> Self {
        Self(cef_postdataelement_type_t::PDE_TYPE_EMPTY)
    }
}

/// See [cef_resource_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceType(cef_resource_type_t);
impl AsRef<cef_resource_type_t> for ResourceType {
    fn as_ref(&self) -> &cef_resource_type_t {
        &self.0
    }
}
impl AsMut<cef_resource_type_t> for ResourceType {
    fn as_mut(&mut self) -> &mut cef_resource_type_t {
        &mut self.0
    }
}
impl From<cef_resource_type_t> for ResourceType {
    fn from(value: cef_resource_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_resource_type_t> for ResourceType {
    fn into(self) -> cef_resource_type_t {
        self.0
    }
}
impl Default for ResourceType {
    fn default() -> Self {
        Self(cef_resource_type_t::RT_MAIN_FRAME)
    }
}

/// See [cef_transition_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TransitionType(cef_transition_type_t);
impl AsRef<cef_transition_type_t> for TransitionType {
    fn as_ref(&self) -> &cef_transition_type_t {
        &self.0
    }
}
impl AsMut<cef_transition_type_t> for TransitionType {
    fn as_mut(&mut self) -> &mut cef_transition_type_t {
        &mut self.0
    }
}
impl From<cef_transition_type_t> for TransitionType {
    fn from(value: cef_transition_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_transition_type_t> for TransitionType {
    fn into(self) -> cef_transition_type_t {
        self.0
    }
}
impl Default for TransitionType {
    fn default() -> Self {
        Self(cef_transition_type_t::TT_LINK)
    }
}

/// See [cef_urlrequest_flags_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UrlrequestFlags(cef_urlrequest_flags_t);
impl AsRef<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn as_ref(&self) -> &cef_urlrequest_flags_t {
        &self.0
    }
}
impl AsMut<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn as_mut(&mut self) -> &mut cef_urlrequest_flags_t {
        &mut self.0
    }
}
impl From<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn from(value: cef_urlrequest_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn into(self) -> cef_urlrequest_flags_t {
        self.0
    }
}
impl Default for UrlrequestFlags {
    fn default() -> Self {
        Self(cef_urlrequest_flags_t::UR_FLAG_NONE)
    }
}

/// See [cef_urlrequest_status_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UrlrequestStatus(cef_urlrequest_status_t);
impl AsRef<cef_urlrequest_status_t> for UrlrequestStatus {
    fn as_ref(&self) -> &cef_urlrequest_status_t {
        &self.0
    }
}
impl AsMut<cef_urlrequest_status_t> for UrlrequestStatus {
    fn as_mut(&mut self) -> &mut cef_urlrequest_status_t {
        &mut self.0
    }
}
impl From<cef_urlrequest_status_t> for UrlrequestStatus {
    fn from(value: cef_urlrequest_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_urlrequest_status_t> for UrlrequestStatus {
    fn into(self) -> cef_urlrequest_status_t {
        self.0
    }
}
impl Default for UrlrequestStatus {
    fn default() -> Self {
        Self(cef_urlrequest_status_t::UR_UNKNOWN)
    }
}

/// See [cef_process_id_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ProcessId(cef_process_id_t);
impl AsRef<cef_process_id_t> for ProcessId {
    fn as_ref(&self) -> &cef_process_id_t {
        &self.0
    }
}
impl AsMut<cef_process_id_t> for ProcessId {
    fn as_mut(&mut self) -> &mut cef_process_id_t {
        &mut self.0
    }
}
impl From<cef_process_id_t> for ProcessId {
    fn from(value: cef_process_id_t) -> Self {
        Self(value)
    }
}
impl Into<cef_process_id_t> for ProcessId {
    fn into(self) -> cef_process_id_t {
        self.0
    }
}
impl Default for ProcessId {
    fn default() -> Self {
        Self(cef_process_id_t::PID_BROWSER)
    }
}

/// See [cef_thread_id_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ThreadId(cef_thread_id_t);
impl AsRef<cef_thread_id_t> for ThreadId {
    fn as_ref(&self) -> &cef_thread_id_t {
        &self.0
    }
}
impl AsMut<cef_thread_id_t> for ThreadId {
    fn as_mut(&mut self) -> &mut cef_thread_id_t {
        &mut self.0
    }
}
impl From<cef_thread_id_t> for ThreadId {
    fn from(value: cef_thread_id_t) -> Self {
        Self(value)
    }
}
impl Into<cef_thread_id_t> for ThreadId {
    fn into(self) -> cef_thread_id_t {
        self.0
    }
}
impl Default for ThreadId {
    fn default() -> Self {
        Self(cef_thread_id_t::TID_UI)
    }
}

/// See [cef_thread_priority_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ThreadPriority(cef_thread_priority_t);
impl AsRef<cef_thread_priority_t> for ThreadPriority {
    fn as_ref(&self) -> &cef_thread_priority_t {
        &self.0
    }
}
impl AsMut<cef_thread_priority_t> for ThreadPriority {
    fn as_mut(&mut self) -> &mut cef_thread_priority_t {
        &mut self.0
    }
}
impl From<cef_thread_priority_t> for ThreadPriority {
    fn from(value: cef_thread_priority_t) -> Self {
        Self(value)
    }
}
impl Into<cef_thread_priority_t> for ThreadPriority {
    fn into(self) -> cef_thread_priority_t {
        self.0
    }
}
impl Default for ThreadPriority {
    fn default() -> Self {
        Self(cef_thread_priority_t::TP_BACKGROUND)
    }
}

/// See [cef_message_loop_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MessageLoopType(cef_message_loop_type_t);
impl AsRef<cef_message_loop_type_t> for MessageLoopType {
    fn as_ref(&self) -> &cef_message_loop_type_t {
        &self.0
    }
}
impl AsMut<cef_message_loop_type_t> for MessageLoopType {
    fn as_mut(&mut self) -> &mut cef_message_loop_type_t {
        &mut self.0
    }
}
impl From<cef_message_loop_type_t> for MessageLoopType {
    fn from(value: cef_message_loop_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_message_loop_type_t> for MessageLoopType {
    fn into(self) -> cef_message_loop_type_t {
        self.0
    }
}
impl Default for MessageLoopType {
    fn default() -> Self {
        Self(cef_message_loop_type_t::ML_TYPE_DEFAULT)
    }
}

/// See [cef_com_init_mode_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ComInitMode(cef_com_init_mode_t);
impl AsRef<cef_com_init_mode_t> for ComInitMode {
    fn as_ref(&self) -> &cef_com_init_mode_t {
        &self.0
    }
}
impl AsMut<cef_com_init_mode_t> for ComInitMode {
    fn as_mut(&mut self) -> &mut cef_com_init_mode_t {
        &mut self.0
    }
}
impl From<cef_com_init_mode_t> for ComInitMode {
    fn from(value: cef_com_init_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_com_init_mode_t> for ComInitMode {
    fn into(self) -> cef_com_init_mode_t {
        self.0
    }
}
impl Default for ComInitMode {
    fn default() -> Self {
        Self(cef_com_init_mode_t::COM_INIT_MODE_NONE)
    }
}

/// See [cef_value_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ValueType(cef_value_type_t);
impl AsRef<cef_value_type_t> for ValueType {
    fn as_ref(&self) -> &cef_value_type_t {
        &self.0
    }
}
impl AsMut<cef_value_type_t> for ValueType {
    fn as_mut(&mut self) -> &mut cef_value_type_t {
        &mut self.0
    }
}
impl From<cef_value_type_t> for ValueType {
    fn from(value: cef_value_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_value_type_t> for ValueType {
    fn into(self) -> cef_value_type_t {
        self.0
    }
}
impl Default for ValueType {
    fn default() -> Self {
        Self(cef_value_type_t::VTYPE_INVALID)
    }
}

/// See [cef_jsdialog_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsdialogType(cef_jsdialog_type_t);
impl AsRef<cef_jsdialog_type_t> for JsdialogType {
    fn as_ref(&self) -> &cef_jsdialog_type_t {
        &self.0
    }
}
impl AsMut<cef_jsdialog_type_t> for JsdialogType {
    fn as_mut(&mut self) -> &mut cef_jsdialog_type_t {
        &mut self.0
    }
}
impl From<cef_jsdialog_type_t> for JsdialogType {
    fn from(value: cef_jsdialog_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_jsdialog_type_t> for JsdialogType {
    fn into(self) -> cef_jsdialog_type_t {
        self.0
    }
}
impl Default for JsdialogType {
    fn default() -> Self {
        Self(cef_jsdialog_type_t::JSDIALOGTYPE_ALERT)
    }
}

/// See [cef_menu_id_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuId(cef_menu_id_t);
impl AsRef<cef_menu_id_t> for MenuId {
    fn as_ref(&self) -> &cef_menu_id_t {
        &self.0
    }
}
impl AsMut<cef_menu_id_t> for MenuId {
    fn as_mut(&mut self) -> &mut cef_menu_id_t {
        &mut self.0
    }
}
impl From<cef_menu_id_t> for MenuId {
    fn from(value: cef_menu_id_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_id_t> for MenuId {
    fn into(self) -> cef_menu_id_t {
        self.0
    }
}
impl Default for MenuId {
    fn default() -> Self {
        Self(cef_menu_id_t::MENU_ID_BACK)
    }
}

/// See [cef_mouse_button_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MouseButtonType(cef_mouse_button_type_t);
impl AsRef<cef_mouse_button_type_t> for MouseButtonType {
    fn as_ref(&self) -> &cef_mouse_button_type_t {
        &self.0
    }
}
impl AsMut<cef_mouse_button_type_t> for MouseButtonType {
    fn as_mut(&mut self) -> &mut cef_mouse_button_type_t {
        &mut self.0
    }
}
impl From<cef_mouse_button_type_t> for MouseButtonType {
    fn from(value: cef_mouse_button_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_mouse_button_type_t> for MouseButtonType {
    fn into(self) -> cef_mouse_button_type_t {
        self.0
    }
}
impl Default for MouseButtonType {
    fn default() -> Self {
        Self(cef_mouse_button_type_t::MBT_LEFT)
    }
}

/// See [cef_touch_event_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TouchEventType(cef_touch_event_type_t);
impl AsRef<cef_touch_event_type_t> for TouchEventType {
    fn as_ref(&self) -> &cef_touch_event_type_t {
        &self.0
    }
}
impl AsMut<cef_touch_event_type_t> for TouchEventType {
    fn as_mut(&mut self) -> &mut cef_touch_event_type_t {
        &mut self.0
    }
}
impl From<cef_touch_event_type_t> for TouchEventType {
    fn from(value: cef_touch_event_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_touch_event_type_t> for TouchEventType {
    fn into(self) -> cef_touch_event_type_t {
        self.0
    }
}
impl Default for TouchEventType {
    fn default() -> Self {
        Self(cef_touch_event_type_t::CEF_TET_RELEASED)
    }
}

/// See [cef_pointer_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PointerType(cef_pointer_type_t);
impl AsRef<cef_pointer_type_t> for PointerType {
    fn as_ref(&self) -> &cef_pointer_type_t {
        &self.0
    }
}
impl AsMut<cef_pointer_type_t> for PointerType {
    fn as_mut(&mut self) -> &mut cef_pointer_type_t {
        &mut self.0
    }
}
impl From<cef_pointer_type_t> for PointerType {
    fn from(value: cef_pointer_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_pointer_type_t> for PointerType {
    fn into(self) -> cef_pointer_type_t {
        self.0
    }
}
impl Default for PointerType {
    fn default() -> Self {
        Self(cef_pointer_type_t::CEF_POINTER_TYPE_TOUCH)
    }
}

/// See [cef_paint_element_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PaintElementType(cef_paint_element_type_t);
impl AsRef<cef_paint_element_type_t> for PaintElementType {
    fn as_ref(&self) -> &cef_paint_element_type_t {
        &self.0
    }
}
impl AsMut<cef_paint_element_type_t> for PaintElementType {
    fn as_mut(&mut self) -> &mut cef_paint_element_type_t {
        &mut self.0
    }
}
impl From<cef_paint_element_type_t> for PaintElementType {
    fn from(value: cef_paint_element_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_paint_element_type_t> for PaintElementType {
    fn into(self) -> cef_paint_element_type_t {
        self.0
    }
}
impl Default for PaintElementType {
    fn default() -> Self {
        Self(cef_paint_element_type_t::PET_VIEW)
    }
}

/// See [cef_event_flags_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EventFlags(cef_event_flags_t);
impl AsRef<cef_event_flags_t> for EventFlags {
    fn as_ref(&self) -> &cef_event_flags_t {
        &self.0
    }
}
impl AsMut<cef_event_flags_t> for EventFlags {
    fn as_mut(&mut self) -> &mut cef_event_flags_t {
        &mut self.0
    }
}
impl From<cef_event_flags_t> for EventFlags {
    fn from(value: cef_event_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_event_flags_t> for EventFlags {
    fn into(self) -> cef_event_flags_t {
        self.0
    }
}
impl Default for EventFlags {
    fn default() -> Self {
        Self(cef_event_flags_t::EVENTFLAG_NONE)
    }
}

/// See [cef_menu_item_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuItemType(cef_menu_item_type_t);
impl AsRef<cef_menu_item_type_t> for MenuItemType {
    fn as_ref(&self) -> &cef_menu_item_type_t {
        &self.0
    }
}
impl AsMut<cef_menu_item_type_t> for MenuItemType {
    fn as_mut(&mut self) -> &mut cef_menu_item_type_t {
        &mut self.0
    }
}
impl From<cef_menu_item_type_t> for MenuItemType {
    fn from(value: cef_menu_item_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_item_type_t> for MenuItemType {
    fn into(self) -> cef_menu_item_type_t {
        self.0
    }
}
impl Default for MenuItemType {
    fn default() -> Self {
        Self(cef_menu_item_type_t::MENUITEMTYPE_NONE)
    }
}

/// See [cef_context_menu_type_flags_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuTypeFlags(cef_context_menu_type_flags_t);
impl AsRef<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn as_ref(&self) -> &cef_context_menu_type_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_type_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn from(value: cef_context_menu_type_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn into(self) -> cef_context_menu_type_flags_t {
        self.0
    }
}
impl Default for ContextMenuTypeFlags {
    fn default() -> Self {
        Self(cef_context_menu_type_flags_t::CM_TYPEFLAG_NONE)
    }
}

/// See [cef_context_menu_media_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuMediaType(cef_context_menu_media_type_t);
impl AsRef<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn as_ref(&self) -> &cef_context_menu_media_type_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn as_mut(&mut self) -> &mut cef_context_menu_media_type_t {
        &mut self.0
    }
}
impl From<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn from(value: cef_context_menu_media_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn into(self) -> cef_context_menu_media_type_t {
        self.0
    }
}
impl Default for ContextMenuMediaType {
    fn default() -> Self {
        Self(cef_context_menu_media_type_t::CM_MEDIATYPE_NONE)
    }
}

/// See [cef_context_menu_media_state_flags_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuMediaStateFlags(cef_context_menu_media_state_flags_t);
impl AsRef<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn as_ref(&self) -> &cef_context_menu_media_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_media_state_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn from(value: cef_context_menu_media_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn into(self) -> cef_context_menu_media_state_flags_t {
        self.0
    }
}
impl Default for ContextMenuMediaStateFlags {
    fn default() -> Self {
        Self(cef_context_menu_media_state_flags_t::CM_MEDIAFLAG_NONE)
    }
}

/// See [cef_context_menu_edit_state_flags_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuEditStateFlags(cef_context_menu_edit_state_flags_t);
impl AsRef<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn as_ref(&self) -> &cef_context_menu_edit_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_edit_state_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn from(value: cef_context_menu_edit_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn into(self) -> cef_context_menu_edit_state_flags_t {
        self.0
    }
}
impl Default for ContextMenuEditStateFlags {
    fn default() -> Self {
        Self(cef_context_menu_edit_state_flags_t::CM_EDITFLAG_NONE)
    }
}

/// See [cef_quick_menu_edit_state_flags_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct QuickMenuEditStateFlags(cef_quick_menu_edit_state_flags_t);
impl AsRef<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn as_ref(&self) -> &cef_quick_menu_edit_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn as_mut(&mut self) -> &mut cef_quick_menu_edit_state_flags_t {
        &mut self.0
    }
}
impl From<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn from(value: cef_quick_menu_edit_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn into(self) -> cef_quick_menu_edit_state_flags_t {
        self.0
    }
}
impl Default for QuickMenuEditStateFlags {
    fn default() -> Self {
        Self(cef_quick_menu_edit_state_flags_t::QM_EDITFLAG_NONE)
    }
}

/// See [cef_key_event_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct KeyEventType(cef_key_event_type_t);
impl AsRef<cef_key_event_type_t> for KeyEventType {
    fn as_ref(&self) -> &cef_key_event_type_t {
        &self.0
    }
}
impl AsMut<cef_key_event_type_t> for KeyEventType {
    fn as_mut(&mut self) -> &mut cef_key_event_type_t {
        &mut self.0
    }
}
impl From<cef_key_event_type_t> for KeyEventType {
    fn from(value: cef_key_event_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_key_event_type_t> for KeyEventType {
    fn into(self) -> cef_key_event_type_t {
        self.0
    }
}
impl Default for KeyEventType {
    fn default() -> Self {
        Self(cef_key_event_type_t::KEYEVENT_RAWKEYDOWN)
    }
}

/// See [cef_focus_source_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FocusSource(cef_focus_source_t);
impl AsRef<cef_focus_source_t> for FocusSource {
    fn as_ref(&self) -> &cef_focus_source_t {
        &self.0
    }
}
impl AsMut<cef_focus_source_t> for FocusSource {
    fn as_mut(&mut self) -> &mut cef_focus_source_t {
        &mut self.0
    }
}
impl From<cef_focus_source_t> for FocusSource {
    fn from(value: cef_focus_source_t) -> Self {
        Self(value)
    }
}
impl Into<cef_focus_source_t> for FocusSource {
    fn into(self) -> cef_focus_source_t {
        self.0
    }
}
impl Default for FocusSource {
    fn default() -> Self {
        Self(cef_focus_source_t::FOCUS_SOURCE_NAVIGATION)
    }
}

/// See [cef_navigation_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NavigationType(cef_navigation_type_t);
impl AsRef<cef_navigation_type_t> for NavigationType {
    fn as_ref(&self) -> &cef_navigation_type_t {
        &self.0
    }
}
impl AsMut<cef_navigation_type_t> for NavigationType {
    fn as_mut(&mut self) -> &mut cef_navigation_type_t {
        &mut self.0
    }
}
impl From<cef_navigation_type_t> for NavigationType {
    fn from(value: cef_navigation_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_navigation_type_t> for NavigationType {
    fn into(self) -> cef_navigation_type_t {
        self.0
    }
}
impl Default for NavigationType {
    fn default() -> Self {
        Self(cef_navigation_type_t::NAVIGATION_LINK_CLICKED)
    }
}

/// See [cef_xml_encoding_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct XmlEncodingType(cef_xml_encoding_type_t);
impl AsRef<cef_xml_encoding_type_t> for XmlEncodingType {
    fn as_ref(&self) -> &cef_xml_encoding_type_t {
        &self.0
    }
}
impl AsMut<cef_xml_encoding_type_t> for XmlEncodingType {
    fn as_mut(&mut self) -> &mut cef_xml_encoding_type_t {
        &mut self.0
    }
}
impl From<cef_xml_encoding_type_t> for XmlEncodingType {
    fn from(value: cef_xml_encoding_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_xml_encoding_type_t> for XmlEncodingType {
    fn into(self) -> cef_xml_encoding_type_t {
        self.0
    }
}
impl Default for XmlEncodingType {
    fn default() -> Self {
        Self(cef_xml_encoding_type_t::XML_ENCODING_NONE)
    }
}

/// See [cef_xml_node_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct XmlNodeType(cef_xml_node_type_t);
impl AsRef<cef_xml_node_type_t> for XmlNodeType {
    fn as_ref(&self) -> &cef_xml_node_type_t {
        &self.0
    }
}
impl AsMut<cef_xml_node_type_t> for XmlNodeType {
    fn as_mut(&mut self) -> &mut cef_xml_node_type_t {
        &mut self.0
    }
}
impl From<cef_xml_node_type_t> for XmlNodeType {
    fn from(value: cef_xml_node_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_xml_node_type_t> for XmlNodeType {
    fn into(self) -> cef_xml_node_type_t {
        self.0
    }
}
impl Default for XmlNodeType {
    fn default() -> Self {
        Self(cef_xml_node_type_t::XML_NODE_UNSUPPORTED)
    }
}

/// See [cef_dom_document_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomDocumentType(cef_dom_document_type_t);
impl AsRef<cef_dom_document_type_t> for DomDocumentType {
    fn as_ref(&self) -> &cef_dom_document_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_document_type_t> for DomDocumentType {
    fn as_mut(&mut self) -> &mut cef_dom_document_type_t {
        &mut self.0
    }
}
impl From<cef_dom_document_type_t> for DomDocumentType {
    fn from(value: cef_dom_document_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_document_type_t> for DomDocumentType {
    fn into(self) -> cef_dom_document_type_t {
        self.0
    }
}
impl Default for DomDocumentType {
    fn default() -> Self {
        Self(cef_dom_document_type_t::DOM_DOCUMENT_TYPE_UNKNOWN)
    }
}

/// See [cef_dom_event_category_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomEventCategory(cef_dom_event_category_t);
impl AsRef<cef_dom_event_category_t> for DomEventCategory {
    fn as_ref(&self) -> &cef_dom_event_category_t {
        &self.0
    }
}
impl AsMut<cef_dom_event_category_t> for DomEventCategory {
    fn as_mut(&mut self) -> &mut cef_dom_event_category_t {
        &mut self.0
    }
}
impl From<cef_dom_event_category_t> for DomEventCategory {
    fn from(value: cef_dom_event_category_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_event_category_t> for DomEventCategory {
    fn into(self) -> cef_dom_event_category_t {
        self.0
    }
}
impl Default for DomEventCategory {
    fn default() -> Self {
        Self(cef_dom_event_category_t::DOM_EVENT_CATEGORY_UNKNOWN)
    }
}

/// See [cef_dom_event_phase_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomEventPhase(cef_dom_event_phase_t);
impl AsRef<cef_dom_event_phase_t> for DomEventPhase {
    fn as_ref(&self) -> &cef_dom_event_phase_t {
        &self.0
    }
}
impl AsMut<cef_dom_event_phase_t> for DomEventPhase {
    fn as_mut(&mut self) -> &mut cef_dom_event_phase_t {
        &mut self.0
    }
}
impl From<cef_dom_event_phase_t> for DomEventPhase {
    fn from(value: cef_dom_event_phase_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_event_phase_t> for DomEventPhase {
    fn into(self) -> cef_dom_event_phase_t {
        self.0
    }
}
impl Default for DomEventPhase {
    fn default() -> Self {
        Self(cef_dom_event_phase_t::DOM_EVENT_PHASE_UNKNOWN)
    }
}

/// See [cef_dom_node_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomNodeType(cef_dom_node_type_t);
impl AsRef<cef_dom_node_type_t> for DomNodeType {
    fn as_ref(&self) -> &cef_dom_node_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_node_type_t> for DomNodeType {
    fn as_mut(&mut self) -> &mut cef_dom_node_type_t {
        &mut self.0
    }
}
impl From<cef_dom_node_type_t> for DomNodeType {
    fn from(value: cef_dom_node_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_node_type_t> for DomNodeType {
    fn into(self) -> cef_dom_node_type_t {
        self.0
    }
}
impl Default for DomNodeType {
    fn default() -> Self {
        Self(cef_dom_node_type_t::DOM_NODE_TYPE_UNSUPPORTED)
    }
}

/// See [cef_dom_form_control_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomFormControlType(cef_dom_form_control_type_t);
impl AsRef<cef_dom_form_control_type_t> for DomFormControlType {
    fn as_ref(&self) -> &cef_dom_form_control_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_form_control_type_t> for DomFormControlType {
    fn as_mut(&mut self) -> &mut cef_dom_form_control_type_t {
        &mut self.0
    }
}
impl From<cef_dom_form_control_type_t> for DomFormControlType {
    fn from(value: cef_dom_form_control_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_form_control_type_t> for DomFormControlType {
    fn into(self) -> cef_dom_form_control_type_t {
        self.0
    }
}
impl Default for DomFormControlType {
    fn default() -> Self {
        Self(cef_dom_form_control_type_t::DOM_FORM_CONTROL_TYPE_UNSUPPORTED)
    }
}

/// See [cef_file_dialog_mode_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FileDialogMode(cef_file_dialog_mode_t);
impl AsRef<cef_file_dialog_mode_t> for FileDialogMode {
    fn as_ref(&self) -> &cef_file_dialog_mode_t {
        &self.0
    }
}
impl AsMut<cef_file_dialog_mode_t> for FileDialogMode {
    fn as_mut(&mut self) -> &mut cef_file_dialog_mode_t {
        &mut self.0
    }
}
impl From<cef_file_dialog_mode_t> for FileDialogMode {
    fn from(value: cef_file_dialog_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_file_dialog_mode_t> for FileDialogMode {
    fn into(self) -> cef_file_dialog_mode_t {
        self.0
    }
}
impl Default for FileDialogMode {
    fn default() -> Self {
        Self(cef_file_dialog_mode_t::FILE_DIALOG_OPEN)
    }
}

/// See [cef_color_model_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorModel(cef_color_model_t);
impl AsRef<cef_color_model_t> for ColorModel {
    fn as_ref(&self) -> &cef_color_model_t {
        &self.0
    }
}
impl AsMut<cef_color_model_t> for ColorModel {
    fn as_mut(&mut self) -> &mut cef_color_model_t {
        &mut self.0
    }
}
impl From<cef_color_model_t> for ColorModel {
    fn from(value: cef_color_model_t) -> Self {
        Self(value)
    }
}
impl Into<cef_color_model_t> for ColorModel {
    fn into(self) -> cef_color_model_t {
        self.0
    }
}
impl Default for ColorModel {
    fn default() -> Self {
        Self(cef_color_model_t::COLOR_MODEL_UNKNOWN)
    }
}

/// See [cef_duplex_mode_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DuplexMode(cef_duplex_mode_t);
impl AsRef<cef_duplex_mode_t> for DuplexMode {
    fn as_ref(&self) -> &cef_duplex_mode_t {
        &self.0
    }
}
impl AsMut<cef_duplex_mode_t> for DuplexMode {
    fn as_mut(&mut self) -> &mut cef_duplex_mode_t {
        &mut self.0
    }
}
impl From<cef_duplex_mode_t> for DuplexMode {
    fn from(value: cef_duplex_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_duplex_mode_t> for DuplexMode {
    fn into(self) -> cef_duplex_mode_t {
        self.0
    }
}
impl Default for DuplexMode {
    fn default() -> Self {
        Self(cef_duplex_mode_t::DUPLEX_MODE_UNKNOWN)
    }
}

/// See [cef_cursor_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CursorType(cef_cursor_type_t);
impl AsRef<cef_cursor_type_t> for CursorType {
    fn as_ref(&self) -> &cef_cursor_type_t {
        &self.0
    }
}
impl AsMut<cef_cursor_type_t> for CursorType {
    fn as_mut(&mut self) -> &mut cef_cursor_type_t {
        &mut self.0
    }
}
impl From<cef_cursor_type_t> for CursorType {
    fn from(value: cef_cursor_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cursor_type_t> for CursorType {
    fn into(self) -> cef_cursor_type_t {
        self.0
    }
}
impl Default for CursorType {
    fn default() -> Self {
        Self(cef_cursor_type_t::CT_POINTER)
    }
}

/// See [cef_uri_unescape_rule_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UriUnescapeRule(cef_uri_unescape_rule_t);
impl AsRef<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn as_ref(&self) -> &cef_uri_unescape_rule_t {
        &self.0
    }
}
impl AsMut<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn as_mut(&mut self) -> &mut cef_uri_unescape_rule_t {
        &mut self.0
    }
}
impl From<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn from(value: cef_uri_unescape_rule_t) -> Self {
        Self(value)
    }
}
impl Into<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn into(self) -> cef_uri_unescape_rule_t {
        self.0
    }
}
impl Default for UriUnescapeRule {
    fn default() -> Self {
        Self(cef_uri_unescape_rule_t::UU_NONE)
    }
}

/// See [cef_json_parser_options_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsonParserOptions(cef_json_parser_options_t);
impl AsRef<cef_json_parser_options_t> for JsonParserOptions {
    fn as_ref(&self) -> &cef_json_parser_options_t {
        &self.0
    }
}
impl AsMut<cef_json_parser_options_t> for JsonParserOptions {
    fn as_mut(&mut self) -> &mut cef_json_parser_options_t {
        &mut self.0
    }
}
impl From<cef_json_parser_options_t> for JsonParserOptions {
    fn from(value: cef_json_parser_options_t) -> Self {
        Self(value)
    }
}
impl Into<cef_json_parser_options_t> for JsonParserOptions {
    fn into(self) -> cef_json_parser_options_t {
        self.0
    }
}
impl Default for JsonParserOptions {
    fn default() -> Self {
        Self(cef_json_parser_options_t::JSON_PARSER_RFC)
    }
}

/// See [cef_json_writer_options_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsonWriterOptions(cef_json_writer_options_t);
impl AsRef<cef_json_writer_options_t> for JsonWriterOptions {
    fn as_ref(&self) -> &cef_json_writer_options_t {
        &self.0
    }
}
impl AsMut<cef_json_writer_options_t> for JsonWriterOptions {
    fn as_mut(&mut self) -> &mut cef_json_writer_options_t {
        &mut self.0
    }
}
impl From<cef_json_writer_options_t> for JsonWriterOptions {
    fn from(value: cef_json_writer_options_t) -> Self {
        Self(value)
    }
}
impl Into<cef_json_writer_options_t> for JsonWriterOptions {
    fn into(self) -> cef_json_writer_options_t {
        self.0
    }
}
impl Default for JsonWriterOptions {
    fn default() -> Self {
        Self(cef_json_writer_options_t::JSON_WRITER_DEFAULT)
    }
}

/// See [cef_pdf_print_margin_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PdfPrintMarginType(cef_pdf_print_margin_type_t);
impl AsRef<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn as_ref(&self) -> &cef_pdf_print_margin_type_t {
        &self.0
    }
}
impl AsMut<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn as_mut(&mut self) -> &mut cef_pdf_print_margin_type_t {
        &mut self.0
    }
}
impl From<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn from(value: cef_pdf_print_margin_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn into(self) -> cef_pdf_print_margin_type_t {
        self.0
    }
}
impl Default for PdfPrintMarginType {
    fn default() -> Self {
        Self(cef_pdf_print_margin_type_t::PDF_PRINT_MARGIN_DEFAULT)
    }
}

/// See [cef_scale_factor_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ScaleFactor(cef_scale_factor_t);
impl AsRef<cef_scale_factor_t> for ScaleFactor {
    fn as_ref(&self) -> &cef_scale_factor_t {
        &self.0
    }
}
impl AsMut<cef_scale_factor_t> for ScaleFactor {
    fn as_mut(&mut self) -> &mut cef_scale_factor_t {
        &mut self.0
    }
}
impl From<cef_scale_factor_t> for ScaleFactor {
    fn from(value: cef_scale_factor_t) -> Self {
        Self(value)
    }
}
impl Into<cef_scale_factor_t> for ScaleFactor {
    fn into(self) -> cef_scale_factor_t {
        self.0
    }
}
impl Default for ScaleFactor {
    fn default() -> Self {
        Self(cef_scale_factor_t::SCALE_FACTOR_NONE)
    }
}

/// See [cef_referrer_policy_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ReferrerPolicy(cef_referrer_policy_t);
impl AsRef<cef_referrer_policy_t> for ReferrerPolicy {
    fn as_ref(&self) -> &cef_referrer_policy_t {
        &self.0
    }
}
impl AsMut<cef_referrer_policy_t> for ReferrerPolicy {
    fn as_mut(&mut self) -> &mut cef_referrer_policy_t {
        &mut self.0
    }
}
impl From<cef_referrer_policy_t> for ReferrerPolicy {
    fn from(value: cef_referrer_policy_t) -> Self {
        Self(value)
    }
}
impl Into<cef_referrer_policy_t> for ReferrerPolicy {
    fn into(self) -> cef_referrer_policy_t {
        self.0
    }
}
impl Default for ReferrerPolicy {
    fn default() -> Self {
        Self (cef_referrer_policy_t :: REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE)
    }
}

/// See [cef_response_filter_status_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResponseFilterStatus(cef_response_filter_status_t);
impl AsRef<cef_response_filter_status_t> for ResponseFilterStatus {
    fn as_ref(&self) -> &cef_response_filter_status_t {
        &self.0
    }
}
impl AsMut<cef_response_filter_status_t> for ResponseFilterStatus {
    fn as_mut(&mut self) -> &mut cef_response_filter_status_t {
        &mut self.0
    }
}
impl From<cef_response_filter_status_t> for ResponseFilterStatus {
    fn from(value: cef_response_filter_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_response_filter_status_t> for ResponseFilterStatus {
    fn into(self) -> cef_response_filter_status_t {
        self.0
    }
}
impl Default for ResponseFilterStatus {
    fn default() -> Self {
        Self(cef_response_filter_status_t::RESPONSE_FILTER_NEED_MORE_DATA)
    }
}

/// See [cef_alpha_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AlphaType(cef_alpha_type_t);
impl AsRef<cef_alpha_type_t> for AlphaType {
    fn as_ref(&self) -> &cef_alpha_type_t {
        &self.0
    }
}
impl AsMut<cef_alpha_type_t> for AlphaType {
    fn as_mut(&mut self) -> &mut cef_alpha_type_t {
        &mut self.0
    }
}
impl From<cef_alpha_type_t> for AlphaType {
    fn from(value: cef_alpha_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_alpha_type_t> for AlphaType {
    fn into(self) -> cef_alpha_type_t {
        self.0
    }
}
impl Default for AlphaType {
    fn default() -> Self {
        Self(cef_alpha_type_t::CEF_ALPHA_TYPE_OPAQUE)
    }
}

/// See [cef_text_style_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextStyle(cef_text_style_t);
impl AsRef<cef_text_style_t> for TextStyle {
    fn as_ref(&self) -> &cef_text_style_t {
        &self.0
    }
}
impl AsMut<cef_text_style_t> for TextStyle {
    fn as_mut(&mut self) -> &mut cef_text_style_t {
        &mut self.0
    }
}
impl From<cef_text_style_t> for TextStyle {
    fn from(value: cef_text_style_t) -> Self {
        Self(value)
    }
}
impl Into<cef_text_style_t> for TextStyle {
    fn into(self) -> cef_text_style_t {
        self.0
    }
}
impl Default for TextStyle {
    fn default() -> Self {
        Self(cef_text_style_t::CEF_TEXT_STYLE_BOLD)
    }
}

/// See [cef_axis_alignment_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AxisAlignment(cef_axis_alignment_t);
impl AsRef<cef_axis_alignment_t> for AxisAlignment {
    fn as_ref(&self) -> &cef_axis_alignment_t {
        &self.0
    }
}
impl AsMut<cef_axis_alignment_t> for AxisAlignment {
    fn as_mut(&mut self) -> &mut cef_axis_alignment_t {
        &mut self.0
    }
}
impl From<cef_axis_alignment_t> for AxisAlignment {
    fn from(value: cef_axis_alignment_t) -> Self {
        Self(value)
    }
}
impl Into<cef_axis_alignment_t> for AxisAlignment {
    fn into(self) -> cef_axis_alignment_t {
        self.0
    }
}
impl Default for AxisAlignment {
    fn default() -> Self {
        Self(cef_axis_alignment_t::CEF_AXIS_ALIGNMENT_START)
    }
}

/// See [cef_button_state_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ButtonState(cef_button_state_t);
impl AsRef<cef_button_state_t> for ButtonState {
    fn as_ref(&self) -> &cef_button_state_t {
        &self.0
    }
}
impl AsMut<cef_button_state_t> for ButtonState {
    fn as_mut(&mut self) -> &mut cef_button_state_t {
        &mut self.0
    }
}
impl From<cef_button_state_t> for ButtonState {
    fn from(value: cef_button_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_button_state_t> for ButtonState {
    fn into(self) -> cef_button_state_t {
        self.0
    }
}
impl Default for ButtonState {
    fn default() -> Self {
        Self(cef_button_state_t::CEF_BUTTON_STATE_NORMAL)
    }
}

/// See [cef_horizontal_alignment_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HorizontalAlignment(cef_horizontal_alignment_t);
impl AsRef<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn as_ref(&self) -> &cef_horizontal_alignment_t {
        &self.0
    }
}
impl AsMut<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn as_mut(&mut self) -> &mut cef_horizontal_alignment_t {
        &mut self.0
    }
}
impl From<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn from(value: cef_horizontal_alignment_t) -> Self {
        Self(value)
    }
}
impl Into<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn into(self) -> cef_horizontal_alignment_t {
        self.0
    }
}
impl Default for HorizontalAlignment {
    fn default() -> Self {
        Self(cef_horizontal_alignment_t::CEF_HORIZONTAL_ALIGNMENT_LEFT)
    }
}

/// See [cef_menu_anchor_position_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuAnchorPosition(cef_menu_anchor_position_t);
impl AsRef<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn as_ref(&self) -> &cef_menu_anchor_position_t {
        &self.0
    }
}
impl AsMut<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn as_mut(&mut self) -> &mut cef_menu_anchor_position_t {
        &mut self.0
    }
}
impl From<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn from(value: cef_menu_anchor_position_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn into(self) -> cef_menu_anchor_position_t {
        self.0
    }
}
impl Default for MenuAnchorPosition {
    fn default() -> Self {
        Self(cef_menu_anchor_position_t::CEF_MENU_ANCHOR_TOPLEFT)
    }
}

/// See [cef_menu_color_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuColorType(cef_menu_color_type_t);
impl AsRef<cef_menu_color_type_t> for MenuColorType {
    fn as_ref(&self) -> &cef_menu_color_type_t {
        &self.0
    }
}
impl AsMut<cef_menu_color_type_t> for MenuColorType {
    fn as_mut(&mut self) -> &mut cef_menu_color_type_t {
        &mut self.0
    }
}
impl From<cef_menu_color_type_t> for MenuColorType {
    fn from(value: cef_menu_color_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_color_type_t> for MenuColorType {
    fn into(self) -> cef_menu_color_type_t {
        self.0
    }
}
impl Default for MenuColorType {
    fn default() -> Self {
        Self(cef_menu_color_type_t::CEF_MENU_COLOR_TEXT)
    }
}

/// See [cef_ssl_version_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SslVersion(cef_ssl_version_t);
impl AsRef<cef_ssl_version_t> for SslVersion {
    fn as_ref(&self) -> &cef_ssl_version_t {
        &self.0
    }
}
impl AsMut<cef_ssl_version_t> for SslVersion {
    fn as_mut(&mut self) -> &mut cef_ssl_version_t {
        &mut self.0
    }
}
impl From<cef_ssl_version_t> for SslVersion {
    fn from(value: cef_ssl_version_t) -> Self {
        Self(value)
    }
}
impl Into<cef_ssl_version_t> for SslVersion {
    fn into(self) -> cef_ssl_version_t {
        self.0
    }
}
impl Default for SslVersion {
    fn default() -> Self {
        Self(cef_ssl_version_t::SSL_CONNECTION_VERSION_UNKNOWN)
    }
}

/// See [cef_ssl_content_status_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SslContentStatus(cef_ssl_content_status_t);
impl AsRef<cef_ssl_content_status_t> for SslContentStatus {
    fn as_ref(&self) -> &cef_ssl_content_status_t {
        &self.0
    }
}
impl AsMut<cef_ssl_content_status_t> for SslContentStatus {
    fn as_mut(&mut self) -> &mut cef_ssl_content_status_t {
        &mut self.0
    }
}
impl From<cef_ssl_content_status_t> for SslContentStatus {
    fn from(value: cef_ssl_content_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_ssl_content_status_t> for SslContentStatus {
    fn into(self) -> cef_ssl_content_status_t {
        self.0
    }
}
impl Default for SslContentStatus {
    fn default() -> Self {
        Self(cef_ssl_content_status_t::SSL_CONTENT_NORMAL_CONTENT)
    }
}

/// See [cef_scheme_options_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SchemeOptions(cef_scheme_options_t);
impl AsRef<cef_scheme_options_t> for SchemeOptions {
    fn as_ref(&self) -> &cef_scheme_options_t {
        &self.0
    }
}
impl AsMut<cef_scheme_options_t> for SchemeOptions {
    fn as_mut(&mut self) -> &mut cef_scheme_options_t {
        &mut self.0
    }
}
impl From<cef_scheme_options_t> for SchemeOptions {
    fn from(value: cef_scheme_options_t) -> Self {
        Self(value)
    }
}
impl Into<cef_scheme_options_t> for SchemeOptions {
    fn into(self) -> cef_scheme_options_t {
        self.0
    }
}
impl Default for SchemeOptions {
    fn default() -> Self {
        Self(cef_scheme_options_t::CEF_SCHEME_OPTION_NONE)
    }
}

/// See [cef_composition_underline_style_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CompositionUnderlineStyle(cef_composition_underline_style_t);
impl AsRef<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn as_ref(&self) -> &cef_composition_underline_style_t {
        &self.0
    }
}
impl AsMut<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn as_mut(&mut self) -> &mut cef_composition_underline_style_t {
        &mut self.0
    }
}
impl From<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn from(value: cef_composition_underline_style_t) -> Self {
        Self(value)
    }
}
impl Into<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn into(self) -> cef_composition_underline_style_t {
        self.0
    }
}
impl Default for CompositionUnderlineStyle {
    fn default() -> Self {
        Self(cef_composition_underline_style_t::CEF_CUS_SOLID)
    }
}

/// See [cef_channel_layout_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChannelLayout(cef_channel_layout_t);
impl AsRef<cef_channel_layout_t> for ChannelLayout {
    fn as_ref(&self) -> &cef_channel_layout_t {
        &self.0
    }
}
impl AsMut<cef_channel_layout_t> for ChannelLayout {
    fn as_mut(&mut self) -> &mut cef_channel_layout_t {
        &mut self.0
    }
}
impl From<cef_channel_layout_t> for ChannelLayout {
    fn from(value: cef_channel_layout_t) -> Self {
        Self(value)
    }
}
impl Into<cef_channel_layout_t> for ChannelLayout {
    fn into(self) -> cef_channel_layout_t {
        self.0
    }
}
impl Default for ChannelLayout {
    fn default() -> Self {
        Self(cef_channel_layout_t::CEF_CHANNEL_LAYOUT_NONE)
    }
}

/// See [cef_media_route_create_result_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaRouteCreateResult(cef_media_route_create_result_t);
impl AsRef<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn as_ref(&self) -> &cef_media_route_create_result_t {
        &self.0
    }
}
impl AsMut<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn as_mut(&mut self) -> &mut cef_media_route_create_result_t {
        &mut self.0
    }
}
impl From<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn from(value: cef_media_route_create_result_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn into(self) -> cef_media_route_create_result_t {
        self.0
    }
}
impl Default for MediaRouteCreateResult {
    fn default() -> Self {
        Self(cef_media_route_create_result_t::CEF_MRCR_UNKNOWN_ERROR)
    }
}

/// See [cef_media_route_connection_state_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaRouteConnectionState(cef_media_route_connection_state_t);
impl AsRef<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn as_ref(&self) -> &cef_media_route_connection_state_t {
        &self.0
    }
}
impl AsMut<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn as_mut(&mut self) -> &mut cef_media_route_connection_state_t {
        &mut self.0
    }
}
impl From<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn from(value: cef_media_route_connection_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn into(self) -> cef_media_route_connection_state_t {
        self.0
    }
}
impl Default for MediaRouteConnectionState {
    fn default() -> Self {
        Self(cef_media_route_connection_state_t::CEF_MRCS_UNKNOWN)
    }
}

/// See [cef_media_sink_icon_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaSinkIconType(cef_media_sink_icon_type_t);
impl AsRef<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn as_ref(&self) -> &cef_media_sink_icon_type_t {
        &self.0
    }
}
impl AsMut<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn as_mut(&mut self) -> &mut cef_media_sink_icon_type_t {
        &mut self.0
    }
}
impl From<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn from(value: cef_media_sink_icon_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn into(self) -> cef_media_sink_icon_type_t {
        self.0
    }
}
impl Default for MediaSinkIconType {
    fn default() -> Self {
        Self(cef_media_sink_icon_type_t::CEF_MSIT_CAST)
    }
}

/// See [cef_text_field_commands_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextFieldCommands(cef_text_field_commands_t);
impl AsRef<cef_text_field_commands_t> for TextFieldCommands {
    fn as_ref(&self) -> &cef_text_field_commands_t {
        &self.0
    }
}
impl AsMut<cef_text_field_commands_t> for TextFieldCommands {
    fn as_mut(&mut self) -> &mut cef_text_field_commands_t {
        &mut self.0
    }
}
impl From<cef_text_field_commands_t> for TextFieldCommands {
    fn from(value: cef_text_field_commands_t) -> Self {
        Self(value)
    }
}
impl Into<cef_text_field_commands_t> for TextFieldCommands {
    fn into(self) -> cef_text_field_commands_t {
        self.0
    }
}
impl Default for TextFieldCommands {
    fn default() -> Self {
        Self(cef_text_field_commands_t::CEF_TFC_CUT)
    }
}

/// See [cef_chrome_toolbar_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromeToolbarType(cef_chrome_toolbar_type_t);
impl AsRef<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn as_ref(&self) -> &cef_chrome_toolbar_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn as_mut(&mut self) -> &mut cef_chrome_toolbar_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn from(value: cef_chrome_toolbar_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn into(self) -> cef_chrome_toolbar_type_t {
        self.0
    }
}
impl Default for ChromeToolbarType {
    fn default() -> Self {
        Self(cef_chrome_toolbar_type_t::CEF_CTT_NONE)
    }
}

/// See [cef_chrome_page_action_icon_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromePageActionIconType(cef_chrome_page_action_icon_type_t);
impl AsRef<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn as_ref(&self) -> &cef_chrome_page_action_icon_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn as_mut(&mut self) -> &mut cef_chrome_page_action_icon_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn from(value: cef_chrome_page_action_icon_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn into(self) -> cef_chrome_page_action_icon_type_t {
        self.0
    }
}
impl Default for ChromePageActionIconType {
    fn default() -> Self {
        Self(cef_chrome_page_action_icon_type_t::CEF_CPAIT_BOOKMARK_STAR)
    }
}

/// See [cef_chrome_toolbar_button_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromeToolbarButtonType(cef_chrome_toolbar_button_type_t);
impl AsRef<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn as_ref(&self) -> &cef_chrome_toolbar_button_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn as_mut(&mut self) -> &mut cef_chrome_toolbar_button_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn from(value: cef_chrome_toolbar_button_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn into(self) -> cef_chrome_toolbar_button_type_t {
        self.0
    }
}
impl Default for ChromeToolbarButtonType {
    fn default() -> Self {
        Self(cef_chrome_toolbar_button_type_t::CEF_CTBT_CAST)
    }
}

/// See [cef_docking_mode_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DockingMode(cef_docking_mode_t);
impl AsRef<cef_docking_mode_t> for DockingMode {
    fn as_ref(&self) -> &cef_docking_mode_t {
        &self.0
    }
}
impl AsMut<cef_docking_mode_t> for DockingMode {
    fn as_mut(&mut self) -> &mut cef_docking_mode_t {
        &mut self.0
    }
}
impl From<cef_docking_mode_t> for DockingMode {
    fn from(value: cef_docking_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_docking_mode_t> for DockingMode {
    fn into(self) -> cef_docking_mode_t {
        self.0
    }
}
impl Default for DockingMode {
    fn default() -> Self {
        Self(cef_docking_mode_t::CEF_DOCKING_MODE_TOP_LEFT)
    }
}

/// See [cef_show_state_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ShowState(cef_show_state_t);
impl AsRef<cef_show_state_t> for ShowState {
    fn as_ref(&self) -> &cef_show_state_t {
        &self.0
    }
}
impl AsMut<cef_show_state_t> for ShowState {
    fn as_mut(&mut self) -> &mut cef_show_state_t {
        &mut self.0
    }
}
impl From<cef_show_state_t> for ShowState {
    fn from(value: cef_show_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_show_state_t> for ShowState {
    fn into(self) -> cef_show_state_t {
        self.0
    }
}
impl Default for ShowState {
    fn default() -> Self {
        Self(cef_show_state_t::CEF_SHOW_STATE_NORMAL)
    }
}

/// See [cef_touch_handle_state_flags_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TouchHandleStateFlags(cef_touch_handle_state_flags_t);
impl AsRef<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn as_ref(&self) -> &cef_touch_handle_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn as_mut(&mut self) -> &mut cef_touch_handle_state_flags_t {
        &mut self.0
    }
}
impl From<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn from(value: cef_touch_handle_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn into(self) -> cef_touch_handle_state_flags_t {
        self.0
    }
}
impl Default for TouchHandleStateFlags {
    fn default() -> Self {
        Self(cef_touch_handle_state_flags_t::CEF_THS_FLAG_NONE)
    }
}

/// See [cef_media_access_permission_types_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaAccessPermissionTypes(cef_media_access_permission_types_t);
impl AsRef<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn as_ref(&self) -> &cef_media_access_permission_types_t {
        &self.0
    }
}
impl AsMut<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn as_mut(&mut self) -> &mut cef_media_access_permission_types_t {
        &mut self.0
    }
}
impl From<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn from(value: cef_media_access_permission_types_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn into(self) -> cef_media_access_permission_types_t {
        self.0
    }
}
impl Default for MediaAccessPermissionTypes {
    fn default() -> Self {
        Self(cef_media_access_permission_types_t::CEF_MEDIA_PERMISSION_NONE)
    }
}

/// See [cef_permission_request_types_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PermissionRequestTypes(cef_permission_request_types_t);
impl AsRef<cef_permission_request_types_t> for PermissionRequestTypes {
    fn as_ref(&self) -> &cef_permission_request_types_t {
        &self.0
    }
}
impl AsMut<cef_permission_request_types_t> for PermissionRequestTypes {
    fn as_mut(&mut self) -> &mut cef_permission_request_types_t {
        &mut self.0
    }
}
impl From<cef_permission_request_types_t> for PermissionRequestTypes {
    fn from(value: cef_permission_request_types_t) -> Self {
        Self(value)
    }
}
impl Into<cef_permission_request_types_t> for PermissionRequestTypes {
    fn into(self) -> cef_permission_request_types_t {
        self.0
    }
}
impl Default for PermissionRequestTypes {
    fn default() -> Self {
        Self(cef_permission_request_types_t::CEF_PERMISSION_TYPE_NONE)
    }
}

/// See [cef_permission_request_result_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PermissionRequestResult(cef_permission_request_result_t);
impl AsRef<cef_permission_request_result_t> for PermissionRequestResult {
    fn as_ref(&self) -> &cef_permission_request_result_t {
        &self.0
    }
}
impl AsMut<cef_permission_request_result_t> for PermissionRequestResult {
    fn as_mut(&mut self) -> &mut cef_permission_request_result_t {
        &mut self.0
    }
}
impl From<cef_permission_request_result_t> for PermissionRequestResult {
    fn from(value: cef_permission_request_result_t) -> Self {
        Self(value)
    }
}
impl Into<cef_permission_request_result_t> for PermissionRequestResult {
    fn into(self) -> cef_permission_request_result_t {
        self.0
    }
}
impl Default for PermissionRequestResult {
    fn default() -> Self {
        Self(cef_permission_request_result_t::CEF_PERMISSION_RESULT_ACCEPT)
    }
}

/// See [cef_test_cert_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TestCertType(cef_test_cert_type_t);
impl AsRef<cef_test_cert_type_t> for TestCertType {
    fn as_ref(&self) -> &cef_test_cert_type_t {
        &self.0
    }
}
impl AsMut<cef_test_cert_type_t> for TestCertType {
    fn as_mut(&mut self) -> &mut cef_test_cert_type_t {
        &mut self.0
    }
}
impl From<cef_test_cert_type_t> for TestCertType {
    fn from(value: cef_test_cert_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_test_cert_type_t> for TestCertType {
    fn into(self) -> cef_test_cert_type_t {
        self.0
    }
}
impl Default for TestCertType {
    fn default() -> Self {
        Self(cef_test_cert_type_t::CEF_TEST_CERT_OK_IP)
    }
}

/// See [cef_preferences_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PreferencesType(cef_preferences_type_t);
impl AsRef<cef_preferences_type_t> for PreferencesType {
    fn as_ref(&self) -> &cef_preferences_type_t {
        &self.0
    }
}
impl AsMut<cef_preferences_type_t> for PreferencesType {
    fn as_mut(&mut self) -> &mut cef_preferences_type_t {
        &mut self.0
    }
}
impl From<cef_preferences_type_t> for PreferencesType {
    fn from(value: cef_preferences_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_preferences_type_t> for PreferencesType {
    fn into(self) -> cef_preferences_type_t {
        self.0
    }
}
impl Default for PreferencesType {
    fn default() -> Self {
        Self(cef_preferences_type_t::CEF_PREFERENCES_TYPE_GLOBAL)
    }
}

/// See [cef_download_interrupt_reason_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DownloadInterruptReason(cef_download_interrupt_reason_t);
impl AsRef<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn as_ref(&self) -> &cef_download_interrupt_reason_t {
        &self.0
    }
}
impl AsMut<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn as_mut(&mut self) -> &mut cef_download_interrupt_reason_t {
        &mut self.0
    }
}
impl From<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn from(value: cef_download_interrupt_reason_t) -> Self {
        Self(value)
    }
}
impl Into<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn into(self) -> cef_download_interrupt_reason_t {
        self.0
    }
}
impl Default for DownloadInterruptReason {
    fn default() -> Self {
        Self(cef_download_interrupt_reason_t::CEF_DOWNLOAD_INTERRUPT_REASON_NONE)
    }
}

/// See [cef_gesture_command_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GestureCommand(cef_gesture_command_t);
impl AsRef<cef_gesture_command_t> for GestureCommand {
    fn as_ref(&self) -> &cef_gesture_command_t {
        &self.0
    }
}
impl AsMut<cef_gesture_command_t> for GestureCommand {
    fn as_mut(&mut self) -> &mut cef_gesture_command_t {
        &mut self.0
    }
}
impl From<cef_gesture_command_t> for GestureCommand {
    fn from(value: cef_gesture_command_t) -> Self {
        Self(value)
    }
}
impl Into<cef_gesture_command_t> for GestureCommand {
    fn into(self) -> cef_gesture_command_t {
        self.0
    }
}
impl Default for GestureCommand {
    fn default() -> Self {
        Self(cef_gesture_command_t::CEF_GESTURE_COMMAND_BACK)
    }
}

/// See [cef_zoom_command_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ZoomCommand(cef_zoom_command_t);
impl AsRef<cef_zoom_command_t> for ZoomCommand {
    fn as_ref(&self) -> &cef_zoom_command_t {
        &self.0
    }
}
impl AsMut<cef_zoom_command_t> for ZoomCommand {
    fn as_mut(&mut self) -> &mut cef_zoom_command_t {
        &mut self.0
    }
}
impl From<cef_zoom_command_t> for ZoomCommand {
    fn from(value: cef_zoom_command_t) -> Self {
        Self(value)
    }
}
impl Into<cef_zoom_command_t> for ZoomCommand {
    fn into(self) -> cef_zoom_command_t {
        self.0
    }
}
impl Default for ZoomCommand {
    fn default() -> Self {
        Self(cef_zoom_command_t::CEF_ZOOM_COMMAND_OUT)
    }
}

/// See [cef_color_variant_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorVariant(cef_color_variant_t);
impl AsRef<cef_color_variant_t> for ColorVariant {
    fn as_ref(&self) -> &cef_color_variant_t {
        &self.0
    }
}
impl AsMut<cef_color_variant_t> for ColorVariant {
    fn as_mut(&mut self) -> &mut cef_color_variant_t {
        &mut self.0
    }
}
impl From<cef_color_variant_t> for ColorVariant {
    fn from(value: cef_color_variant_t) -> Self {
        Self(value)
    }
}
impl Into<cef_color_variant_t> for ColorVariant {
    fn into(self) -> cef_color_variant_t {
        self.0
    }
}
impl Default for ColorVariant {
    fn default() -> Self {
        Self(cef_color_variant_t::CEF_COLOR_VARIANT_SYSTEM)
    }
}

/// See [cef_task_type_t] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TaskType(cef_task_type_t);
impl AsRef<cef_task_type_t> for TaskType {
    fn as_ref(&self) -> &cef_task_type_t {
        &self.0
    }
}
impl AsMut<cef_task_type_t> for TaskType {
    fn as_mut(&mut self) -> &mut cef_task_type_t {
        &mut self.0
    }
}
impl From<cef_task_type_t> for TaskType {
    fn from(value: cef_task_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_task_type_t> for TaskType {
    fn into(self) -> cef_task_type_t {
        self.0
    }
}
impl Default for TaskType {
    fn default() -> Self {
        Self(cef_task_type_t::CEF_TASK_TYPE_UNKNOWN)
    }
}

/// See [cef_string_wide_set] for more documentation.
pub fn string_wide_set(
    src: Option<&[wchar_t]>,
    output: Option<&mut CefStringWide>,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_copy = arg_copy;
        let result = cef_string_wide_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.as_wrapper()
    }
}

/// See [cef_string_utf8_set] for more documentation.
pub fn string_utf8_set(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringUtf8>,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_copy = arg_copy;
        let result = cef_string_utf8_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.as_wrapper()
    }
}

/// See [cef_string_utf16_set] for more documentation.
pub fn string_utf16_set(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf16>,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_copy = arg_copy;
        let result = cef_string_utf16_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.as_wrapper()
    }
}

/// See [cef_string_wide_clear] for more documentation.
pub fn string_wide_clear(str_: Option<&mut CefStringWide>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_wide_clear(arg_str_);
        result.as_wrapper()
    }
}

/// See [cef_string_utf8_clear] for more documentation.
pub fn string_utf8_clear(str_: Option<&mut CefStringUtf8>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf8_clear(arg_str_);
        result.as_wrapper()
    }
}

/// See [cef_string_utf16_clear] for more documentation.
pub fn string_utf16_clear(str_: Option<&mut CefStringUtf16>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_clear(arg_str_);
        result.as_wrapper()
    }
}

/// See [cef_string_wide_cmp] for more documentation.
pub fn string_wide_cmp(
    str_1: Option<&CefStringWide>,
    str_2: Option<&CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let arg_str_2 = arg_str_2
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_wide_cmp(arg_str_1, arg_str_2);
        result.as_wrapper()
    }
}

/// See [cef_string_utf8_cmp] for more documentation.
pub fn string_utf8_cmp(
    str_1: Option<&CefStringUtf8>,
    str_2: Option<&CefStringUtf8>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let arg_str_2 = arg_str_2
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_utf8_cmp(arg_str_1, arg_str_2);
        result.as_wrapper()
    }
}

/// See [cef_string_utf16_cmp] for more documentation.
pub fn string_utf16_cmp(
    str_1: Option<&CefStringUtf16>,
    str_2: Option<&CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let arg_str_2 = arg_str_2
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_utf16_cmp(arg_str_1, arg_str_2);
        result.as_wrapper()
    }
}

/// See [cef_string_wide_to_utf8] for more documentation.
pub fn string_wide_to_utf8(
    src: Option<&[wchar_t]>,
    output: Option<&mut CefStringUtf8>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_wide_to_utf8(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_utf8_to_wide] for more documentation.
pub fn string_utf8_to_wide(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf8_to_wide(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_wide_to_utf16] for more documentation.
pub fn string_wide_to_utf16(
    src: Option<&[wchar_t]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_wide_to_utf16(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_utf16_to_wide] for more documentation.
pub fn string_utf16_to_wide(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_wide(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_utf8_to_utf16] for more documentation.
pub fn string_utf8_to_utf16(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf8_to_utf16(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_utf16_to_utf8] for more documentation.
pub fn string_utf16_to_utf8(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf8>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_utf8(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_ascii_to_wide] for more documentation.
pub fn string_ascii_to_wide(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_ascii_to_wide(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_ascii_to_utf16] for more documentation.
pub fn string_ascii_to_utf16(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_ascii_to_utf16(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_userfree_wide_alloc] for more documentation.
pub fn string_userfree_wide_alloc() -> Option<CefStringWide> {
    unsafe {
        let result = cef_string_userfree_wide_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_string_userfree_utf8_alloc] for more documentation.
pub fn string_userfree_utf8_alloc() -> Option<CefStringUtf8> {
    unsafe {
        let result = cef_string_userfree_utf8_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_string_userfree_utf16_alloc] for more documentation.
pub fn string_userfree_utf16_alloc() -> Option<CefStringUtf16> {
    unsafe {
        let result = cef_string_userfree_utf16_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_string_userfree_wide_free] for more documentation.
pub fn string_userfree_wide_free(str_: Option<&mut CefStringWide>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_userfree_wide_free(arg_str_);
        result.as_wrapper()
    }
}

/// See [cef_string_userfree_utf8_free] for more documentation.
pub fn string_userfree_utf8_free(str_: Option<&mut CefStringUtf8>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_userfree_utf8_free(arg_str_);
        result.as_wrapper()
    }
}

/// See [cef_string_userfree_utf16_free] for more documentation.
pub fn string_userfree_utf16_free(str_: Option<&mut CefStringUtf16>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_userfree_utf16_free(arg_str_);
        result.as_wrapper()
    }
}

/// See [cef_string_utf16_to_lower] for more documentation.
pub fn string_utf16_to_lower(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_lower(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_utf16_to_upper] for more documentation.
pub fn string_utf16_to_upper(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_upper(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}

/// See [cef_string_list_alloc] for more documentation.
pub fn string_list_alloc() -> Option<CefStringList> {
    unsafe {
        let result = cef_string_list_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_string_list_size] for more documentation.
pub fn string_list_size(list: Option<&mut CefStringList>) -> usize {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_size(arg_list);
        result.as_wrapper()
    }
}

/// See [cef_string_list_value] for more documentation.
pub fn string_list_value(
    list: Option<&mut CefStringList>,
    index: usize,
    value: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_list, arg_index, arg_value) = (list, index, value);
        let arg_list = arg_list
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_index = arg_index;
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_value(arg_list, arg_index, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_list_append] for more documentation.
pub fn string_list_append(list: Option<&mut CefStringList>, value: Option<&CefStringUtf16>) {
    unsafe {
        let (arg_list, arg_value) = (list, value);
        let arg_list = arg_list
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_list_append(arg_list, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_list_clear] for more documentation.
pub fn string_list_clear(list: Option<&mut CefStringList>) {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_clear(arg_list);
        result.as_wrapper()
    }
}

/// See [cef_string_list_free] for more documentation.
pub fn string_list_free(list: Option<&mut CefStringList>) {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_free(arg_list);
        result.as_wrapper()
    }
}

/// See [cef_string_list_copy] for more documentation.
pub fn string_list_copy(list: Option<&mut CefStringList>) -> Option<CefStringList> {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_copy(arg_list);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_string_map_alloc] for more documentation.
pub fn string_map_alloc() -> Option<CefStringMap> {
    unsafe {
        let result = cef_string_map_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_string_map_size] for more documentation.
pub fn string_map_size(map: Option<&mut CefStringMap>) -> usize {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_size(arg_map);
        result.as_wrapper()
    }
}

/// See [cef_string_map_find] for more documentation.
pub fn string_map_find(
    map: Option<&mut CefStringMap>,
    key: Option<&CefStringUtf16>,
    value: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_find(arg_map, arg_key, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_map_key] for more documentation.
pub fn string_map_key(
    map: Option<&mut CefStringMap>,
    index: usize,
    key: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_key) = (map, index, key);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_index = arg_index;
        let arg_key = arg_key
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_key(arg_map, arg_index, arg_key);
        result.as_wrapper()
    }
}

/// See [cef_string_map_value] for more documentation.
pub fn string_map_value(
    map: Option<&mut CefStringMap>,
    index: usize,
    value: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_value) = (map, index, value);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_index = arg_index;
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_value(arg_map, arg_index, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_map_append] for more documentation.
pub fn string_map_append(
    map: Option<&mut CefStringMap>,
    key: Option<&CefStringUtf16>,
    value: Option<&CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_map_append(arg_map, arg_key, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_map_clear] for more documentation.
pub fn string_map_clear(map: Option<&mut CefStringMap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_clear(arg_map);
        result.as_wrapper()
    }
}

/// See [cef_string_map_free] for more documentation.
pub fn string_map_free(map: Option<&mut CefStringMap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_free(arg_map);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_alloc] for more documentation.
pub fn string_multimap_alloc() -> Option<CefStringMultimap> {
    unsafe {
        let result = cef_string_multimap_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_string_multimap_size] for more documentation.
pub fn string_multimap_size(map: Option<&mut CefStringMultimap>) -> usize {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_size(arg_map);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_find_count] for more documentation.
pub fn string_multimap_find_count(
    map: Option<&mut CefStringMultimap>,
    key: Option<&CefStringUtf16>,
) -> usize {
    unsafe {
        let (arg_map, arg_key) = (map, key);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let result = cef_string_multimap_find_count(arg_map, arg_key);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_enumerate] for more documentation.
pub fn string_multimap_enumerate(
    map: Option<&mut CefStringMultimap>,
    key: Option<&CefStringUtf16>,
    value_index: usize,
    value: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value_index, arg_value) = (map, key, value_index, value);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_value_index = arg_value_index;
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_enumerate(arg_map, arg_key, arg_value_index, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_key] for more documentation.
pub fn string_multimap_key(
    map: Option<&mut CefStringMultimap>,
    index: usize,
    key: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_key) = (map, index, key);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_index = arg_index;
        let arg_key = arg_key
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_key(arg_map, arg_index, arg_key);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_value] for more documentation.
pub fn string_multimap_value(
    map: Option<&mut CefStringMultimap>,
    index: usize,
    value: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_value) = (map, index, value);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_index = arg_index;
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_value(arg_map, arg_index, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_append] for more documentation.
pub fn string_multimap_append(
    map: Option<&mut CefStringMultimap>,
    key: Option<&CefStringUtf16>,
    value: Option<&CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_multimap_append(arg_map, arg_key, arg_value);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_clear] for more documentation.
pub fn string_multimap_clear(map: Option<&mut CefStringMultimap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_clear(arg_map);
        result.as_wrapper()
    }
}

/// See [cef_string_multimap_free] for more documentation.
pub fn string_multimap_free(map: Option<&mut CefStringMultimap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_free(arg_map);
        result.as_wrapper()
    }
}

/// See [cef_time_to_timet] for more documentation.
pub fn time_to_timet(cef_time: Option<&Time>, time: Option<&mut time_t>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time, arg_time) = (cef_time, time);
        let arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_time = arg_time
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_to_timet(arg_cef_time, arg_time);
        result.as_wrapper()
    }
}

/// See [cef_time_from_timet] for more documentation.
pub fn time_from_timet(time: time_t, cef_time: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_time, arg_cef_time) = (time, cef_time);
        let arg_time = arg_time;
        let mut arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_from_timet(arg_time, arg_cef_time);
        result.as_wrapper()
    }
}

/// See [cef_time_to_doublet] for more documentation.
pub fn time_to_doublet(cef_time: Option<&Time>, time: Option<&mut f64>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time, arg_time) = (cef_time, time);
        let arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_time = arg_time
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_to_doublet(arg_cef_time, arg_time);
        result.as_wrapper()
    }
}

/// See [cef_time_from_doublet] for more documentation.
pub fn time_from_doublet(time: f64, cef_time: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_time, arg_cef_time) = (time, cef_time);
        let arg_time = arg_time;
        let mut arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_from_doublet(arg_time, arg_cef_time);
        result.as_wrapper()
    }
}

/// See [cef_time_now] for more documentation.
pub fn time_now(cef_time: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let arg_cef_time = cef_time;
        let mut arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_now(arg_cef_time);
        result.as_wrapper()
    }
}

/// See [cef_basetime_now] for more documentation.
pub fn basetime_now() -> Basetime {
    unsafe {
        let result = cef_basetime_now();
        result.as_wrapper()
    }
}

/// See [cef_time_delta] for more documentation.
pub fn time_delta(
    cef_time_1: Option<&Time>,
    cef_time_2: Option<&Time>,
    delta: Option<&mut ::std::os::raw::c_longlong>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time_1, arg_cef_time_2, arg_delta) = (cef_time_1, cef_time_2, delta);
        let arg_cef_time_1 = arg_cef_time_1.cloned().map(|arg| arg.into());
        let arg_cef_time_1 = arg_cef_time_1
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_cef_time_2 = arg_cef_time_2.cloned().map(|arg| arg.into());
        let arg_cef_time_2 = arg_cef_time_2
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_delta = arg_delta
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_delta(arg_cef_time_1, arg_cef_time_2, arg_delta);
        result.as_wrapper()
    }
}

/// See [cef_time_to_basetime] for more documentation.
pub fn time_to_basetime(from: Option<&Time>, to: Option<&mut Basetime>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_from, arg_to) = (from, to);
        let arg_from = arg_from.cloned().map(|arg| arg.into());
        let arg_from = arg_from
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let mut arg_to = arg_to.cloned().map(|arg| arg.into());
        let arg_to = arg_to
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_to_basetime(arg_from, arg_to);
        result.as_wrapper()
    }
}

/// See [cef_time_from_basetime] for more documentation.
pub fn time_from_basetime(from: _cef_basetime_t, to: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_from, arg_to) = (from, to);
        let mut arg_to = arg_to.cloned().map(|arg| arg.into());
        let arg_to = arg_to
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_from_basetime(arg_from, arg_to);
        result.as_wrapper()
    }
}

/// See [cef_get_xdisplay] for more documentation.
pub fn get_xdisplay() -> *mut XDisplay {
    unsafe {
        let result = cef_get_xdisplay();
        result.as_wrapper()
    }
}

/// See [cef_value_create] for more documentation.
pub fn value_create() -> Option<Value> {
    unsafe {
        let result = cef_value_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_binary_value_create] for more documentation.
pub fn binary_value_create(data: Option<&[u8]>) -> Option<BinaryValue> {
    unsafe {
        let arg_data = data;
        let arg_data_size = arg_data.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_data = arg_data
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let result = cef_binary_value_create(arg_data, arg_data_size);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_dictionary_value_create] for more documentation.
pub fn dictionary_value_create() -> Option<DictionaryValue> {
    unsafe {
        let result = cef_dictionary_value_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_list_value_create] for more documentation.
pub fn list_value_create() -> Option<ListValue> {
    unsafe {
        let result = cef_list_value_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_image_create] for more documentation.
pub fn image_create() -> Option<Image> {
    unsafe {
        let result = cef_image_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_stream_reader_create_for_file] for more documentation.
pub fn stream_reader_create_for_file(file_name: Option<&CefStringUtf16>) -> Option<StreamReader> {
    unsafe {
        let arg_file_name = file_name;
        let arg_file_name = arg_file_name
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_stream_reader_create_for_file(arg_file_name);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_stream_reader_create_for_data] for more documentation.
pub fn stream_reader_create_for_data(data: *mut u8, size: usize) -> Option<StreamReader> {
    unsafe {
        let (arg_data, arg_size) = (data, size);
        let arg_data = arg_data as *mut _;
        let arg_size = arg_size;
        let result = cef_stream_reader_create_for_data(arg_data, arg_size);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_stream_reader_create_for_handler] for more documentation.
pub fn stream_reader_create_for_handler(
    handler: Option<&mut impl ImplReadHandler>,
) -> Option<StreamReader> {
    unsafe {
        let arg_handler = handler;
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplReadHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_stream_reader_create_for_handler(arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_stream_writer_create_for_file] for more documentation.
pub fn stream_writer_create_for_file(file_name: Option<&CefStringUtf16>) -> Option<StreamWriter> {
    unsafe {
        let arg_file_name = file_name;
        let arg_file_name = arg_file_name
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_stream_writer_create_for_file(arg_file_name);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_stream_writer_create_for_handler] for more documentation.
pub fn stream_writer_create_for_handler(
    handler: Option<&mut impl ImplWriteHandler>,
) -> Option<StreamWriter> {
    unsafe {
        let arg_handler = handler;
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplWriteHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_stream_writer_create_for_handler(arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_drag_data_create] for more documentation.
pub fn drag_data_create() -> Option<DragData> {
    unsafe {
        let result = cef_drag_data_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_process_message_create] for more documentation.
pub fn process_message_create(name: Option<&CefStringUtf16>) -> Option<ProcessMessage> {
    unsafe {
        let arg_name = name;
        let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let result = cef_process_message_create(arg_name);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_request_create] for more documentation.
pub fn request_create() -> Option<Request> {
    unsafe {
        let result = cef_request_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_post_data_create] for more documentation.
pub fn post_data_create() -> Option<PostData> {
    unsafe {
        let result = cef_post_data_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_post_data_element_create] for more documentation.
pub fn post_data_element_create() -> Option<PostDataElement> {
    unsafe {
        let result = cef_post_data_element_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_cookie_manager_get_global_manager] for more documentation.
pub fn cookie_manager_get_global_manager(
    callback: Option<&mut impl ImplCompletionCallback>,
) -> Option<CookieManager> {
    unsafe {
        let arg_callback = callback;
        let arg_callback = arg_callback
            .map(|arg| {
                arg.add_ref();
                ImplCompletionCallback::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_cookie_manager_get_global_manager(arg_callback);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_media_router_get_global] for more documentation.
pub fn media_router_get_global(
    callback: Option<&mut impl ImplCompletionCallback>,
) -> Option<MediaRouter> {
    unsafe {
        let arg_callback = callback;
        let arg_callback = arg_callback
            .map(|arg| {
                arg.add_ref();
                ImplCompletionCallback::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_media_router_get_global(arg_callback);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_preference_manager_get_global] for more documentation.
pub fn preference_manager_get_global() -> Option<PreferenceManager> {
    unsafe {
        let result = cef_preference_manager_get_global();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_request_context_get_global_context] for more documentation.
pub fn request_context_get_global_context() -> Option<RequestContext> {
    unsafe {
        let result = cef_request_context_get_global_context();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_request_context_create_context] for more documentation.
pub fn request_context_create_context(
    settings: Option<&RequestContextSettings>,
    handler: Option<&mut impl ImplRequestContextHandler>,
) -> Option<RequestContext> {
    unsafe {
        let (arg_settings, arg_handler) = (settings, handler);
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplRequestContextHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_request_context_create_context(arg_settings, arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_create_context_shared] for more documentation.
pub fn create_context_shared(
    other: Option<&mut impl ImplRequestContext>,
    handler: Option<&mut impl ImplRequestContextHandler>,
) -> Option<RequestContext> {
    unsafe {
        let (arg_other, arg_handler) = (other, handler);
        let arg_other = arg_other
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplRequestContextHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_create_context_shared(arg_other, arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_browser_host_create_browser] for more documentation.
pub fn browser_host_create_browser(
    window_info: Option<&WindowInfo>,
    client: Option<&mut impl ImplClient>,
    url: Option<&CefStringUtf16>,
    settings: Option<&BrowserSettings>,
    extra_info: Option<&mut impl ImplDictionaryValue>,
    request_context: Option<&mut impl ImplRequestContext>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        ) = (
            window_info,
            client,
            url,
            settings,
            extra_info,
            request_context,
        );
        let arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
        let arg_window_info = arg_window_info
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_extra_info = arg_extra_info
            .map(|arg| {
                arg.add_ref();
                ImplDictionaryValue::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_host_create_browser(
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        );
        result.as_wrapper()
    }
}

/// See [cef_browser_host_create_browser_sync] for more documentation.
pub fn browser_host_create_browser_sync(
    window_info: Option<&WindowInfo>,
    client: Option<&mut impl ImplClient>,
    url: Option<&CefStringUtf16>,
    settings: Option<&BrowserSettings>,
    extra_info: Option<&mut impl ImplDictionaryValue>,
    request_context: Option<&mut impl ImplRequestContext>,
) -> Option<Browser> {
    unsafe {
        let (
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        ) = (
            window_info,
            client,
            url,
            settings,
            extra_info,
            request_context,
        );
        let arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
        let arg_window_info = arg_window_info
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_extra_info = arg_extra_info
            .map(|arg| {
                arg.add_ref();
                ImplDictionaryValue::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_host_create_browser_sync(
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        );
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_browser_host_get_browser_by_identifier] for more documentation.
pub fn browser_host_get_browser_by_identifier(
    browser_id: ::std::os::raw::c_int,
) -> Option<Browser> {
    unsafe {
        let arg_browser_id = browser_id;
        let arg_browser_id = arg_browser_id;
        let result = cef_browser_host_get_browser_by_identifier(arg_browser_id);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_menu_model_create] for more documentation.
pub fn menu_model_create(delegate: Option<&mut impl ImplMenuModelDelegate>) -> Option<MenuModel> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplMenuModelDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_menu_model_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_print_settings_create] for more documentation.
pub fn print_settings_create() -> Option<PrintSettings> {
    unsafe {
        let result = cef_print_settings_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_response_create] for more documentation.
pub fn response_create() -> Option<Response> {
    unsafe {
        let result = cef_response_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_is_cert_status_error] for more documentation.
pub fn is_cert_status_error(status: CertStatus) -> ::std::os::raw::c_int {
    unsafe {
        let arg_status = status;
        let arg_status = arg_status.as_raw();
        let result = cef_is_cert_status_error(arg_status);
        result.as_wrapper()
    }
}

/// See [cef_command_line_create] for more documentation.
pub fn command_line_create() -> Option<CommandLine> {
    unsafe {
        let result = cef_command_line_create();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_command_line_get_global] for more documentation.
pub fn command_line_get_global() -> Option<CommandLine> {
    unsafe {
        let result = cef_command_line_get_global();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_task_runner_get_for_current_thread] for more documentation.
pub fn task_runner_get_for_current_thread() -> Option<TaskRunner> {
    unsafe {
        let result = cef_task_runner_get_for_current_thread();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_task_runner_get_for_thread] for more documentation.
pub fn task_runner_get_for_thread(thread_id: ThreadId) -> Option<TaskRunner> {
    unsafe {
        let arg_thread_id = thread_id;
        let arg_thread_id = arg_thread_id.as_raw();
        let result = cef_task_runner_get_for_thread(arg_thread_id);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_currently_on] for more documentation.
pub fn currently_on(thread_id: ThreadId) -> ::std::os::raw::c_int {
    unsafe {
        let arg_thread_id = thread_id;
        let arg_thread_id = arg_thread_id.as_raw();
        let result = cef_currently_on(arg_thread_id);
        result.as_wrapper()
    }
}

/// See [cef_post_task] for more documentation.
pub fn post_task(thread_id: ThreadId, task: Option<&mut impl ImplTask>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_thread_id, arg_task) = (thread_id, task);
        let arg_thread_id = arg_thread_id.as_raw();
        let arg_task = arg_task
            .map(|arg| {
                arg.add_ref();
                ImplTask::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_post_task(arg_thread_id, arg_task);
        result.as_wrapper()
    }
}

/// See [cef_post_delayed_task] for more documentation.
pub fn post_delayed_task(
    thread_id: ThreadId,
    task: Option<&mut impl ImplTask>,
    delay_ms: i64,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_thread_id, arg_task, arg_delay_ms) = (thread_id, task, delay_ms);
        let arg_thread_id = arg_thread_id.as_raw();
        let arg_task = arg_task
            .map(|arg| {
                arg.add_ref();
                ImplTask::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_delay_ms = arg_delay_ms;
        let result = cef_post_delayed_task(arg_thread_id, arg_task, arg_delay_ms);
        result.as_wrapper()
    }
}

/// See [cef_v8context_get_current_context] for more documentation.
pub fn v8context_get_current_context() -> Option<V8context> {
    unsafe {
        let result = cef_v8context_get_current_context();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8context_get_entered_context] for more documentation.
pub fn v8context_get_entered_context() -> Option<V8context> {
    unsafe {
        let result = cef_v8context_get_entered_context();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8context_in_context] for more documentation.
pub fn v8context_in_context() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_v8context_in_context();
        result.as_wrapper()
    }
}

/// See [cef_v8value_create_undefined] for more documentation.
pub fn v8value_create_undefined() -> Option<V8value> {
    unsafe {
        let result = cef_v8value_create_undefined();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_null] for more documentation.
pub fn v8value_create_null() -> Option<V8value> {
    unsafe {
        let result = cef_v8value_create_null();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_bool] for more documentation.
pub fn v8value_create_bool(value: ::std::os::raw::c_int) -> Option<V8value> {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_bool(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_int] for more documentation.
pub fn v8value_create_int(value: i32) -> Option<V8value> {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_int(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_uint] for more documentation.
pub fn v8value_create_uint(value: u32) -> Option<V8value> {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_uint(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_double] for more documentation.
pub fn v8value_create_double(value: f64) -> Option<V8value> {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_double(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_date] for more documentation.
pub fn v8value_create_date(date: _cef_basetime_t) -> Option<V8value> {
    unsafe {
        let arg_date = date;
        let result = cef_v8value_create_date(arg_date);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_string] for more documentation.
pub fn v8value_create_string(value: Option<&CefStringUtf16>) -> Option<V8value> {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_v8value_create_string(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_object] for more documentation.
pub fn v8value_create_object(
    accessor: Option<&mut impl ImplV8accessor>,
    interceptor: Option<&mut impl ImplV8interceptor>,
) -> Option<V8value> {
    unsafe {
        let (arg_accessor, arg_interceptor) = (accessor, interceptor);
        let arg_accessor = arg_accessor
            .map(|arg| {
                arg.add_ref();
                ImplV8accessor::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_interceptor = arg_interceptor
            .map(|arg| {
                arg.add_ref();
                ImplV8interceptor::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_v8value_create_object(arg_accessor, arg_interceptor);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_array] for more documentation.
pub fn v8value_create_array(length: ::std::os::raw::c_int) -> Option<V8value> {
    unsafe {
        let arg_length = length;
        let arg_length = arg_length;
        let result = cef_v8value_create_array(arg_length);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_array_buffer] for more documentation.
pub fn v8value_create_array_buffer(
    buffer: *mut u8,
    length: usize,
    release_callback: Option<&mut impl ImplV8arrayBufferReleaseCallback>,
) -> Option<V8value> {
    unsafe {
        let (arg_buffer, arg_length, arg_release_callback) = (buffer, length, release_callback);
        let arg_buffer = arg_buffer as *mut _;
        let arg_length = arg_length;
        let arg_release_callback = arg_release_callback
            .map(|arg| {
                arg.add_ref();
                ImplV8arrayBufferReleaseCallback::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_v8value_create_array_buffer(arg_buffer, arg_length, arg_release_callback);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_array_buffer_with_copy] for more documentation.
pub fn v8value_create_array_buffer_with_copy(buffer: *mut u8, length: usize) -> Option<V8value> {
    unsafe {
        let (arg_buffer, arg_length) = (buffer, length);
        let arg_buffer = arg_buffer as *mut _;
        let arg_length = arg_length;
        let result = cef_v8value_create_array_buffer_with_copy(arg_buffer, arg_length);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_function] for more documentation.
pub fn v8value_create_function(
    name: Option<&CefStringUtf16>,
    handler: Option<&mut impl ImplV8handler>,
) -> Option<V8value> {
    unsafe {
        let (arg_name, arg_handler) = (name, handler);
        let arg_name = arg_name.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplV8handler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_v8value_create_function(arg_name, arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8value_create_promise] for more documentation.
pub fn v8value_create_promise() -> Option<V8value> {
    unsafe {
        let result = cef_v8value_create_promise();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_v8stack_trace_get_current] for more documentation.
pub fn v8stack_trace_get_current(frame_limit: ::std::os::raw::c_int) -> Option<V8stackTrace> {
    unsafe {
        let arg_frame_limit = frame_limit;
        let arg_frame_limit = arg_frame_limit;
        let result = cef_v8stack_trace_get_current(arg_frame_limit);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_register_extension] for more documentation.
pub fn register_extension(
    extension_name: Option<&CefStringUtf16>,
    javascript_code: Option<&CefStringUtf16>,
    handler: Option<&mut impl ImplV8handler>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_extension_name, arg_javascript_code, arg_handler) =
            (extension_name, javascript_code, handler);
        let arg_extension_name = arg_extension_name
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let arg_javascript_code = arg_javascript_code
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplV8handler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_register_extension(arg_extension_name, arg_javascript_code, arg_handler);
        result.as_wrapper()
    }
}

/// See [cef_register_scheme_handler_factory] for more documentation.
pub fn register_scheme_handler_factory(
    scheme_name: Option<&CefStringUtf16>,
    domain_name: Option<&CefStringUtf16>,
    factory: Option<&mut impl ImplSchemeHandlerFactory>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_scheme_name, arg_domain_name, arg_factory) = (scheme_name, domain_name, factory);
        let arg_scheme_name = arg_scheme_name
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let arg_domain_name = arg_domain_name
            .map(|arg| arg.as_raw())
            .unwrap_or(std::ptr::null());
        let arg_factory = arg_factory
            .map(|arg| {
                arg.add_ref();
                ImplSchemeHandlerFactory::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result =
            cef_register_scheme_handler_factory(arg_scheme_name, arg_domain_name, arg_factory);
        result.as_wrapper()
    }
}

/// See [cef_clear_scheme_handler_factories] for more documentation.
pub fn clear_scheme_handler_factories() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_clear_scheme_handler_factories();
        result.as_wrapper()
    }
}

/// See [cef_execute_process] for more documentation.
pub fn execute_process(
    args: Option<&MainArgs>,
    application: Option<&mut impl ImplApp>,
    windows_sandbox_info: *mut u8,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_args, arg_application, arg_windows_sandbox_info) =
            (args, application, windows_sandbox_info);
        let arg_args = arg_args.cloned().map(|arg| arg.into());
        let arg_args = arg_args
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_application = arg_application
            .map(|arg| {
                arg.add_ref();
                ImplApp::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_windows_sandbox_info = arg_windows_sandbox_info as *mut _;
        let result = cef_execute_process(arg_args, arg_application, arg_windows_sandbox_info);
        result.as_wrapper()
    }
}

/// See [cef_initialize] for more documentation.
pub fn initialize(
    args: Option<&MainArgs>,
    settings: Option<&Settings>,
    application: Option<&mut impl ImplApp>,
    windows_sandbox_info: *mut u8,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_args, arg_settings, arg_application, arg_windows_sandbox_info) =
            (args, settings, application, windows_sandbox_info);
        let arg_args = arg_args.cloned().map(|arg| arg.into());
        let arg_args = arg_args
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_application = arg_application
            .map(|arg| {
                arg.add_ref();
                ImplApp::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_windows_sandbox_info = arg_windows_sandbox_info as *mut _;
        let result = cef_initialize(
            arg_args,
            arg_settings,
            arg_application,
            arg_windows_sandbox_info,
        );
        result.as_wrapper()
    }
}

/// See [cef_get_exit_code] for more documentation.
pub fn get_exit_code() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_get_exit_code();
        result.as_wrapper()
    }
}

/// See [cef_shutdown] for more documentation.
pub fn shutdown() {
    unsafe {
        let result = cef_shutdown();
        result.as_wrapper()
    }
}

/// See [cef_do_message_loop_work] for more documentation.
pub fn do_message_loop_work() {
    unsafe {
        let result = cef_do_message_loop_work();
        result.as_wrapper()
    }
}

/// See [cef_run_message_loop] for more documentation.
pub fn run_message_loop() {
    unsafe {
        let result = cef_run_message_loop();
        result.as_wrapper()
    }
}

/// See [cef_quit_message_loop] for more documentation.
pub fn quit_message_loop() {
    unsafe {
        let result = cef_quit_message_loop();
        result.as_wrapper()
    }
}

/// See [cef_urlrequest_create] for more documentation.
pub fn urlrequest_create(
    request: Option<&mut impl ImplRequest>,
    client: Option<&mut impl ImplUrlrequestClient>,
    request_context: Option<&mut impl ImplRequestContext>,
) -> Option<Urlrequest> {
    unsafe {
        let (arg_request, arg_client, arg_request_context) = (request, client, request_context);
        let arg_request = arg_request
            .map(|arg| {
                arg.add_ref();
                ImplRequest::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplUrlrequestClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_urlrequest_create(arg_request, arg_client, arg_request_context);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_label_button_create] for more documentation.
pub fn label_button_create(
    delegate: Option<&mut impl ImplButtonDelegate>,
    text: Option<&CefStringUtf16>,
) -> Option<LabelButton> {
    unsafe {
        let (arg_delegate, arg_text) = (delegate, text);
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplButtonDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let result = cef_label_button_create(arg_delegate, arg_text);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_menu_button_create] for more documentation.
pub fn menu_button_create(
    delegate: Option<&mut impl ImplMenuButtonDelegate>,
    text: Option<&CefStringUtf16>,
) -> Option<MenuButton> {
    unsafe {
        let (arg_delegate, arg_text) = (delegate, text);
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplMenuButtonDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_text = arg_text.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let result = cef_menu_button_create(arg_delegate, arg_text);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_textfield_create] for more documentation.
pub fn textfield_create(delegate: Option<&mut impl ImplTextfieldDelegate>) -> Option<Textfield> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplTextfieldDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_textfield_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_browser_view_create] for more documentation.
pub fn browser_view_create(
    client: Option<&mut impl ImplClient>,
    url: Option<&CefStringUtf16>,
    settings: Option<&BrowserSettings>,
    extra_info: Option<&mut impl ImplDictionaryValue>,
    request_context: Option<&mut impl ImplRequestContext>,
    delegate: Option<&mut impl ImplBrowserViewDelegate>,
) -> Option<BrowserView> {
    unsafe {
        let (arg_client, arg_url, arg_settings, arg_extra_info, arg_request_context, arg_delegate) =
            (client, url, settings, extra_info, request_context, delegate);
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_url = arg_url.map(|arg| arg.as_raw()).unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_extra_info = arg_extra_info
            .map(|arg| {
                arg.add_ref();
                ImplDictionaryValue::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplBrowserViewDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_view_create(
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
            arg_delegate,
        );
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_browser_view_get_for_browser] for more documentation.
pub fn browser_view_get_for_browser(browser: Option<&mut impl ImplBrowser>) -> Option<BrowserView> {
    unsafe {
        let arg_browser = browser;
        let arg_browser = arg_browser
            .map(|arg| {
                arg.add_ref();
                ImplBrowser::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_view_get_for_browser(arg_browser);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_scroll_view_create] for more documentation.
pub fn scroll_view_create(delegate: Option<&mut impl ImplViewDelegate>) -> Option<ScrollView> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplViewDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_scroll_view_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_display_get_primary] for more documentation.
pub fn display_get_primary() -> Option<Display> {
    unsafe {
        let result = cef_display_get_primary();
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_display_get_nearest_point] for more documentation.
pub fn display_get_nearest_point(
    point: Option<&Point>,
    input_pixel_coords: ::std::os::raw::c_int,
) -> Option<Display> {
    unsafe {
        let (arg_point, arg_input_pixel_coords) = (point, input_pixel_coords);
        let arg_point = arg_point.cloned().map(|arg| arg.into());
        let arg_point = arg_point
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_input_pixel_coords = arg_input_pixel_coords;
        let result = cef_display_get_nearest_point(arg_point, arg_input_pixel_coords);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_display_get_matching_bounds] for more documentation.
pub fn display_get_matching_bounds(
    bounds: Option<&Rect>,
    input_pixel_coords: ::std::os::raw::c_int,
) -> Option<Display> {
    unsafe {
        let (arg_bounds, arg_input_pixel_coords) = (bounds, input_pixel_coords);
        let arg_bounds = arg_bounds.cloned().map(|arg| arg.into());
        let arg_bounds = arg_bounds
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_input_pixel_coords = arg_input_pixel_coords;
        let result = cef_display_get_matching_bounds(arg_bounds, arg_input_pixel_coords);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_display_get_count] for more documentation.
pub fn display_get_count() -> usize {
    unsafe {
        let result = cef_display_get_count();
        result.as_wrapper()
    }
}

/// See [cef_display_get_alls] for more documentation.
pub fn display_get_alls(displays: Option<&mut Vec<Option<Display>>>) {
    unsafe {
        let arg_displays = displays;
        let mut out_displays_count = arg_displays
            .as_ref()
            .map(|arg| arg.len())
            .unwrap_or_default();
        let arg_displays_count = &mut out_displays_count;
        let out_displays = arg_displays;
        let mut vec_displays = out_displays
            .as_ref()
            .map(|arg| {
                arg.iter()
                    .map(|elem| {
                        elem.as_ref()
                            .map(|elem| {
                                elem.add_ref();
                                elem.get_raw()
                            })
                            .unwrap_or(std::ptr::null_mut())
                    })
                    .collect::<Vec<_>>()
            })
            .unwrap_or_default();
        let arg_displays = if vec_displays.is_empty() {
            std::ptr::null_mut()
        } else {
            vec_displays.as_mut_ptr()
        };
        let result = cef_display_get_alls(arg_displays_count, arg_displays);
        if let Some(out_displays) = out_displays {
            *out_displays = vec_displays
                .into_iter()
                .take(out_displays_count)
                .map(|elem| {
                    if elem.is_null() {
                        None
                    } else {
                        Some(elem.as_wrapper())
                    }
                })
                .collect();
        }
        result.as_wrapper()
    }
}

/// See [cef_display_convert_screen_point_to_pixels] for more documentation.
pub fn display_convert_screen_point_to_pixels(point: Option<&Point>) -> Point {
    unsafe {
        let arg_point = point;
        let arg_point = arg_point.cloned().map(|arg| arg.into());
        let arg_point = arg_point
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_point_to_pixels(arg_point);
        result.as_wrapper()
    }
}

/// See [cef_display_convert_screen_point_from_pixels] for more documentation.
pub fn display_convert_screen_point_from_pixels(point: Option<&Point>) -> Point {
    unsafe {
        let arg_point = point;
        let arg_point = arg_point.cloned().map(|arg| arg.into());
        let arg_point = arg_point
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_point_from_pixels(arg_point);
        result.as_wrapper()
    }
}

/// See [cef_display_convert_screen_rect_to_pixels] for more documentation.
pub fn display_convert_screen_rect_to_pixels(rect: Option<&Rect>) -> Rect {
    unsafe {
        let arg_rect = rect;
        let arg_rect = arg_rect.cloned().map(|arg| arg.into());
        let arg_rect = arg_rect
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_rect_to_pixels(arg_rect);
        result.as_wrapper()
    }
}

/// See [cef_display_convert_screen_rect_from_pixels] for more documentation.
pub fn display_convert_screen_rect_from_pixels(rect: Option<&Rect>) -> Rect {
    unsafe {
        let arg_rect = rect;
        let arg_rect = arg_rect.cloned().map(|arg| arg.into());
        let arg_rect = arg_rect
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_rect_from_pixels(arg_rect);
        result.as_wrapper()
    }
}

/// See [cef_panel_create] for more documentation.
pub fn panel_create(delegate: Option<&mut impl ImplPanelDelegate>) -> Option<Panel> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplPanelDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_panel_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}

/// See [cef_window_create_top_level] for more documentation.
pub fn window_create_top_level(delegate: Option<&mut impl ImplWindowDelegate>) -> Option<Window> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplWindowDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_window_create_top_level(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.as_wrapper())
        }
    }
}
